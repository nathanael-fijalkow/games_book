
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Algorithms &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Bibliographic references" href="references.html" />
    <link rel="prev" title="Relations between all games" href="relations.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../1_Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../2_Regular/index.html">
   Regular Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/attractors.html">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/buchi.html">
     Büchi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../3_Parity/index.html">
   Parity Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Games with Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../5_MDP/index.html">
   Markov Decision Processes
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reachability.html">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Stochastic Games
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="determinacy.html">
     Positional determinacy of stochastic reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="relations.html">
     Relations between all games
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Information
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../7_Concurrent/index.html">
   Concurrent Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/matrix_games.html">
     Matrix games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/reachability.html">
     Concurrent reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/mean_payoff.html">
     Concurrent mean-payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/references.html">
     Bibilographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../8_Imperfect/index.html">
   Games with Signals
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/finite_duration.html">
     Finite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/infinite_duration.html">
     Infinite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Infinite
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../9_Timed/index.html">
   Timed Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/state_space_representation.html">
     State-Space Representation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/controllable_predecessor_operator.html">
     Controllable-Predecessor Operator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/backward_algorithm.html">
     Backward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/forward_algorithm.html">
     Forward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../10_Pushdown/index.html">
   Pushdown Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/profiles.html">
     Profiles and regularity of the winning regions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/parity.html">
     Parity pushdown games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../11_Counters/index.html">
   Games with Counters
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/counters.html">
     Vector games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/dim1.html">
     Games in dimension one
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/avag.html">
     Asymmetric games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/resource.html">
     Resource-conscious games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/complexity.html">
     The complexity of asymmetric monotone games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Multi
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../12_Multiobjectives/index.html">
   Games with multiple objectives
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/mean_payoff_energy.html">
     Mean-payoff and energy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/total_payoff_shortest_path.html">
     Total-payoff and shortest path
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/beyond_worst_case.html">
     Beyond worst-case synthesis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/percentile.html">
     Percentile queries
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../13_Multiplayer/index.html">
   Multiplayer Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/nash_equilibria_normal_form.html">
     Nash Equilibria for games in normal form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/admissible_strategies.html">
     Admissible strategies
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#value-iteration">
   Value iteration
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#strategy-enumeration-and-strategy-improvement-algorithms">
   Strategy enumeration and strategy improvement algorithms
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#computing-almost-sure-winning-or-almost-sure-losing-states">
     Computing almost-sure winning or almost-sure losing states
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#permutation-of-random-vertices">
     Permutation of random vertices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#live-and-self-consistent-permutations">
     Live and self-consistent permutations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#correctness-of-live-and-self-consistent-permutations">
     Correctness of live and self-consistent permutations
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#existence-of-a-live-and-self-consistent-permutation">
     Existence of a live and self-consistent permutation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#complexity-analysis">
     Complexity analysis
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#strategy-enumeration-algorithm">
     Strategy enumeration algorithm
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#strategy-improvement-algorithm">
     Strategy improvement algorithm
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mathematical-programming">
   Mathematical programming
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="algorithms">
<span id="sec-algos"></span><h1>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h1>
<div class="math notranslate nohighlight">
\[\renewcommand{\Game}{\game}
\]</div>
<p>We have shown that stochastic reachability games are central to the (quantitative) analysis of stochastic games.
We have indeed reduced the quantitative analysis of all kinds of stochastic games to stochastic reachability games. We will now present algorithms for stochastic reachability games.</p>
<div class="section" id="value-iteration">
<h2>Value iteration<a class="headerlink" href="#value-iteration" title="Permalink to this headline">¶</a></h2>
<div class="proof definition admonition" id="definition-0">
<p class="admonition-title"><span class="caption-number">Definition 212 </span> (NEEDS TITLE AND LABEL)</p>
<div class="definition-content section" id="proof-content">
<p>A stochastic arena <span class="math notranslate nohighlight">\(\mathcal{A} = ( V,E,\delta)\)</span> is said to be
<strong>simple</strong> if</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(V\)</span> contains two sink vertices <span class="math notranslate nohighlight">\(v_{ \textrm{Eve}}\)</span> and <span class="math notranslate nohighlight">\(v_{ \textrm{Adam}}\)</span>;</p></li>
<li><p>every non-sink vertex
<span class="math notranslate nohighlight">\(v \in  V \setminus \{v_{ \textrm{Eve}},v_{ \textrm{Adam}}\}\)</span> has two
successors;</p></li>
<li><p>every random vertex <span class="math notranslate nohighlight">\(v \in   V_{\text{Rand}}\)</span> is an
<strong>average vertex</strong>, that is, for every vertex
<span class="math notranslate nohighlight">\(v'\in  V\)</span>, <span class="math notranslate nohighlight">\((v,v') \in E\)</span> implies
<span class="math notranslate nohighlight">\(\delta(v,v')=\frac{1}{2}\)</span>.</p></li>
</ul>
<p>A stochastic arena <span class="math notranslate nohighlight">\(\mathcal{A} = ( V,E,\delta)\)</span> is said to be
<strong>simple</strong> if</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(V\)</span> contains two sink vertices <span class="math notranslate nohighlight">\(v_{ \textrm{Eve}}\)</span> and <span class="math notranslate nohighlight">\(v_{ \textrm{Adam}}\)</span>;</p></li>
<li><p>every non-sink vertex
<span class="math notranslate nohighlight">\(v \in  V \setminus \{v_{ \textrm{Eve}},v_{ \textrm{Adam}}\}\)</span> has two
successors;</p></li>
<li><p>every random vertex <span class="math notranslate nohighlight">\(v \in   V_{\text{Rand}}\)</span> is an
<strong>average vertex</strong>, that is, for every vertex
<span class="math notranslate nohighlight">\(v'\in  V\)</span>, <span class="math notranslate nohighlight">\((v,v') \in E\)</span> implies
<span class="math notranslate nohighlight">\(\delta(v,v')=\frac{1}{2}\)</span>.</p></li>
</ul>
</div>
</div><p>With a simple stochastic arena is naturally associated the
reachability objective <span class="math notranslate nohighlight">\(\mathtt{Reach}(\{v_{ \textrm{Eve}}\})\)</span>. The resulting game is
called a <strong>simple stochastic game</strong>.</p>
<div class="proof proposition admonition" id="proposition-1">
<p class="admonition-title"><span class="caption-number">Proposition 213 </span> (NEEDS TITLE AND LABEL)</p>
<div class="proposition-content section" id="proof-content">
<p>There exists a polynomial time transformation from stochastic games
to simple stochastic games, which preserves the values.</p>
<p>There exists a polynomial time transformation from stochastic games
to simple stochastic games, which preserves the values.</p>
</div>
</div><p>More precisely,</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Let <span class="math notranslate nohighlight">\(\mathcal{A} = ( V,E,\delta)\)</span> be an arbitrary stochastic
arena. First of all, all vertices in <span class="math notranslate nohighlight">\(\textrm{Win}\)</span> are merged into a single
sink vertex <span class="math notranslate nohighlight">\(v_\textrm{Eve}\)</span>.</p>
<p>Assume <span class="math notranslate nohighlight">\(v \in   V_{\text{Rand}}\)</span> is a random vertex with <span class="math notranslate nohighlight">\(k\)</span> outgoing
edges, with probabilities <span class="math notranslate nohighlight">\(p_1, \cdots, p_k\)</span>, leading respectively
to <span class="math notranslate nohighlight">\(v_1,\cdots,v_k\)</span>. We first introduce intermediary vertices in
order to build a binary tree, whose leaves are <span class="math notranslate nohighlight">\(v_1 \cdots v_k\)</span>,
root is <span class="math notranslate nohighlight">\(v\)</span>, and probabilities are set at each level of the tree in
order to recover <span class="math notranslate nohighlight">\(p_1, \cdots p_k\)</span> on the respective branches. This
introduces <span class="math notranslate nohighlight">\(O(\log(k))\)</span> fresh vertices, and is illustrated on an
example on <a class="reference internal" href="#fig-gen2binary"><span class="std std-numref">Fig. 54</span></a>.</p>
<div class="figure align-center" id="fig-gen2binary">
<img alt="../_images/6-fig:gen2binary.png" src="../_images/6-fig:gen2binary.png" />
<p class="caption"><span class="caption-number">Fig. 54 </span><span class="caption-text">From general random vertices to binary ones.</span><a class="headerlink" href="#fig-gen2binary" title="Permalink to this image">¶</a></p>
</div>
<p>It remains to explain how to simulate a discrete probability
distribution from say vertex <span class="math notranslate nohighlight">\(v\)</span> to vertices <span class="math notranslate nohighlight">\(v_1\)</span> and <span class="math notranslate nohighlight">\(v_2\)</span> with
probabilities <span class="math notranslate nohighlight">\(\frac{p}{q}\)</span>, resp.  <span class="math notranslate nohighlight">\(\frac{q-p}{q}\)</span>, using average
vertices only.  We let <span class="math notranslate nohighlight">\(t \in \mathbb{N}\)</span> be such that
<span class="math notranslate nohighlight">\(2^{t-1} \leq q &lt; 2^{t}\)</span>. Using the binary encodings of <span class="math notranslate nohighlight">\(p\)</span> resp.
<span class="math notranslate nohighlight">\(q-p\)</span> as <span class="math notranslate nohighlight">\(a_1 \cdots a_t\)</span> resp. <span class="math notranslate nohighlight">\(b_1 \cdots b_t\)</span> (with most
significant bit first) we build the following gadget. The input
vertex is <span class="math notranslate nohighlight">\(v\)</span> and for every <span class="math notranslate nohighlight">\(2 \leq i \leq t+1\)</span>, it has two exit
edges with accumulated probabilities <span class="math notranslate nohighlight">\(2^{-i}\)</span>. Now, if <span class="math notranslate nohighlight">\(a_i=1\)</span>
(resp.  <span class="math notranslate nohighlight">\(b_1 =1\)</span>), one vertex with probability <span class="math notranslate nohighlight">\(2^{-(i+1)}\)</span> is <span class="math notranslate nohighlight">\(v_1\)</span>
(resp. <span class="math notranslate nohighlight">\(v_2\)</span>). The pending edges are redirected to <span class="math notranslate nohighlight">\(v\)</span> itself. The
transformation is depicted in <a class="reference internal" href="#fig-simul"><span class="std std-numref">Fig. 55</span></a>, assuming
<span class="math notranslate nohighlight">\(p=11\equiv_{b} 1011\)</span> and <span class="math notranslate nohighlight">\(q=14\)</span> (so that
<span class="math notranslate nohighlight">\(p-q = 3 \equiv_{b} 0011\)</span>).  For simplicity some vertices are
represented several times to avoid intricate transitions. One can
check that this gadget indeed simulates probabilities <span class="math notranslate nohighlight">\(\frac p q\)</span> to
<span class="math notranslate nohighlight">\(v_1\)</span> and <span class="math notranslate nohighlight">\(\frac {q-p} q\)</span> to <span class="math notranslate nohighlight">\(v_2\)</span>.</p>
<div class="figure align-center" id="fig-simul">
<img alt="../_images/6-fig:simul.png" src="../_images/6-fig:simul.png" />
<p class="caption"><span class="caption-number">Fig. 55 </span><span class="caption-text">From binary random vertices to average ones.</span><a class="headerlink" href="#fig-simul" title="Permalink to this image">¶</a></p>
</div>
<p>For vertices owned by either of the two players, only the first step
of the above transformation is needed (injection of a binary tree).</p>
<p>The overall transformation yields a simple stochastic game with
<span class="math notranslate nohighlight">\(O(n(\log(n)+k))\)</span> additional vertices, where <span class="math notranslate nohighlight">\(k\)</span> is the maximum
number of bits required to represent probabilities in
<span class="math notranslate nohighlight">\(\mathcal{G}\)</span>. Moreover, for vertices in <span class="math notranslate nohighlight">\(V'\)</span> that were originally
in <span class="math notranslate nohighlight">\(V\)</span>, the value is preserved.</p>
</div>
<div class="proof definition admonition" id="definition-2">
<p class="admonition-title"><span class="caption-number">Definition 214 </span> (NEEDS TITLE AND LABEL)</p>
<div class="definition-content section" id="proof-content">
<p>A simple stochastic game is <strong>stopping</strong> if for every vertex
<span class="math notranslate nohighlight">\(v \in  V\)</span> and under every \nat{pure positional} strategy profile
<span class="math notranslate nohighlight">\((\sigma,\tau)\)</span>, <span class="math notranslate nohighlight">\(\mathbb{P}_{\sigma,\tau}^v( \mathtt{Reach}(\{v_\textrm{Eve},v_\textrm{Adam}\})) &gt;0\)</span>.</p>
<p>A simple stochastic game is <strong>stopping</strong> if for every vertex
<span class="math notranslate nohighlight">\(v \in  V\)</span> and under every \nat{pure positional} strategy profile
<span class="math notranslate nohighlight">\((\sigma,\tau)\)</span>, <span class="math notranslate nohighlight">\(\mathbb{P}_{\sigma,\tau}^v( \mathtt{Reach}(\{v_\textrm{Eve},v_\textrm{Adam}\})) &gt;0\)</span>.</p>
</div>
</div><div class="proof theorem admonition" id="6-thm:reduction_stopping_games">
<p class="admonition-title"><span class="caption-number">Theorem 215 </span> (Reduction to stopping games)</p>
<div class="theorem-content section" id="proof-content">
<p>For every simple stochastic game, one can build a  stopping  one, such that the value is <span class="math notranslate nohighlight">\(&gt; \frac{1}{2}\)</span> is the original game iff it is <span class="math notranslate nohighlight">\(&gt;\frac{1}{2}\)</span> in the stopping game.</p>
</div>
</div><p>Caution: the transformation from general SSG to stopping
SSG does not preserve the value! more precisely, one can approximate
up to an arbitrary precision the value in an SSG by the value in a
stopping one by decreasing the fixed termination probability at each step.</p>
<div class="proof proposition admonition" id="6-prop:fixed_point_characterisation_stopping_ssg">
<p class="admonition-title"><span class="caption-number">Proposition 216 </span> (Fixed point characterisation for stopping simple stochastic games)</p>
<div class="proposition-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> be a stopping simple stochastic game. Then, the operator <span class="math notranslate nohighlight">\(\mathfrak{F}\)</span> has a unique fixpoint.</p>
</div>
</div><p>The first proof of determinacy of those games already gave a first
value iteration algorithm. This was first due to Shapley under the
hypothesis of stopping games.</p>
</div>
<div class="section" id="strategy-enumeration-and-strategy-improvement-algorithms">
<h2>Strategy enumeration and strategy improvement algorithms<a class="headerlink" href="#strategy-enumeration-and-strategy-improvement-algorithms" title="Permalink to this headline">¶</a></h2>
<p>We have seen in Section <a class="reference internal" href="determinacy.html#sec-determinacy"><span class="std std-ref">Positional determinacy of stochastic reachability games</span></a> that stochastic
reachability games are positionally determined: there are optimal
pure positional strategies for both players. We present here a
strategy improvement algorithm to compute the values at each vertex of
the game, and strategies achieving these values.</p>
<p>The algorithm focuses on the role of random vertices in the game, and
is based on the fact that amongst two random vertices, one of them is
likely to be better for  \textrm{Eve}, while the other will be better for  \textrm{Adam}
(or they are equally good). We will start proving a strategy
enumeration algorithm, where, given a permutation of the set of random
vertices, one computes adequate strategies for  \textrm{Eve} and  \textrm{Adam}; under
some assumptions on the permutation (liveness and self-consistency),
those strategies will be provably optimal. We will show that there
will be some live and self-consistent permutation, implying the
correctness and completeness of the algorithm. Based on this approach,
we will design a strategy improvement algorithm.</p>
<p>We start with the strategy enumeration algorithm
(Subsection <span class="xref std std-ref">6-subsec:first</span> to Subsection <span class="xref std std-ref">6-subsec:last</span>), and will
conclude with the strategy improvement algorithm
(Subsection <span class="xref std std-ref">6-subsec:algo-strat-improv</span>).</p>
<div class="section" id="computing-almost-sure-winning-or-almost-sure-losing-states">
<span id="subsubsec-first"></span><h3>Computing almost-sure winning or almost-sure losing states<a class="headerlink" href="#computing-almost-sure-winning-or-almost-sure-losing-states" title="Permalink to this headline">¶</a></h3>
<p>The algorithms we will present assume that games are
<strong>normalized</strong>, that is, there is a unique vertex denoted <span class="math notranslate nohighlight">\(v_{win}\)</span>
(resp. <span class="math notranslate nohighlight">\(v_{lose}\)</span>) with value <span class="math notranslate nohighlight">\(1\)</span> (resp. <span class="math notranslate nohighlight">\(0\)</span>).  This is without loss of
generality since:</p>
<ul class="simple">
<li><p>vertices with value <span class="math notranslate nohighlight">\(1\)</span> (resp. <span class="math notranslate nohighlight">\(0\)</span>) can be computed in
polynomial time;</p></li>
<li><p>all vertices with value <span class="math notranslate nohighlight">\(1\)</span> (resp. <span class="math notranslate nohighlight">\(0\)</span>) can be replaced by a
single sink vertex <span class="math notranslate nohighlight">\(v_{win}\)</span> (resp. <span class="math notranslate nohighlight">\(v_{lose}\)</span>);</p></li>
<li><p>the target reachability state is set to <span class="math notranslate nohighlight">\(v_{win}\)</span>.</p></li>
</ul>
<p>The only point that we will discuss is the first item above. General
transformations assigning a non-stochastic parity game to each
stochastic parity game, which allow to compute almost-sure winning
states, have been developed. \pat{it would be nice to cite
here <span id="id1">[<span>CJH-csl03</span>]</span>} However, we focus on the simpler reachability
games that we are focusing on, and we briefly describe the
construction here, inspired by <span id="id2">[<span>paulin-nathalie</span>]</span>:</p>
<ul class="simple">
<li><p>For computing vertices with value <span class="math notranslate nohighlight">\(1\)</span>: replace a random vertex
<span class="math notranslate nohighlight">\(v\)</span> with an  \textrm{Adam} vertex <span class="math notranslate nohighlight">\(v_A\)</span> and an  \textrm{Eve} vertex <span class="math notranslate nohighlight">\(v_E\)</span>. Any edge
going to <span class="math notranslate nohighlight">\(v\)</span> in the original game will go to <span class="math notranslate nohighlight">\(v_A\)</span>; there will be an
edge <span class="math notranslate nohighlight">\(v_A \to v_E\)</span> with priority <span class="math notranslate nohighlight">\(1\)</span>; if <span class="math notranslate nohighlight">\(v \to v'\)</span> in the original
game, then <span class="math notranslate nohighlight">\(v_A \to v'\)</span> with priority <span class="math notranslate nohighlight">\(2\)</span> in the new game, and <span class="math notranslate nohighlight">\(v_E
\to v'\)</span> with priority <span class="math notranslate nohighlight">\(1\)</span> in the new game. We add a selfloop over
<span class="math notranslate nohighlight">\(\textrm{Win}\)</span> with priority <span class="math notranslate nohighlight">\(2\)</span>. Then, a vertex is almost-sure winning
(that is, has value <span class="math notranslate nohighlight">\(1\)</span>) in the original game if and only if it is
winning in the constructed non-stochastic parity game.</p></li>
<li><p>For computing vertices with value <span class="math notranslate nohighlight">\(0\)</span>: give each random vertex
<span class="math notranslate nohighlight">\(v\)</span> to  \textrm{Adam}. Then, a vertex has value <span class="math notranslate nohighlight">\(0\)</span> in the original game if
and only if it is losing in the constructed non-stochastic parity
game.</p></li>
</ul>
<p>From now on, we assume that the game <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> is normalized.</p>
</div>
<div class="section" id="permutation-of-random-vertices">
<h3>Permutation of random vertices<a class="headerlink" href="#permutation-of-random-vertices" title="Permalink to this headline">¶</a></h3>
<p>Assume that from vertex <span class="math notranslate nohighlight">\(v\)</span> belonging to  \textrm{Eve}, one can choose between
two random vertices <span class="math notranslate nohighlight">\(v_1\)</span> and <span class="math notranslate nohighlight">\(v_2\)</span> such that the value of <span class="math notranslate nohighlight">\(v_1\)</span> is
larger than the value of <span class="math notranslate nohighlight">\(v_2\)</span>, then obviously  \textrm{Eve} should choose to
go to <span class="math notranslate nohighlight">\(v_1\)</span>. The idea will then be for  \textrm{Eve} to target random vertices
with the largest possible values. We formalize this idea below</p>
<p>We write <span class="math notranslate nohighlight">\(V_{\text{Rand}} = \{v_1,\ldots,v_k\}\)</span>.</p>
<p>The idea will be to order random vertices in such a way that the
higher is a random vertice (in the order), the better it is for  \textrm{Eve};
and conversely, the smaller is a random vertice (in the order), the
worse it is for  \textrm{Adam}. We fix a permutation
<span class="math notranslate nohighlight">\(\pi:   V_{\text{Rand}} \to   V_{\text{Rand}}\)</span>, and abusively write
<span class="math notranslate nohighlight">\(\pi_i =  \pi^{-1}(v_i)\)</span>, the <span class="math notranslate nohighlight">\(i\)</span>-th element in the order defined
by <span class="math notranslate nohighlight">\(\pi\)</span>.</p>
<p>We define the deterministic attractor operator <span class="math notranslate nohighlight">\(**DetAtt**\)</span> as
follows. If <span class="math notranslate nohighlight">\(X \subseteq  V\)</span>, we define inductively the
sequence <span class="math notranslate nohighlight">\((X_i)_{i \ge 0}\)</span> by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left\{
\begin{array}{rcl}
  X_0 &amp; =&amp; X \\
  X_{i+1} &amp;=&amp; X_i \cup \{v \in   V_\mathrm{Eve} \mid \exists w \in X_i\
  \text{s.t.}\ (v,w) \in E\} \\
   &amp;&amp; \phantom{X_i} \cup \{v \in   V_\mathrm{Adam} \mid \forall w \in X_i,\ 
  (v,w) \in E\ \text{implies}\ v \in X_i\}
\end{array}
\right.
\end{split}\]</div>
<p>The deterministic attractor of <span class="math notranslate nohighlight">\(X\)</span> is then given by:</p>
<div class="math notranslate nohighlight">
\[
 **DetAtt**(X) = \lim_{i \to +\infty} X_i = \bigcup_{i =0}^{+\infty} X_i
\]</div>
<p>Note that since <span class="math notranslate nohighlight">\(V\)</span> is finite, the sequence <span class="math notranslate nohighlight">\((X_i)_{i \ge 0}\)</span>
stabilizes and the above union is actually finite.  \pat{refer to the
relevant previous chapter, there certainly is one.}</p>
<p>Let <span class="math notranslate nohighlight">\(\pi\)</span> be a permutation. We define the <span class="math notranslate nohighlight">\(\pi\)</span>-regions as
deterministic attractors to the random vertices (taken in the correct
order) as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left\{
\begin{array}{l}
  W_\pi^{k+1}  = \{ v_{win}\} \\
  W_\pi^i =
   **DetAtt**(\{ \pi_i,\ldots, \pi_k, v_{win}\}) \setminus \bigcup_{j=i+1}^{k+1}
  W_\pi^j\quad \forall 1 \le i \le k \\ 
  W_\pi^0 = V \setminus \bigcup_{j=1}^{k+1} W_\pi^j = \{ v_{lose}\}
\end{array}
\right.
\end{split}\]</div>
<p>The last equality (for <span class="math notranslate nohighlight">\(W_\pi^0\)</span>) holds since (i) from vertices in
<span class="math notranslate nohighlight">\(W_\pi^0\)</span>  \textrm{Adam} can enforce avoiding <span class="math notranslate nohighlight">\(V_{\text{Rand}} \cup
\{ v_{win}\}\)</span> (by determinacy of non-stochastic reachability games
\pat{ref to a previous chapter?}), yielding only losing outcomes, and
(ii) <span class="math notranslate nohighlight">\(v_{lose}\)</span> is the unique vertex with value <span class="math notranslate nohighlight">\(0\)</span> (by
assumption). Later, we will write <span class="math notranslate nohighlight">\(W_\pi^{\ge j}\)</span> for
<span class="math notranslate nohighlight">\(\bigcup_{i=j}^{k+1} W_\pi^i\)</span>.</p>
<p>Given <span class="math notranslate nohighlight">\(\pi\)</span> a permutation, we define strategies <span class="math notranslate nohighlight">\(\sigma_\pi\)</span> (for
\textrm{Eve}) and <span class="math notranslate nohighlight">\(\tau_\pi\)</span> (for  \textrm{Adam}) such that on <span class="math notranslate nohighlight">\(W_\pi^i\)</span>:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\sigma_\pi\)</span> is a pure and positional attractor strategy to
<span class="math notranslate nohighlight">\(\{ \pi_i,\ldots, \pi_k, v_{win}\}\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\tau_\pi\)</span> is a pure and positional trapping strategy avoiding
<span class="math notranslate nohighlight">\(\{ \pi_{i+1},\ldots, \pi_k, v_{win}\}\)</span>.</p></li>
</ul>
<p>Those two strategies obviously exist: <span class="math notranslate nohighlight">\(\sigma_\pi\)</span> exists by
definition of the deterministic attractor, while <span class="math notranslate nohighlight">\(\tau_\pi\)</span> exists
by determinacy of reachability games (if a vertex is not winning for
\textrm{Eve} for a reachability objective, then it is winning for  \textrm{Adam} for
the corresponding safety objective).</p>
<p>We can then define for every <span class="math notranslate nohighlight">\(v \in  V\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\begin{array}{rcl}
  \textrm{val}_\pi(v) &amp;=&amp;  \mathbb{P}_{\sigma_\pi,\tau_\pi}^v( \mathtt{Reach}( \textrm{Win}))
\end{array}
\]</div>
<p>which can be easily computed using systems of linear
equations.</p>
<p>The rest of this section is devoted to a proof of the following
result, which uses only basic arguments:</p>
<div class="proof theorem admonition" id="6-thm:corr-strat-improv">
<p class="admonition-title"><span class="caption-number">Theorem 217 </span> (NEEDS TITLE 6-thm:corr-strat-improv)</p>
<div class="theorem-content section" id="proof-content">
<p>There is a permutation <span class="math notranslate nohighlight">\(\pi\)</span> such that <span class="math notranslate nohighlight">\(\sigma_\pi\)</span> is optimal
for  \textrm{Eve} and <span class="math notranslate nohighlight">\(\tau_\pi\)</span> is optimal for  \textrm{Adam}. Given a permutation
<span class="math notranslate nohighlight">\(\pi\)</span>, we can check in polynomial time whether <span class="math notranslate nohighlight">\(\sigma_\pi\)</span> and
<span class="math notranslate nohighlight">\(\tau_\pi\)</span> are optimal.</p>
</div>
</div><p>We will explain in Subsection <span class="xref std std-ref">6-subsec:algo-strat-improv</span> how this
theorem can be turned into a strategy improvement algorithm for
computing values and optimal strategies in stochastic reachability
games.</p>
</div>
<div class="section" id="live-and-self-consistent-permutations">
<h3>Live and self-consistent permutations<a class="headerlink" href="#live-and-self-consistent-permutations" title="Permalink to this headline">¶</a></h3>
<p>We say that a permutation <span class="math notranslate nohighlight">\(\pi\)</span> is <strong>self-consistent</strong> whenever:</p>
<div class="math notranslate nohighlight">
\[
  \textrm{val}_\pi( \pi_1) \le   \textrm{val}_\pi( \pi_2) \le \ldots \le   \textrm{val}_\pi( \pi_k)
\]</div>
<p>That is, the order given by <span class="math notranslate nohighlight">\(\pi\)</span> coincides with the preference of
\textrm{Eve}.</p>
<p>We say <span class="math notranslate nohighlight">\(\pi\)</span> is <strong>live</strong> whenever for every <span class="math notranslate nohighlight">\(1 \le i \le k\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\delta( \pi_i)\big(W_\pi^{\ge i+1}\big)&gt;0
\]</div>
<p>That is, there is a direct move from <span class="math notranslate nohighlight">\(\pi_i\)</span> to one of the vertices
in larger attractors. In particular, with positive probability, one
goes closer to <span class="math notranslate nohighlight">\(v_{win}\)</span> and hence eventually reach <span class="math notranslate nohighlight">\(v_{win}\)</span>.</p>
<p>We will show that <span class="math notranslate nohighlight">\(\pi\)</span>-strategies associated with a live
and self-consistent permutation <span class="math notranslate nohighlight">\(\pi\)</span> are optimal for both players.
And that such a permutation always exists. We start with the
correctness, and will turn to the existence later.</p>
</div>
<div class="section" id="correctness-of-live-and-self-consistent-permutations">
<h3>Correctness of live and self-consistent permutations<a class="headerlink" href="#correctness-of-live-and-self-consistent-permutations" title="Permalink to this headline">¶</a></h3>
<p>We first give some properties always satisfied by strategies
<span class="math notranslate nohighlight">\(\sigma_\pi\)</span> and <span class="math notranslate nohighlight">\(\tau_\pi\)</span> without any condition on <span class="math notranslate nohighlight">\(\pi\)</span>, and
refine these properties to show that <span class="math notranslate nohighlight">\(\sigma_\pi\)</span> and <span class="math notranslate nohighlight">\(\tau_\pi\)</span>
are (local) best responses to each others, when the permutation is
self-consistent.</p>
<div class="proof lemma admonition" id="stoch:lemma2">
<p class="admonition-title"><span class="caption-number">Lemma 218 </span> (NEEDS TITLE stoch:lemma2)</p>
<div class="lemma-content section" id="proof-content">
<p>We write (\ddag) for the assumption that <span class="math notranslate nohighlight">\(\pi\)</span> is self-consistent.</p>
<ol class="simple">
<li><p><span class="math notranslate nohighlight">\(\textrm{val}_\pi( v_{lose}) = 0\)</span> and <span class="math notranslate nohighlight">\(\textrm{val}_\pi( v_{win}) = 1\)</span>;</p></li>
<li><p>for every <span class="math notranslate nohighlight">\(1 \le i \le k\)</span>, for every <span class="math notranslate nohighlight">\(v \in W_\pi^i\)</span>,
<span class="math notranslate nohighlight">\(\textrm{val}_\pi(v) =   \textrm{val}_\pi( \pi_i)\)</span>;</p></li>
<li><p>For every <span class="math notranslate nohighlight">\(v \in   V_\mathrm{Eve}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[
      \textrm{val}_\pi(v) =   \textrm{val}_\pi(\sigma_\pi(v)) \stackrel{(\ddag)}{=}
    \max_{w\ \text{s.t.}\ (v,w) \in E}   \textrm{val}_\pi(w)
    \]</div>
<ol class="simple">
<li><p>For every <span class="math notranslate nohighlight">\(v \in   V_\mathrm{Adam}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[
      \textrm{val}_\pi(v) =   \textrm{val}_\pi(\tau_\pi(v)) \stackrel{(\ddag)}{=}
    \min_{w\ \text{s.t.}\ (v,w) \in E}   \textrm{val}_\pi(w)
    \]</div>
<ol class="simple">
<li><p>For every <span class="math notranslate nohighlight">\(v \in   V_{\text{Rand}}\)</span>, <span class="math notranslate nohighlight">\(\textrm{val}_\pi(v) = \sum_{w\
\text{s.t.}\ (v,w) \in E} \delta(v)(w) \cdot   \textrm{val}_\pi(w)\)</span>.</p></li>
</ol>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>The first item is obvious.</p>
<p>For every <span class="math notranslate nohighlight">\(v \in W_\pi^i\)</span>, up to the first visit to a random
vertex, the strategy profile <span class="math notranslate nohighlight">\((\sigma_\pi,\tau_\pi)\)</span> generates a
unique path. So we can speak of the first random vertex encountered
from <span class="math notranslate nohighlight">\(v\)</span> when applying <span class="math notranslate nohighlight">\((\sigma_\pi,\tau_\pi)\)</span>. By definition of
<span class="math notranslate nohighlight">\(\sigma_\pi\)</span> (attractor to <span class="math notranslate nohighlight">\(\{ \pi_i,\ldots, \pi_k, v_{win}\}\)</span>) and
<span class="math notranslate nohighlight">\(\tau_\pi\)</span> (trapping strategy avoiding
<span class="math notranslate nohighlight">\(\{ \pi_{i+1},\ldots, \pi_k, v_{win}\}\)</span>), this random vertex can only
be <span class="math notranslate nohighlight">\(\pi_i\)</span>. According values follow, proving the second item.</p>
<p>Assume <span class="math notranslate nohighlight">\(v \in   V_\mathrm{Eve} \cap W_\pi^i\)</span>.  By definition of
<span class="math notranslate nohighlight">\(\sigma_\pi\)</span> (being an attractor strategy), <span class="math notranslate nohighlight">\(\sigma_\pi(v) \in
  W_\pi^i \cup \{ \pi_i,\ldots, \pi_k, v_{win}\}\)</span>. Dually, since <span class="math notranslate nohighlight">\(v
  \notin W_\pi^{\ge i+1}\)</span>, <span class="math notranslate nohighlight">\(\sigma_\pi(v) \notin
  \{ \pi_{i+1},\ldots, \pi_k, v_{win}\}\)</span>. Hence, <span class="math notranslate nohighlight">\(\sigma_\pi(v) \in
  W_\pi^i \cup \{ \pi_i\} = W_\pi^i\)</span>, and we get that
<span class="math notranslate nohighlight">\(\textrm{val}_\pi(v) =   \textrm{val}_\pi( \pi_i) =   \textrm{val}_\pi(\sigma_\pi(v))\)</span>.
Assume (towards a contradiction) that there is <span class="math notranslate nohighlight">\(w \in  V\)</span>
such that <span class="math notranslate nohighlight">\((v,w) \in E\)</span> and <span class="math notranslate nohighlight">\(\textrm{val}_\pi(w)&gt;  \textrm{val}_\pi(v)\)</span>.  Since
<span class="math notranslate nohighlight">\(\textrm{val}_\pi(w) &gt;   \textrm{val}_\pi(v) =   \textrm{val}_\pi( \pi_i)\)</span>, by
self-consistence, it is the case that <span class="math notranslate nohighlight">\(w \in W_\pi^j\)</span> with <span class="math notranslate nohighlight">\(j &gt; i\)</span>
(with <span class="math notranslate nohighlight">\(\textrm{val}_\pi(w) =   \textrm{val}_\pi( \pi_j)\)</span>). But then, we can
deduce that <span class="math notranslate nohighlight">\(v \in  **DetAtt**(w) \subseteq
   **DetAtt**(\{ \pi_j,\ldots, \pi_k, v_{win}\})\)</span>, which is not the case,
since <span class="math notranslate nohighlight">\(v \notin W_\pi^{\ge i+1} \supseteq W_\pi^j\)</span>. There is
therefore a contradiction, and we can conclude that <span class="math notranslate nohighlight">\(\textrm{val}_\pi(v) =
  \max_{w\ \text{s.t.}\ (v,w) \in E}   \textrm{val}_\pi(w)\)</span>.</p>
<p>Assume <span class="math notranslate nohighlight">\(v \in   V_\mathrm{Adam} \cap W_\pi^i\)</span>. By definition of
<span class="math notranslate nohighlight">\(\sigma_\pi\)</span> (being a trapping strategy), <span class="math notranslate nohighlight">\(\tau_\pi(v) \notin
  \{ \pi_{i+1},\ldots, \pi_k, v_{win}\}\)</span>. However since <span class="math notranslate nohighlight">\(v \in
  W_\pi^i\)</span>, we nevertheless have that <span class="math notranslate nohighlight">\(\tau_\pi(v) \in W_\pi^i
  \cup \{ \pi_i,\ldots, \pi_k, v_{win}\}\)</span>, hence <span class="math notranslate nohighlight">\(\tau_\pi(v) \in
  W_\pi^i \cup \{ \pi_i\} = W_\pi^i\)</span>. Hence <span class="math notranslate nohighlight">\(\textrm{val}_\pi(v) =
    \textrm{val}_\pi( \pi_i) =   \textrm{val}_\pi(\tau_\pi(v))\)</span>.  Assume (towards a
contradiction) that there is <span class="math notranslate nohighlight">\(w \in  V\)</span> such that <span class="math notranslate nohighlight">\((v,w) \in
  E\)</span> and <span class="math notranslate nohighlight">\(\textrm{val}_\pi(w)&lt;  \textrm{val}_\pi(v)\)</span>. As in the previous item, by
self-consistence, <span class="math notranslate nohighlight">\(w \in W_\pi^j\)</span> with <span class="math notranslate nohighlight">\(j&lt;i\)</span>. But, <span class="math notranslate nohighlight">\(v\)</span> can only be
in a deterministic attractor if all its successors already are. This
contradicts the fact that <span class="math notranslate nohighlight">\(w \in W_\pi^j\)</span>, hence <span class="math notranslate nohighlight">\(w \notin
  W_\pi^{\ge j+1} \supseteq W_\pi^i\)</span>. Hence, we conclude that
<span class="math notranslate nohighlight">\(\textrm{val}_\pi(v) = \min_{w\ \text{s.t.}\ (v,w) \in E}   \textrm{val}_\pi(w)\)</span>.</p>
<p>The fifth item is straightforward hence omitted.  \qed</p>
</div>
<p>As a consequence of <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:lemma2</span></code>, we get that <span class="math notranslate nohighlight">\(\textrm{val}_\pi\)</span>
is a fixpoint of Bellman’s equations, hence it is larger than (or
equal to) the least fixpoint of Bellman’s equations, that is <span class="math notranslate nohighlight">\(\textrm{val}^*\)</span>:</p>
<div class="proof corollary admonition" id="corollary-7">
<p class="admonition-title"><span class="caption-number">Corollary 219 </span> (NEEDS TITLE AND LABEL)</p>
<div class="corollary-content section" id="proof-content">
<p>Assume <span class="math notranslate nohighlight">\(\pi\)</span> is self-consistent.  Then for every <span class="math notranslate nohighlight">\(v \in
   V\)</span>, <span class="math notranslate nohighlight">\(\textrm{val}^*(v) \le   \textrm{val}_\pi(v)\)</span>.</p>
<p>Assume <span class="math notranslate nohighlight">\(\pi\)</span> is self-consistent.  Then for every <span class="math notranslate nohighlight">\(v \in
   V\)</span>, <span class="math notranslate nohighlight">\(\textrm{val}^*(v) \le   \textrm{val}_\pi(v)\)</span>.</p>
</div>
</div><p>The converse inequality is not true for general or self-consistent
permutations, but will require the liveness property. One of the main
advantages of a live permutation <span class="math notranslate nohighlight">\(\pi\)</span> is that it induces a
stopping MDP when  \textrm{Eve} plays according to <span class="math notranslate nohighlight">\(\sigma_\pi\)</span>:  \textrm{Adam}
will not be able to prevent the game converging to <span class="math notranslate nohighlight">\(v_{lose}\)</span> and <span class="math notranslate nohighlight">\(v_{win}\)</span>.</p>
<div class="proof lemma admonition" id="stoch:lemma:stopping">
<p class="admonition-title"><span class="caption-number">Lemma 220 </span> (NEEDS TITLE stoch:lemma:stopping)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\pi\)</span> be a live permutation. Then, for every  \textrm{Adam}’s strategy
<span class="math notranslate nohighlight">\(\tau\)</span>, for every vertex <span class="math notranslate nohighlight">\(v\)</span>:</p>
<div class="math notranslate nohighlight">
\[
   \mathbb{P}^v_{\sigma_\pi,\tau} ( \mathtt{Reach}(\{ v_{lose}, v_{win}\})) = 1
  \]</div>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We make use of the progress property induced by a live permutation.
Let</p>
<div class="math notranslate nohighlight">
\[
  \alpha = \min_{1 \le i \le k} \delta( \pi_i) \big(W_\pi^{\ge
    i+1}\big)
  \]</div>
<p>By definition of a live permutation, <span class="math notranslate nohighlight">\(\alpha&gt;0\)</span>.</p>
<p>We write <span class="math notranslate nohighlight">\(V_i\)</span> for the random variable representing the <span class="math notranslate nohighlight">\(i\)</span>-th state
of a run.</p>
<p>By definition of <span class="math notranslate nohighlight">\(\alpha\)</span>, for every <span class="math notranslate nohighlight">\(v \in  V\)</span>, for every <span class="math notranslate nohighlight">\(1
  \le i \le k\)</span> and for every <span class="math notranslate nohighlight">\(l \ge 0\)</span>,</p>
<div class="math notranslate nohighlight">
\[
   \mathbb{P}^v_{\sigma_\pi,\tau}\Big(V_{l+1} \in W_\pi^{\ge i+1} \mid
  V_l =  \pi_i\Big) \ge \alpha
  \]</div>
<p>Also, for every <span class="math notranslate nohighlight">\(1 \le i \le k\)</span>, for every <span class="math notranslate nohighlight">\(v \in  V\)</span>, for
every <span class="math notranslate nohighlight">\(l \ge 0\)</span>,</p>
<div class="math notranslate nohighlight">
\[
   \mathbb{P}^v_{\sigma_\pi,\tau}\Big(\exists h &lt; |W_\pi^i|\
  \text{s.t.}\ V_{l+h} \in \{ \pi_i,\ldots, \pi_k, v_{win}\} \mid V_l
  \in W_\pi^i\Big)=1
  \]</div>
<p>since <span class="math notranslate nohighlight">\(\sigma_\pi\)</span> plays according to attractor strategies in
according subsets of vertices.</p>
<p>Hence we deduce that for every <span class="math notranslate nohighlight">\(v \in  V\)</span>, for every <span class="math notranslate nohighlight">\(l \ge
  0\)</span>,</p>
<div class="math notranslate nohighlight">
\[
   \mathbb{P}^v_{\sigma_\pi,\tau}\Big(V_{l+| V|}= v_{win} \mid V_l
  \ne  v_{lose}\Big) \ge \alpha^k
  \]</div>
<p>which we can rewrite as:</p>
<div class="math notranslate nohighlight">
\[
   \mathbb{P}^v_{\sigma_\pi,\tau}\Big(\forall 0 \le l \le l' \le
  l+| V|,\ V_{l'} \ne  v_{win} \mid V_l \ne  v_{lose}\Big) \le
  (1-\alpha^k)
  \]</div>
<p>Iterating, we get that for every <span class="math notranslate nohighlight">\(i\)</span>, for every <span class="math notranslate nohighlight">\(v \in  V\)</span>,</p>
<div class="math notranslate nohighlight">
\[
   \mathbb{P}^v_{\sigma_\pi,\tau}\Big(\forall l \le i \cdot | V|,\
  V_{l} \ne  v_{win} \mid V_0 \ne  v_{lose}\Big) \le (1-\alpha^k)^i
  \]</div>
<p>We  deduce that for every <span class="math notranslate nohighlight">\(v \in  V\)</span>,</p>
<div class="math notranslate nohighlight">
\[
   \mathbb{P}^v_{\sigma_\pi,\tau}(\forall l \ge 0,\ V_l \ne  v_{win} \mid
  V_0 \ne  v_{lose}) = 0
  \]</div>
<p>We conclude with</p>
<div class="math notranslate nohighlight">
\[
   \mathbb{P}^v_{\sigma_\pi,\tau}(\exists l \ge 0,\ V_l =  v_{win} \mid V_0
  \ne  v_{lose}) = 1
  \]</div>
<p>hence with the statement.</p>
</div>
<div class="proof lemma admonition" id="lemma-9">
<p class="admonition-title"><span class="caption-number">Lemma 221 </span> (NEEDS TITLE AND LABEL)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\pi\)</span> be a live and self-consistent permutation.  Then for
every <span class="math notranslate nohighlight">\(v \in  V\)</span>,  <span class="math notranslate nohighlight">\(\textrm{val}_\pi(v) \le   \textrm{val}^*(v)\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(\pi\)</span> be a live and self-consistent permutation.  Then for
every <span class="math notranslate nohighlight">\(v \in  V\)</span>,  <span class="math notranslate nohighlight">\(\textrm{val}_\pi(v) \le   \textrm{val}^*(v)\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Fix a pure positional  \textrm{Adam}’s strategy <span class="math notranslate nohighlight">\(\tau\)</span>. The tuple
<span class="math notranslate nohighlight">\(( \mathbb{P}_{\sigma_\pi,\tau}^v( \mathtt{Reach}( \textrm{Win})))_{v \in  V}\)</span> is
a</p>
<p>solution to the following equations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \left\{\begin{array}{ll} x_v =
      x_{\tau(v)} &amp; \text{if}\ v \in   V_\mathrm{Adam} \\
      x_v = x_{\sigma_\pi(v)} &amp; \text{if}\ v \in   V_\mathrm{Eve} \\
      x_v = \sum_{w\ \text{s.t.}\ (v,w) \in E} \delta(v)(w) \cdot
      x_w  &amp; \text{if}\ v \in   V_{\text{Rand}} \\
      x_{ v_{win}} = 1 \\
      x_{ v_{lose}} = 0
    \end{array}\right.
  \end{split}\]</div>
<p>In particular, it is a solution to the following inequations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \left\{\begin{array}{ll} 
      x_v \ge \min_{w\ \text{s.t.}\ (v,w) \in E}
      x_w &amp; \text{if}\ v \in   V_\mathrm{Adam} \\
      x_v = x_{\sigma_\pi(v)}  &amp; \text{if}\ v \in   V_\mathrm{Eve} \\
      x_v = \sum_{w\ \text{s.t.}\ (v,w) \in E} \delta(v)(w) \cdot x_w
      &amp; \text{if}\ v \in   V_{\text{Rand}} \\
      x_{ v_{win}} = 1 \\
      x_{ v_{lose}} = 0
    \end{array}\right.
  \end{split}\]</div>
<p>Since the MDP (when <span class="math notranslate nohighlight">\(\sigma_\pi\)</span> has been fixed) is stopping (see <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:stopping</span></code>), there is no proper end-component
(except <span class="math notranslate nohighlight">\(\{ v_{win}\}\)</span> and <span class="math notranslate nohighlight">\(\{ v_{lose}\}\)</span>), and the above system of
inequations has a unique minimal solution, which is the unique
solution of the same system with <span class="math notranslate nohighlight">\(=\)</span> instead of <span class="math notranslate nohighlight">\(\ge\)</span>.</p>
<p>On the other hand <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:lemma2</span></code> tells us that
<span class="math notranslate nohighlight">\((  \textrm{val}_\pi(v))_{v \in V}\)</span> can only be that unique
solution. Hence, for every <span class="math notranslate nohighlight">\(v \in  V\)</span>:</p>
<div class="math notranslate nohighlight">
\[
    \textrm{val}_\pi(v) \le  \mathbb{P}_{\sigma_\pi,\tau}^v( \mathtt{Reach}( \textrm{Win}))
  \]</div>
<p>Since this holds for every pure positional strategy <span class="math notranslate nohighlight">\(\tau\)</span> of  \textrm{Adam},
we conclude that for every <span class="math notranslate nohighlight">\(v \in  V\)</span>,
<span class="math notranslate nohighlight">\(\textrm{val}_\pi(v) \le   \textrm{val}^*(v)\)</span>. \qed</p>
</div>
<div class="proof corollary admonition" id="stoch:coro">
<p class="admonition-title"><span class="caption-number">Corollary 222 </span> (NEEDS TITLE stoch:coro)</p>
<div class="corollary-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\pi\)</span> be a live and self-consistent permutation. Then, for
every <span class="math notranslate nohighlight">\(v \in  V\)</span>, <span class="math notranslate nohighlight">\(\textrm{val}^*(v) =   \textrm{val}_\pi(v)\)</span>.</p>
</div>
</div></div>
<div class="section" id="existence-of-a-live-and-self-consistent-permutation">
<h3>Existence of a live and self-consistent permutation<a class="headerlink" href="#existence-of-a-live-and-self-consistent-permutation" title="Permalink to this headline">¶</a></h3>
<div class="proof lemma admonition" id="stoch:lemma:croissant">
<p class="admonition-title"><span class="caption-number">Lemma 223 </span> (NEEDS TITLE stoch:lemma:croissant)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\pi\)</span> be a live permutation such that</p>
<div class="math notranslate nohighlight">
\[
    \textrm{val}^*( \pi_1) \le   \textrm{val}^*( \pi_2) \le \ldots \le   \textrm{val}^*( \pi_k)
  \]</div>
<p>Then, <span class="math notranslate nohighlight">\(\pi\)</span> is self-consistent.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We will show that for every vertex <span class="math notranslate nohighlight">\(v \in  V\)</span>, <span class="math notranslate nohighlight">\(\textrm{val}^*(v) =
    \textrm{val}_\pi(v)\)</span>. This will ne enough for proving the expected result.</p>
<p>We first show a counterpart to <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:lemma2</span></code> for
<span class="math notranslate nohighlight">\(\textrm{val}^*\)</span>:</p>
<div class="proof lemma admonition" id="lemma-12">
<p class="admonition-title"><span class="caption-number">Lemma 224 </span> (NEEDS TITLE AND LABEL)</p>
<div class="lemma-content section" id="proof-content">
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Same hypotheses as {prf:ref}`6-lem:croissant`. Then:

1.  $\textrm{val}^*( v_{lose}) = 0$ and $\textrm{val}^*( v_{win}) = 1$;
2.  for every $1 \le i \le k$, for every $v \in W_\pi^i$,
  $\textrm{val}^*(v) =   \textrm{val}^*( \pi_i)$.

Same hypotheses as {prf:ref}`6-lem:croissant`. Then:

1.  $\textrm{val}^*( v_{lose}) = 0$ and $\textrm{val}^*( v_{win}) = 1$;
2.  for every $1 \le i \le k$, for every $v \in W_\pi^i$,
  $\textrm{val}^*(v) =   \textrm{val}^*( \pi_i)$.
</pre></div>
</div>
</div>
</div></div>
<p>\begin{proof}
Notice that item 1 is obvious.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>We then focus on item 2.  Assume $v \in W_\pi^i$, and define
strategy $\sigma^*$ from $v$ as $\sigma_\pi$ (attractor strategy
to $\{ \pi_i,\ldots, \pi_k, v_{win}\}$) until $v_{win}$ or a random
vertex $\pi_j$ ($j \ge i$) is reached; in the latter case, switch
to an optimal strategy out of $\pi_j$. We obviously get that for
every strategy $\tau$ for  \textrm{Adam},
$\mathbb{P}_{\sigma^*,\tau}^v( \mathtt{Reach}(\{ v_{win}\})) \ge \min_{i \le j \le
  k}  \textrm{val}^*( \pi_j) =   \textrm{val}^*( \pi_i)$. Hence $\textrm{val}^*(v) \ge
  \textrm{val}^*( \pi_i)$.

Conversely define strategy $\tau^*$ from $v$ as $\tau_\pi$
(trapping strategy out of $\{ \pi_{i+1},\ldots, \pi_k, v_{win}\}$)
until $v_{lose}$ or a random vertex $\pi_j$ ($j \le i$) is reached;
in the latter case, switch to an optimal strategy out of
$\pi_j$. Note that it can a priori be the case that we never hit
$v_{lose}$ or a random vertex, but this is good to  \textrm{Adam}. However we
can conclude that for every strategy $\sigma$ for  \textrm{Eve},
$\mathbb{P}_{\sigma,\tau^*}^v( \mathtt{Reach}(\{ v_{win}\})) \le \max_{1 \le j \le
  i}  \textrm{val}^*( \pi_j) =   \textrm{val}^*( \pi_i)$. Hence
$\textrm{val}^*(v) \le   \textrm{val}^*( \pi_i)$.

This allows to conclude item 2, hence the lemma.
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
  Both $\textrm{val}^*$ and $\textrm{val}_\pi$ satisfy the system of equations:

$$
  \left\{\begin{array}{ll} 
      x_v = x_{ \pi_i} &amp; \text{if}\ v \in W_\pi^i \\

      x_v = \sum_{w\ \text{s.t.}\ (v,w) \in E} \delta(v)(w) \cdot x_w
      &amp; \text{if}\ v \in   V_{\text{Rand}} \\
      x_{ v_{win}} = 1 \\
      x_{ v_{lose}} = 0
    \end{array}\right.
  $$

  We can rewrite this system into:

$$
  \left\{\begin{array}{ll} 
      x_v = x_{ \pi_i} &amp; \text{if}\ v \in W_\pi^i \\

      x_{ \pi_i} = \sum_{j=0}^{k+1} \delta( \pi_i)(W_\pi^j) \cdot x_{ \pi_j}
      &amp; \\
      x_{ v_{win}} = 1 \\
      x_{ v_{lose}} = 0
    \end{array}\right.
  $$

  Since $\pi$ is live this system has a unique solution!  Hence
  $\textrm{val}^* =   \textrm{val}_\pi$, and $\pi$ is self-consistent.
\end{proof}

It remains to show that there always exist  a live permutation
satisfying the hypothesis of {prf:ref}`6-lem:croissant`.

To do so, we show the following structural property of the game, which
will help building an appropriate live permutation.

````{prf:lemma} NEEDS TITLE stoch:lemma:structure
:label: stoch:lemma:structure

  Let $\{ v_{win}\} \subseteq X \subseteq V$ be a subset of vertices, and
  $Y = V \setminus  **DetAtt**(X)$. Then either $Y = \{ v_{lose}\}$, or there
  is a random vertex $v \in Y$ such that $\textrm{val}^*(v) = \max\{  \textrm{val}^*(w)
  \mid w \in Y\}$ and $\delta(v)\Big( **DetAtt**(X)\Big)&gt;0$.

</pre></div>
</div>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Let <span class="math notranslate nohighlight">\(Z = \textsf{Argmax}_Y (  \textrm{val}^*)\)</span>. We assume that there is no
random vertex <span class="math notranslate nohighlight">\(v \in Z \cap   V_{\text{Rand}}\)</span> such that
<span class="math notranslate nohighlight">\(\delta(v)\Big( **DetAtt**(X)\Big)&gt;0\)</span>. We will show that <span class="math notranslate nohighlight">\(Z =
  \{ v_{lose}\}\)</span>, which will imply <span class="math notranslate nohighlight">\(Y = \{ v_{lose}\}\)</span>. To do so, we show
that if <span class="math notranslate nohighlight">\(v \in Z\)</span>, then <span class="math notranslate nohighlight">\(\textrm{val}^*(v) = 0\)</span>.  We fix <span class="math notranslate nohighlight">\(v \in Z\)</span>, and we
assume towards a contradiction that <span class="math notranslate nohighlight">\(\textrm{val}^*(v)&gt;0\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(\tau\)</span> be a pure positional  \textrm{Adam}’s strategy on <span class="math notranslate nohighlight">\(Y\)</span> avoiding
<span class="math notranslate nohighlight">\(**DetAtt**(X)\)</span>: by definition, <span class="math notranslate nohighlight">\(\tau(Y) \subseteq Y\)</span>. Also, one can
argue that <span class="math notranslate nohighlight">\(\tau(Z) \subseteq Z\)</span>. Indeed otherwise there is <span class="math notranslate nohighlight">\(v' \in
  Z\)</span> such that <span class="math notranslate nohighlight">\(\tau(v') \in Y \setminus Z\)</span>. Thus, <span class="math notranslate nohighlight">\(\textrm{val}^*(\tau(v')) &lt;
    \textrm{val}^*(v')\)</span>, which is not possible since <span class="math notranslate nohighlight">\(\textrm{val}^*(v') = \min_{w\
    \text{s.t.}\ (v',w) \in E}   \textrm{val}^*(w)\)</span> (Bellman’s equations). Also
by Bellman’s equations, if <span class="math notranslate nohighlight">\(v' \in   V_{\text{Rand}} \cap Z\)</span>, for
every <span class="math notranslate nohighlight">\(w'\)</span> such that <span class="math notranslate nohighlight">\(\delta(v')(w')&gt;0\)</span>, <span class="math notranslate nohighlight">\(\textrm{val}^*(w') =
    \textrm{val}^*(v')\)</span>. By assumption, it cannot be the case that <span class="math notranslate nohighlight">\(w' \in
   **DetAtt**(X)\)</span>, hence <span class="math notranslate nohighlight">\(w' \in Z\)</span>.  Let <span class="math notranslate nohighlight">\(v' \in Z \cap   V_\mathrm{Eve}\)</span>. If
there is <span class="math notranslate nohighlight">\(w' \notin Z\)</span> such that <span class="math notranslate nohighlight">\((v',w') \in E\)</span>, then it must be
the case that <span class="math notranslate nohighlight">\(w' \in Y \setminus Z\)</span>: indeed, it cannot be the case
that <span class="math notranslate nohighlight">\(w' \in  **DetAtt**(X)\)</span>, otherwise <span class="math notranslate nohighlight">\(v'\)</span> would also be in
<span class="math notranslate nohighlight">\(**DetAtt**(X)\)</span>.</p>
<p>We now define strategy <span class="math notranslate nohighlight">\(\tau'\)</span> which plays from <span class="math notranslate nohighlight">\(v\)</span> as <span class="math notranslate nohighlight">\(\tau\)</span> until
<span class="math notranslate nohighlight">\(Z\)</span> is left, and then <span class="math notranslate nohighlight">\(\tau'\)</span> plays an optimal strategy for  \textrm{Adam}.
Let <span class="math notranslate nohighlight">\(\sigma\)</span> be a strategy for  \textrm{Eve}. Under the profile
<span class="math notranslate nohighlight">\((\sigma,\tau')\)</span> from <span class="math notranslate nohighlight">\(v\)</span>, either we stay forever in <span class="math notranslate nohighlight">\(Z\)</span>, or we
leave at some  \textrm{Eve}’s vertex <span class="math notranslate nohighlight">\(v'\)</span> towards a vertex <span class="math notranslate nohighlight">\(w'\)</span> with
<span class="math notranslate nohighlight">\(\textrm{val}^*(w') &lt;   \textrm{val}^*(v') =   \textrm{val}^*(v)\)</span> (recall the discussion
above). We can then write:
\begin{eqnarray*}
\mathbb{P}<em>{\sigma,\tau’}( \mathtt{Reach}({ v</em>{win}})) &amp;=&amp;
\mathbb{P}<em>{\sigma,\tau’}( \mathtt{Reach}({ v</em>{win}}) \mid \text{stays in}\  Z<br />
\text{forever}) \cdot   \mathbb{P}<em>{\sigma,\tau’}(\text{stays in}\  Z<br />
\text{forever}) \
&amp;&amp; + \sum</em>{(v’,w’) \in (Z \times (Y \setminus Z) \cap E)}
\mathbb{P}<em>{\sigma,\tau’}( \mathtt{Reach}({ v</em>{win}}) \mid
\text{leave via}\  (v’,w’)) \cdot
\mathbb{P}<em>{\sigma,\tau’}(\text{leave via}\  (v’,w’)) \
&amp; = &amp; 0 \cdot  \mathbb{P}</em>{\sigma,\tau’}(\text{stays in}\  Z<br />
\text{forever}) + \sum_{(v’,w’) \in (Z \times (Y \setminus Z) \cap
E)}    \textrm{val}^<em>(w’) \cdot
\mathbb{P}_{\sigma,\tau’}(\text{leave via}\  (v’,w’)) \
&amp; \le &amp; \beta
\end{eqnarray</em>}
where <span class="math notranslate nohighlight">\(\beta = \max \{  \textrm{val}^*(w) \mid w \in Y \setminus Z\} &lt;
    \textrm{val}^*(v)\)</span>.  Hence, we get <span class="math notranslate nohighlight">\(\textrm{val}^*(v) \le \beta &lt;   \textrm{val}^*(v)\)</span>. This
is a contradiction.</p>
</div>
<div class="proof lemma admonition" id="stoch:lemma-existence">
<p class="admonition-title"><span class="caption-number">Lemma 225 </span> (NEEDS TITLE stoch:lemma-existence)</p>
<div class="lemma-content section" id="proof-content">
<p>There is a live and self-consistent permutation.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We will define a permutation <span class="math notranslate nohighlight">\(\pi\)</span> inductively, by repeatedly
using <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:structure</span></code>.  For every <span class="math notranslate nohighlight">\(i =k, \ldots
  ,1\)</span> we define <span class="math notranslate nohighlight">\(\pi_i\)</span> by applying
Lemma <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:structure</span></code> to <span class="math notranslate nohighlight">\(X =
  \{ \pi_{i+1},\ldots, \pi_k, v_{win}\}\)</span>.</p>
<p>By construction,</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(\textrm{val}^*( \pi_i) = \max \{  \textrm{val}^*(v) \mid v \in V \setminus
**DetAtt**(\{ \pi_{i+1},\ldots, \pi_k, v_{win}\})\}\)</span>;</p></li>
<li><div class="highlight-none notranslate"><div class="highlight"><pre><span></span> $\delta( \pi_i)\Big( **DetAtt**(\{ \pi_{i+1},\ldots, \pi_k, v_{win}\})\Big)
</pre></div>
</div>
<blockquote>
<div><p>0$</p>
</div></blockquote>
</li>
</ul>
<p>Hence, <span class="math notranslate nohighlight">\(\pi\)</span> is live, and the hypothesis of <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:croissant</span></code> is satisfied. Hence <span class="math notranslate nohighlight">\(\pi\)</span> is
self-consistent. This concludes the proof.</p>
</div>
</div>
<div class="section" id="complexity-analysis">
<h3>Complexity analysis<a class="headerlink" href="#complexity-analysis" title="Permalink to this headline">¶</a></h3>
<p>To obtain the polynomial-time complexity claimed in <a class="reference internal" href="#6-thm:corr-strat-improv">Theorem 217</a>, we realize that once a
permutation <span class="math notranslate nohighlight">\(\pi\)</span> is fixed, computing the sets <span class="math notranslate nohighlight">\(W_\pi^i\)</span> can be done
in polynomial time (those are simple attractors), and corresponding
strategies <span class="math notranslate nohighlight">\(\sigma_\pi\)</span> and <span class="math notranslate nohighlight">\(\tau_\pi\)</span> can be simultaneously
computed as well. Now, computing <span class="math notranslate nohighlight">\(\textrm{val}_\pi\)</span> reduces to computing the
probability to reach <span class="math notranslate nohighlight">\(v_{win}\)</span> in the induced Markov chain, which is
known to be possible in polynomial time. Note that we could improve
the complexity by reducing the Markov chain to a Markov chain where
the only vertices are <span class="math notranslate nohighlight">\(V_{\text{Rand}} \cup \{ v_{lose}, v_{win}\}\)</span>, but
this would only marginally impact the overall complexity.</p>
</div>
<div class="section" id="strategy-enumeration-algorithm">
<span id="subsubsec-last"></span><h3>Strategy enumeration algorithm<a class="headerlink" href="#strategy-enumeration-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Thanks to <a class="reference internal" href="#6-thm:corr-strat-improv">Theorem 217</a>, we get an algorithm
to compute values and optimal strategies for both players in a
stochastic reachability game: enumerate permutations of random
vertices, and for each of them, check whether it is live and
self-consistent; stop when one is found.</p>
<p>However, as such, this requires to enumerate all permutations of
random vertices, and there are <span class="math notranslate nohighlight">\(|  V_{\text{Rand}}|!\)</span> of them. Hence the
overall complexity of finding the values and the optimal strategies is
exponential.</p>
</div>
<div class="section" id="strategy-improvement-algorithm">
<span id="subsubsec-algo-strat-improv"></span><h3>Strategy improvement algorithm<a class="headerlink" href="#strategy-improvement-algorithm" title="Permalink to this headline">¶</a></h3>
<p>We will describe a strategy improvement algorithm, which may avoid
enumerating all permutations. Note that there is nevertheless no
guarantee that the overall complexity will be betther than the
strategy enumeration algorithm.</p>
<p>The algorithm consists in the following steps:</p>
<ul class="simple">
<li><p>Initialization step: Compute a live permutation <span class="math notranslate nohighlight">\(\pi\)</span></p></li>
<li><p>Improvement step: Given a live permutation <span class="math notranslate nohighlight">\(\pi\)</span>, compute a
live and self-consistent permutation in <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_\pi]\)</span>, the
restriction of game <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> where <span class="math notranslate nohighlight">\(\textrm{Eve}\)</span> always plays according to
<span class="math notranslate nohighlight">\(\sigma_\pi\)</span>.</p></li>
</ul>
<p>Below, since we will speak of games <span class="math notranslate nohighlight">\(\mathcal{G}\)</span>, <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_\pi]\)</span> and
even <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_{ \pi'}]\)</span>, when speaking about the value of the
game, we will specify the game in which we consider the value. For
instance, <span class="math notranslate nohighlight">\(\textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}\)</span> denotes the value vector of the game
<span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_\pi]\)</span>, and <span class="math notranslate nohighlight">\(\textrm{val}_{ \mathcal{G}, \pi}\)</span> denotes the former
<span class="math notranslate nohighlight">\(\textrm{val}_\pi\)</span>.</p>
<p>We will argue (though not with full details) that the following
properties are satisfied by the algorithm:</p>
<ol class="simple">
<li><p>An initial live permutation can be computed in polynomial time.</p></li>
<li><p>For every live permutation <span class="math notranslate nohighlight">\(\pi\)</span>, one can compute in
polynomial time a live and self-consistent permutation <span class="math notranslate nohighlight">\(\pi'\)</span> in
<span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_\pi]\)</span>.</p></li>
<li><p>The above-mentioned permutation <span class="math notranslate nohighlight">\(\pi'\)</span> is live in <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> as
well.</p></li>
<li><p>The improvement step really implements some improvement:</p></li>
</ol>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\textrm{val}^*_{ \mathcal{G}[\sigma_\pi]} \le
 \textrm{val}^*_{ \mathcal{G}[\sigma_{ \pi'}]}\)</span>, and</p></li>
<li><p><span class="math notranslate nohighlight">\(\textrm{val}^*_{ \mathcal{G}[\sigma_\pi]} =
 \textrm{val}^*_{ \mathcal{G}[\sigma_{ \pi'}]}\)</span> implies that <span class="math notranslate nohighlight">\(\pi'\)</span> is
self-consistent.</p></li>
</ul>
<p>The first property is based on the construction of <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:existence</span></code>.</p>
<p>For the second property, we know as a consequence of <a class="reference internal" href="#6-thm:corr-strat-improv">Theorem 217</a> that there exists a live and
self-consistent permutation <span class="math notranslate nohighlight">\(\pi'\)</span> in <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_{ \pi}]\)</span>,
provided we prove that <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_{ \pi}]\)</span> is normalized (this was
a general assumption of the approach, mentioned in Subsection <span class="xref std std-ref">6-subsec:first</span>). This is actually the case since
every proper vertex <span class="math notranslate nohighlight">\(v\)</span> can be proven to have a value strictly within
<span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(1\)</span> in <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_{ \pi}]\)</span> (it is indeed smaller in
<span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_{ \pi}]\)</span> than in <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> since <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_{ \pi}]\)</span>
offers less options to  \textrm{Eve}, and it cannot be <span class="math notranslate nohighlight">\(0\)</span>, using a proof
similar to that of <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:stopping</span></code>).</p>
<p>Now, since <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_\pi]\)</span> turns out to be a Markov decision
process, values of all random vertices can be computed in polynomial
time using linear programming; then we can apply a construction
similar to that of <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:existence</span></code> to get a live and
self-consistent permutation <span class="math notranslate nohighlight">\(\pi'\)</span> in <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_\pi]\)</span>. This
yields a polynomial time algorithm to compute <span class="math notranslate nohighlight">\(\pi'\)</span>.</p>
<p>For the third property, we realize that</p>
<p><span class="math notranslate nohighlight">\(\pi'\)</span>-regions in <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_\pi]\)</span> are included in
<span class="math notranslate nohighlight">\(\pi'\)</span>-regions in <span class="math notranslate nohighlight">\(\mathcal{G}\)</span>, which immediately implies the result.</p>
<p>The last property is harder to argue; it expresses the fact that the
new permutation <span class="math notranslate nohighlight">\(\pi'\)</span> improves over <span class="math notranslate nohighlight">\(\pi\)</span>.</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Since <span class="math notranslate nohighlight">\(\pi'\)</span> is live and self-consistent in <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_\pi]\)</span>,
by <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-cor:</span></code>, extending the previous notations, we
get that
<span class="math notranslate nohighlight">\(\textrm{val}^*_{ \mathcal{G}[\sigma_\pi]} =
    \textrm{val}_{ \mathcal{G}[\sigma_\pi], \pi'}\)</span>. Now, since <span class="math notranslate nohighlight">\(\pi'\)</span> is
self-consistent in <span class="math notranslate nohighlight">\(\mathcal{G}[\sigma_\pi]\)</span>, we deduce that</p>
<div class="math notranslate nohighlight">
\[
      \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi'_1) \le
      \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi'_2) \le \dots \le
      \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi'_k)
  \]</div>
<p>We consider the following family of strategies for  \textrm{Eve} in <span class="math notranslate nohighlight">\(\mathcal{G}\)</span>:
for every <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(\sigma^{(n)}\)</span> is the strategy where  \textrm{Eve} plays
according to <span class="math notranslate nohighlight">\(\sigma_{ \pi'}\)</span> up to its <span class="math notranslate nohighlight">\(n\)</span>-th visit to a random
vertex, and then switches to <span class="math notranslate nohighlight">\(\sigma_\pi\)</span>.</p>
</div>
<p>We can then prove:</p>
<div class="proof lemma admonition" id="6-lem:convergence_sequence_values">
<p class="admonition-title"><span class="caption-number">Lemma 226 </span> (Converge of the sequence of values)</p>
<div class="lemma-content section" id="proof-content">
<p>The sequence <span class="math notranslate nohighlight">\((  \textrm{val}_{ \mathcal{G},\sigma^{(n)}})_n\)</span> is non-decreasing.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>We do the proof by induction on $n$.  We focus on $n=0$, and prove
below that $\textrm{val}_{ \mathcal{G},\sigma^{(1)}} \ge
  \textrm{val}_{ \mathcal{G},\sigma^{(0)}}$. First notice that $\sigma^{(0)} =
\sigma_\pi$.

First, notice that $v \in W_{ \mathcal{G}, \pi&#39;}^i$ for some $i$, and $v
\in W_{ \mathcal{G}[\sigma_\pi], \pi&#39;}^j$ for some $j$. This
$game[ \pi]$ restricts actions of  \textrm{Eve}, we immediately get $i \ge
j$. Hence, applying the line of inequalities at the beginning of
the proof of the larger lemma,
$\textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi&#39;_j) \le
  \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi&#39;_i)$.

If  \textrm{Eve} plays with $\sigma^{(1)}$, the definition of
$\sigma_{ \pi&#39;}$ ensures that the first random vertex (or
terminal vertex) which is visited when starting in $v$ belongs to
$\{ \pi&#39;_i, \pi&#39;_{i+1},\dots, \pi&#39;_k, v_{win}\}$, so since from
that vertex, $\sigma^{(1)}$ plays according to $\sigma_\pi$, we
get:
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[
      \textrm{val}_{ \mathcal{G},\sigma^{(1)}}(v) \ge \min
    \{  \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi'_i),
      \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi'_{i+1}),\dots,
      \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi'_k),1\} \ge
      \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi'_i)
    \]</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>since $\textrm{val}^*_{ \mathcal{G}[\sigma_\pi]} =   \textrm{val}_{ \mathcal{G},\sigma_\pi}$.

Now, when playing $\sigma_\pi = \sigma^{(0)}$ from $v$, 

Thanks to  {prf:ref}`6-lem:lemma2`, since $v \in
W_{ \mathcal{G}[\sigma_\pi], \pi&#39;}^j$,
$\textrm{val}_{ \mathcal{G}[\sigma_\pi], \pi&#39;}(v) =
  \textrm{val}_{ \mathcal{G}[\sigma_\pi], \pi&#39;}( \pi&#39;_j)$ and hence (as argued
in the proof of the larger lemma,
$\textrm{val}_{ \mathcal{G}[\sigma_\pi], \pi&#39;} =
  \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}$), $\textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}(v) =
  \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi&#39;_j)$. We conclude that:
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[
      \textrm{val}_{\sigma_\pi}(v) =   \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}(v) \le
      \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi'_j) \le
      \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]}( \pi'_i) \le
      \textrm{val}_{ \mathcal{G},\sigma^{(1)}}(v)
    \]</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>which concludes the initial case for the induction.

\smallskip The inductive step is then rather straightforward: the
two strategies $\sigma^{(n+2)}$ and $\sigma^{(n+1)}$ coincide
until a first random vertex is encounted, and then the first one
switches to $\sigma^{(n+1)}$ while the other switches to
$\sigma^{(n)}$. Hence, using the induction hypothesis that
$\sigma^{(n+1)}$ is better for  \textrm{Eve} than $\sigma^{(n)}$, we can
conclude.
</pre></div>
</div>
</div>
<p>Let <span class="math notranslate nohighlight">\(\tau\)</span> be an  \textrm{Adam}’s strategy. Since <span class="math notranslate nohighlight">\(\pi'\)</span> has been shown to
be live in <span class="math notranslate nohighlight">\(\mathcal{G}\)</span>, applying  <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">6-lem:stopping</span></code>, we
get that: <span class="math notranslate nohighlight">\(\mathbb{P}^v_{\sigma_{ \pi'},\tau} ( \mathtt{Reach}(\{ v_{win}\})) =
   \mathbb{P}^v_{\sigma_{ \pi'},\tau} (\neg \mathtt{Reach}(\{ v_{lose}\}))\)</span>. This last
probability value coincides with <span class="math notranslate nohighlight">\(\lim_{n \to +\infty}
   \mathbb{P}^v_{\sigma_{ \pi'},\tau} (\neg \mathtt{Reach}_{\le n}(\{ v_{lose}\}))\)</span>,
the probability to not reach <span class="math notranslate nohighlight">\(v_{lose}\)</span> for the first <span class="math notranslate nohighlight">\(n\)</span> visits to a
random vertex; for these <span class="math notranslate nohighlight">\(n\)</span> first visits, <span class="math notranslate nohighlight">\(\sigma_{ \pi'}\)</span>
coincides with <span class="math notranslate nohighlight">\(\sigma^{(n)}\)</span>, hence
<span class="math notranslate nohighlight">\(\mathbb{P}^v_{\sigma_{ \pi'},\tau} ( \mathtt{Reach}(\{ v_{win}\})) \ge \lim_{n\to
    +\infty}  \mathbb{P}^v_{\sigma^{(n)},\tau} ( \mathtt{Reach}(\{ v_{win}\}))\)</span>. By
definition of value in a game, this last term is larger than or
equal to <span class="math notranslate nohighlight">\(\lim_{n \to+\infty}  \textrm{val}_{ \mathcal{G},\sigma^{(n)}}\)</span>, hence
<span class="math notranslate nohighlight">\(\lim_{n \to+\infty}  \textrm{val}_{ \mathcal{G},\sigma^{(n)}} \le
    \textrm{val}_{ \mathcal{G}, \pi'}\)</span>.</p>
<p>We conclude that:</p>
<div class="math notranslate nohighlight">
\[
    \textrm{val}^*_{ \mathcal{G}[\sigma_\pi]} =   \textrm{val}_{ \mathcal{G},\sigma^{(0)}} \le
    \textrm{val}_{ \mathcal{G},\sigma^{(1)}} \le   \textrm{val}_{ \mathcal{G},\sigma^{(2)}} \le \dots\le
  \lim_{n \to +\infty}   \textrm{val}_{ \mathcal{G},\sigma^{(n)}} \le
    \textrm{val}^*_{ \mathcal{G}[\sigma_{ \pi'}]}
  \]</div>
<p>Assume now that <span class="math notranslate nohighlight">\(\textrm{val}^*_{ \mathcal{G}[\sigma_\pi]} =
    \textrm{val}^*_{ \mathcal{G}[\sigma_{ \pi'}]}\)</span>. Then applying the first line of
inequalities above, we get:</p>
<div class="math notranslate nohighlight">
\[
    \textrm{val}^*_{ \mathcal{G}[\sigma_{ \pi'}]}( \pi'_1) \le
    \textrm{val}^*_{ \mathcal{G}[\sigma_{ \pi'}]}( \pi'_2) \le \dots \le
    \textrm{val}^*_{ \mathcal{G}[\sigma_{ \pi'}]}( \pi'_k)
  \]</div>
<p>Now, the strategy <span class="math notranslate nohighlight">\(\tau_{ \pi'}\)</span> is precisely the optimal strategy
against <span class="math notranslate nohighlight">\(\sigma_{ \pi'}\)</span> \pat{Not so sure of the argument, it is
not argued that way in GH09}, hence for every vertex <span class="math notranslate nohighlight">\(v\)</span>:</p>
<div class="math notranslate nohighlight">
\[
    \textrm{val}^*_{ \mathcal{G}[\sigma_{ \pi'}]}(v) = \inf_\tau
   \mathbb{P}^v_{\sigma_{ \pi'},\tau} ( \mathtt{Reach}(\{ v_{win}\})) =
   \mathbb{P}^v_{\sigma_{ \pi'},\tau_{ \pi'}} ( \mathtt{Reach}(\{ v_{win}\})) =
    \textrm{val}_{ \mathcal{G}, \pi'}
  \]</div>
<p>We deduce that</p>
<div class="math notranslate nohighlight">
\[
    \textrm{val}_{ \mathcal{G}, \pi'}( \pi'_1) \le   \textrm{val}_{ \mathcal{G}, \pi'}( \pi'_2) \le
  \dots \le   \textrm{val}_{ \mathcal{G}, \pi'}( \pi'_k)
  \]</div>
<p>which is precisely the definition of a self-consistent permutation
in <span class="math notranslate nohighlight">\(\mathcal{G}\)</span>, so we are done.</p>
<p>\end{proof}</p>
<p>This last property ensures both termination of the algorithm: indeed,
it is ensured by the finiteness of the number of permutations, and by
the improvement characterization above. Note that it may be the case
that in the worst-case, all permutations will be enumerated. No lower
nor upper bound is known no far.</p>
</div>
</div>
<div class="section" id="mathematical-programming">
<h2>Mathematical programming<a class="headerlink" href="#mathematical-programming" title="Permalink to this headline">¶</a></h2>
<p>From Condon’93 resolution of stochastic games (assuming they are
stopping, and with 2 successors only, and proba all 1/2) to quadratic
programming.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./6_Stochastic"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="relations.html" title="previous page">Relations between all games</a>
    <a class='right-next' id="next-link" href="references.html" title="next page">Bibliographic references</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>