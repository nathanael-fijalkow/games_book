
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Memory &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Reductions" href="reductions.html" />
    <link rel="prev" title="Automata" href="automata.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Introduction
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../2_Regular/index.html">
   Regular Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/attractors.html">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/buchi.html">
     Büchi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../3_Parity/index.html">
   Parity Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Games with Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../5_MDP/index.html">
   Markov Decision Processes
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reachability.html">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#positional-strategies">
   Positional strategies
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#uniformity">
   Uniformity
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#finite-memory-strategies-label-1-finite-memory">
   Finite memory strategies}\label{1-finite memory
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="memory">
<span id="sec-memory"></span><h1>Memory<a class="headerlink" href="#memory" title="Permalink to this headline">¶</a></h1>
<div class="math notranslate nohighlight">
\[\newcommand{\Eve}{\textrm{Eve}}
\newcommand{\Adam}{\textrm{Adam}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zinfty}{\Z \cup \set{\pm \infty}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rinfty}{\R \cup \set{\pm \infty}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Qinfty}{\Q \cup \set{\pm \infty}}
\newcommand{\argmax}{\textrm{argmax}}
\newcommand{\argmin}{\textrm{argmin}}
\newcommand{\Op}{\mathbb{O}}
\newcommand{\Prob}{\mathbb{P}} \newcommand{\dist}{\mathcal{D}} \newcommand{\Dist}{\dist} \newcommand{\supp}{\textrm{supp}} 
\newcommand{\game}{\mathcal{G}} \renewcommand{\Game}{\game} \newcommand{\arena}{\mathcal{A}} \newcommand{\Arena}{\arena} 
\newcommand{\col}{\textsf{col}} \newcommand{\Col}{\col} 
\newcommand{\mEve}{\mathrm{Eve}}
\newcommand{\mAdam}{\mathrm{Adam}}
\newcommand{\mRandom}{\mathrm{Random}}
\newcommand{\vertices}{V} \newcommand{\VE}{V_\mEve} \newcommand{\VA}{V_\mAdam} \newcommand{\VR}{V_\mRandom} 
\newcommand{\ing}{\textrm{In}}
\newcommand{\Ing}{\ing}
\newcommand{\out}{\textrm{Out}}
\newcommand{\Out}{\out}
\newcommand{\dest}{\Delta} 
\newcommand{\WE}{W_\mEve} \newcommand{\WA}{W_\mAdam} 
\newcommand{\Paths}{\textrm{Paths}} \newcommand{\play}{\pi} \newcommand{\first}{\textrm{first}} \newcommand{\last}{\textrm{last}} 
\newcommand{\mem}{\mathcal{M}} \newcommand{\Mem}{\mem} 
\newcommand{\Pre}{\textrm{Pre}} \newcommand{\PreE}{\textrm{Pre}_\mEve} \newcommand{\PreA}{\textrm{Pre}_\mAdam} \newcommand{\Attr}{\textrm{Attr}} \newcommand{\AttrE}{\textrm{Attr}_\mEve} \newcommand{\AttrA}{\textrm{Attr}_\mAdam} \newcommand{\rank}{\textrm{rank}}
\newcommand{\Win}{\textrm{Win}} 
\newcommand{\Lose}{\textrm{Lose}} 
\newcommand{\Value}{\textrm{val}} 
\newcommand{\ValueE}{\textrm{val}_\mEve} 
\newcommand{\ValueA}{\textrm{val}_\mAdam}
\newcommand{\val}{\Value} 
\newcommand{\Automaton}{\mathbf{A}} 
\newcommand{\Safe}{\mathtt{Safe}}
\newcommand{\Reach}{\mathtt{Reach}} 
\newcommand{\Buchi}{\mathtt{Buchi}} 
\newcommand{\CoBuchi}{\mathtt{CoBuchi}} 
\newcommand{\Parity}{\mathtt{Parity}} 
\newcommand{\Muller}{\mathtt{Muller}} 
\newcommand{\Rabin}{\mathtt{Rabin}} 
\newcommand{\Streett}{\mathtt{Streett}} 
\newcommand{\MeanPayoff}{\mathtt{MeanPayoff}} 
\newcommand{\DiscountedPayoff}{\mathtt{DiscountedPayoff}}
\newcommand{\Energy}{\mathtt{Energy}}
\newcommand{\TotalPayoff}{\mathtt{TotalPayoff}}
\newcommand{\ShortestPath}{\mathtt{ShortestPath}}
\newcommand{\Sup}{\mathtt{Sup}}
\newcommand{\Inf}{\mathtt{Inf}}
\newcommand{\LimSup}{\mathtt{LimSup}}
\newcommand{\LimInf}{\mathtt{LimInf}}
\newcommand{\NL}{\textrm{NL}}
\newcommand{\PTIME}{\textrm{PTIME}}
\newcommand{\NP}{\textrm{NP}}
\newcommand{\UP}{\textrm{UP}}
\newcommand{\coNP}{\textrm{coNP}}
\newcommand{\coUP}{\textrm{coUP}}
\newcommand{\PSPACE}{\textrm{PSPACE}}\]</div>
<p>A strategy can be a very complicated object, in particular it is infinite.
Indeed, it is a function <span class="math notranslate nohighlight">\(\sigma : \Paths \to E\)</span>,
which means that in order to choose the next move the strategy considers everything played so far:
the strategy depends upon the whole play.</p>
<p>An important part of the study of games is to prove that simple strategies suffice for many purposes,
and one aspect that makes strategies simple is that they use little memory.
For understanding a certain class of games a great insight is often to prove the existence of <strong>simple</strong> winning strategies,
as for instance positional or using finite memory.</p>
<div class="section" id="positional-strategies">
<h2>Positional strategies<a class="headerlink" href="#positional-strategies" title="Permalink to this headline">¶</a></h2>
<p><strong>Positional</strong> strategies carry no memory about the play constructed so far and in choosing an edge only look at the current vertex.
The word memoryless is sometimes used in lieu of positional.
Formally, a positional strategy for Eve is a function</p>
<div class="math notranslate nohighlight">
\[
\sigma : V \to E.
\]</div>
<p>A positional strategy induces a strategy by <span class="math notranslate nohighlight">\(\widehat{\sigma}(\pi) = \sigma(\last(\pi))\)</span>.</p>
<p>For reasoning about positional strategies it is useful to define the following notion.
Let <span class="math notranslate nohighlight">\(\Game\)</span> be a game and <span class="math notranslate nohighlight">\(\sigma\)</span> a positional strategy, we define <span class="math notranslate nohighlight">\(\Game[\sigma]\)</span> the graph with condition <span class="math notranslate nohighlight">\(W\)</span> induced by <span class="math notranslate nohighlight">\(\sigma\)</span> on <span class="math notranslate nohighlight">\(\Game\)</span>.
The set of vertices is <span class="math notranslate nohighlight">\(V\)</span> and the set of edges is</p>
<div class="math notranslate nohighlight">
\[
E[\sigma] = \set{e = (v,v') \in E : v \in \VA \text{ or } \left( v \in \VE \text{ and } \sigma(v) = e \right)}.
\]</div>
<p>It is equipped with the condition <span class="math notranslate nohighlight">\(W\)</span> inherited from <span class="math notranslate nohighlight">\(\Game\)</span>.</p>
<div class="proof observation admonition" id="1-fact:game_induced_positional_strategy">
<p class="admonition-title"><span class="caption-number">Observation 14 </span> (Game induced by a positional strategy)</p>
<div class="observation-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a game with condition <span class="math notranslate nohighlight">\(W\)</span>, <span class="math notranslate nohighlight">\(\sigma\)</span> a positional strategy, and <span class="math notranslate nohighlight">\(v\)</span> a vertex.
Then the strategy <span class="math notranslate nohighlight">\(\sigma\)</span> is winning from <span class="math notranslate nohighlight">\(v\)</span> if and only if all infinite paths in <span class="math notranslate nohighlight">\(\Game[\sigma]\)</span> from <span class="math notranslate nohighlight">\(v\)</span> satisfy <span class="math notranslate nohighlight">\(W\)</span>.</p>
</div>
</div><p>We say that a qualitative objective <span class="math notranslate nohighlight">\(\Omega\)</span> is positionally determined (sometimes simply positional) if
for every game <span class="math notranslate nohighlight">\(\game\)</span> with objective <span class="math notranslate nohighlight">\(\Omega\)</span> and every vertex <span class="math notranslate nohighlight">\(v\)</span>,
if Eve has a winning strategy from <span class="math notranslate nohighlight">\(v\)</span>, then she has a positional winning strategy from <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>As we discussed earlier, the task of solving a game does not include constructing winning strategies.
We present a general binary search technique for doing so assuming positional determinacy.</p>
<div class="proof lemma admonition" id="1-lem:constructing_winning_strategy">
<p class="admonition-title"><span class="caption-number">Lemma 15 </span> (Binary search for constructing positional strategies)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Omega\)</span> be a positionally determined qualitative objective.
If there exists an algorithm <span class="math notranslate nohighlight">\(A\)</span> for solving games with objective <span class="math notranslate nohighlight">\(\Omega\)</span>,
then there exists an algorithm for constructing winning strategies for games in this class
using <span class="math notranslate nohighlight">\(n \cdot \log(\frac{m}{n})\)</span> calls to the algorithm <span class="math notranslate nohighlight">\(A\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Let <span class="math notranslate nohighlight">\(\Omega\)</span> be a positionally determined objective and <span class="math notranslate nohighlight">\(\Game\)</span> a qualitative game with objective <span class="math notranslate nohighlight">\(\Omega\)</span>.
We first determine <span class="math notranslate nohighlight">\(\WE(\Game)\)</span>, which requires one call to a solving algorithm for each vertex.
We fix a vertex <span class="math notranslate nohighlight">\(v \in \WE(\Game)\)</span> and determine a winning positional move from <span class="math notranslate nohighlight">\(v\)</span>.
We let <span class="math notranslate nohighlight">\(d(v)\)</span> denote the outdegree of <span class="math notranslate nohighlight">\(v\)</span>.
We choose a subset of <span class="math notranslate nohighlight">\(\lfloor \frac{d(v)}{2} \rfloor\)</span> outgoing edges of <span class="math notranslate nohighlight">\(v\)</span>, construct the game where we remove these edges,
and solve it using <span class="math notranslate nohighlight">\(v\)</span> as initial vertex.
If Eve wins this game from <span class="math notranslate nohighlight">\(v\)</span>, then there is a positional winning strategy that picks one of the remaining outgoing edges of <span class="math notranslate nohighlight">\(v\)</span>,
otherwise we need to choose one of the removed edges.
This binary search algorithm requires <span class="math notranslate nohighlight">\(O(\log(d(v)))\)</span> calls to a solving algorithm for finding a winning positional move from <span class="math notranslate nohighlight">\(v\)</span>.
Doing so for all vertices requires</p>
<div class="math notranslate nohighlight">
\[
O\left( \sum_{v \in V} \log d(v) \right) \le n \cdot \log \left( \frac{m}{n} \right)
\]</div>
<p>calls to a solving algorithm.</p>
</div>
<p>We say that <span class="math notranslate nohighlight">\(\Omega\)</span> is positionally determined for both players if both <span class="math notranslate nohighlight">\(\Omega\)</span> and its complement <span class="math notranslate nohighlight">\(C^\omega \setminus \Omega\)</span> are positionally determined.
If the positional determinacy only holds for Eve we say that such objectives are half-positional.</p>
<p>Parity objectives are positionally determined for both players; this will be proved in Chapter <a class="reference internal" href="../2_Regular/index.html#chap-regular"><span class="std std-ref">Regular Games</span></a>.
We illustrate it on <a class="reference internal" href="#fig-parity-game-example-positional"><span class="std std-numref">Fig. 5</span></a> by annotating <a class="reference internal" href="objectives.html#fig-parity-game-example"><span class="std std-numref">Fig. 3</span></a> with the positional winning strategies for both players.</p>
<div class="figure align-center" id="fig-parity-game-example-positional">
<img alt="../_images/1-fig:parity_game_example_positional.png" src="../_images/1-fig:parity_game_example_positional.png" />
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">The example of a parity game given in <a class="reference internal" href="objectives.html#fig-parity-game-example"><span class="std std-numref">Fig. 3</span></a> with additional positional winning strategies for both players (corresponding to dashed edges).</span><a class="headerlink" href="#fig-parity-game-example-positional" title="Permalink to this image">¶</a></p>
</div>
<p>We say that a quantitative objective <span class="math notranslate nohighlight">\(\Phi\)</span> is positionally determined if
for every game <span class="math notranslate nohighlight">\(\game\)</span> with objective <span class="math notranslate nohighlight">\(\Phi\)</span> and every vertex <span class="math notranslate nohighlight">\(v\)</span>,
there exists a positional optimal strategy from <span class="math notranslate nohighlight">\(v\)</span>.
Let us state the quantitative counterpart of <a class="reference internal" href="#1-lem:constructing_winning_strategy">Lemma 15</a>.
The proof is the same.</p>
<div class="proof lemma admonition" id="1-lem:constructing_winning_strategy_quantitative">
<p class="admonition-title"><span class="caption-number">Lemma 16 </span> (Binary search for constructive winning strategies, quantitative case)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Omega\)</span> be a positionally determined quantitative objective.
If there exists an algorithm <span class="math notranslate nohighlight">\(A\)</span> for computing the value of games with objective <span class="math notranslate nohighlight">\(\Omega\)</span>,
then there exists an algorithm for constructing optimal positional strategies for games in this class
using <span class="math notranslate nohighlight">\(n \cdot \log(\frac{m}{n})\)</span> calls to <span class="math notranslate nohighlight">\(A\)</span>.</p>
</div>
</div></div>
<div class="section" id="uniformity">
<h2>Uniformity<a class="headerlink" href="#uniformity" title="Permalink to this headline">¶</a></h2>
<p>A qualitative objective <span class="math notranslate nohighlight">\(\Omega\)</span> is uniformly positionally determined if for every game <span class="math notranslate nohighlight">\(\game\)</span> with objective <span class="math notranslate nohighlight">\(\Omega\)</span>,
Eve has a positional strategy which is winning from <span class="math notranslate nohighlight">\(\WE(\game)\)</span>, meaning from every vertex in <span class="math notranslate nohighlight">\(\WE(\game)\)</span>.
Similarly, a quantitative objective <span class="math notranslate nohighlight">\(\Phi\)</span> is uniformly positionally determined if for every game with objective <span class="math notranslate nohighlight">\(\Phi\)</span>,
Eve has a positional strategy which is optimal from every vertex.</p>
<p>Being uniformly positionally determined is a stronger property than being positionally determined, but in most cases an objective satisfies either both or none, as for example if the objective is prefix independent.</p>
<div class="proof lemma admonition" id="1-lem:from_positional_to_uniformly_positional">
<p class="admonition-title"><span class="caption-number">Lemma 17 </span> (From positional to uniformly positional prefix independent objectives)</p>
<div class="lemma-content section" id="proof-content">
<p>If an objective is positionally determined and prefix independent then it is uniformly positionally determined.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Let us consider a game <span class="math notranslate nohighlight">\(\game\)</span> with qualitative objective <span class="math notranslate nohighlight">\(\Omega\)</span> (the argument is exactly the same for quantitative objectives so we will not repeat it).
For each <span class="math notranslate nohighlight">\(v \in \WE(\game)\)</span> let <span class="math notranslate nohighlight">\(\sigma_v\)</span> be a positional winning strategy.
Thanks to~\cref{1-fact:winning_prefix_independent_qualitative}
the strategy <span class="math notranslate nohighlight">\(\sigma_v\)</span> is winning from all vertices reachable by a play consistent with <span class="math notranslate nohighlight">\(\sigma_v\)</span> starting from <span class="math notranslate nohighlight">\(v\)</span>.
Without loss of generality let us assume that <span class="math notranslate nohighlight">\(\sigma_v\)</span> is only defined on these vertices.</p>
<p>We fix <span class="math notranslate nohighlight">\(\le\)</span> a total order on the set of vertices</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>The argument we give in this proof extends to infinite games whose set of vertices can be well ordered. A well-order is a total order such that every non-empty subset has a least element, which is exactly the property we need in this proof.```</p>
<p>.
We let <span class="math notranslate nohighlight">\(\sigma\)</span> be the positional strategy defined by <span class="math notranslate nohighlight">\(\sigma(u)\)</span> is <span class="math notranslate nohighlight">\(\sigma_v(u)\)</span> where <span class="math notranslate nohighlight">\(v\)</span> is the least vertex (with respect to <span class="math notranslate nohighlight">\(\le\)</span>) such that <span class="math notranslate nohighlight">\(\sigma_v\)</span> is defined on <span class="math notranslate nohighlight">\(u\)</span>. We say that <span class="math notranslate nohighlight">\(\sigma\)</span> uses <span class="math notranslate nohighlight">\(\sigma_v\)</span> at <span class="math notranslate nohighlight">\(u\)</span>.</p>
<p>We argue that <span class="math notranslate nohighlight">\(\sigma\)</span> is winning from <span class="math notranslate nohighlight">\(\WE(\game)\)</span>.
Consider a play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> starting from some vertex in <span class="math notranslate nohighlight">\(\WE(\game)\)</span> and look at the sequence of strategies it uses.
By definition this sequence is non-increasing (with respect to <span class="math notranslate nohighlight">\(\le\)</span>), hence it is stationary.
In other words the play is eventually consistent with some strategy <span class="math notranslate nohighlight">\(\sigma_v\)</span>, implying that this suffix satisfies <span class="math notranslate nohighlight">\(\Omega\)</span>.
Since <span class="math notranslate nohighlight">\(\Omega\)</span> is prefix independent this means that the play itself satisfies <span class="math notranslate nohighlight">\(\Omega\)</span>, so <span class="math notranslate nohighlight">\(\sigma\)</span> is indeed winning.</p>
</div>
</div>
</div>
<div class="section" id="finite-memory-strategies-label-1-finite-memory">
<h2>Finite memory strategies}\label{1-finite memory<a class="headerlink" href="#finite-memory-strategies-label-1-finite-memory" title="Permalink to this headline">¶</a></h2>
<p>Memoryless strategies are sometimes not enough.
A more powerful class of strategies is <strong>finite memory</strong> strategies.
Intuitively, a finite memory strategy uses a finite state machine called a memory structure
to store the relevant pieces of information about the play constructed so far.</p>
<p>To define finite memory strategies formally, we fix a graph <span class="math notranslate nohighlight">\(G\)</span>.
A memory structure is <span class="math notranslate nohighlight">\(\mem = (M, m_0, \delta)\)</span>: the set <span class="math notranslate nohighlight">\(M\)</span> is a set of (memory) states,
<span class="math notranslate nohighlight">\(m_0 \in M\)</span> is the initial state and <span class="math notranslate nohighlight">\(\delta : M \times E \to M\)</span> is the update function.
The update function is extended to <span class="math notranslate nohighlight">\(\delta^* : E^* \to M\)</span> by
<span class="math notranslate nohighlight">\(\delta^*(\varepsilon) = m_0\)</span> and <span class="math notranslate nohighlight">\(\delta^* (\rho e) = \delta(\delta^*(\rho), e)\)</span>.
The size of a memory structure is its number of states.
Note that a memory structure is a deterministic automaton over the alphabet <span class="math notranslate nohighlight">\(E\)</span> but without specifying the acceptance condition.</p>
<p>We define a strategy using <span class="math notranslate nohighlight">\(\mem\)</span> as a function</p>
<div class="math notranslate nohighlight">
\[
\sigma : \VE \times M \to E.
\]</div>
<p>It induces a strategy <span class="math notranslate nohighlight">\(\widehat{\sigma}\)</span> via <span class="math notranslate nohighlight">\(\widehat{\sigma}(\pi) = \sigma(\last(\pi), \delta^*(\pi))\)</span>.
A common abuse of notations is to write <span class="math notranslate nohighlight">\(\sigma\)</span> for <span class="math notranslate nohighlight">\(\widehat{\sigma}\)</span>.</p>
<p>We note that positional strategies correspond to strategies using the trivial memory structure consisting of only one state.</p>
<p>We say that a qualitative objective <span class="math notranslate nohighlight">\(\Omega\)</span> is determined with finite memory strategies if
for every game <span class="math notranslate nohighlight">\(\game\)</span> and every vertex <span class="math notranslate nohighlight">\(v\)</span>,
if Eve has a winning strategy from <span class="math notranslate nohighlight">\(v\)</span>, then she has a winning strategy from <span class="math notranslate nohighlight">\(v\)</span> using finite memory.
There are several variants of this definition covering cases where the memory is constant or bounded, and whether it holds for one or both players,
and uniformly over all vertices or not.</p>
<p>We give in <a class="reference internal" href="#fig-memory-required"><span class="std std-numref">Fig. 6</span></a> an example of a game where Eve has a winning strategy using two memory states
but no positional winning strategy.
Let us consider the condition <span class="math notranslate nohighlight">\(\Buchi[\set{v_1}] \wedge \Buchi[\set{v_2}]\)</span>, meaning that a play is winning if both <span class="math notranslate nohighlight">\(v_1\)</span> and <span class="math notranslate nohighlight">\(v_2\)</span> are visited infinitely many times. A positional strategy would either always choose to go left to <span class="math notranslate nohighlight">\(v_1\)</span> or to the right to <span class="math notranslate nohighlight">\(v_2\)</span>, hence does not satisfy the condition.
Some memory is required to switch between the two.</p>
<p>Formally we let <span class="math notranslate nohighlight">\(\mem = (\set{m_1,m_2},m_1,\delta)\)</span> defined by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{lll}
\delta(m_1,(v_0,v_1)) &amp; = &amp; m_2, \\
\delta(m_2,(v_1,v_0)) &amp; = &amp; m_2, \\
\delta(m_2,(v_0,v_2)) &amp; = &amp; m_1, \\
\delta(m_1,(v_2,v_0)) &amp; = &amp; m_1.
\end{array}
\end{split}\]</div>
<p>Then we define <span class="math notranslate nohighlight">\(\sigma(v_0,m_1) = (v_0,v_1)\)</span> and <span class="math notranslate nohighlight">\(\sigma(v_0,m_2) = (v_0,v_2)\)</span>
inducing the winning strategy <span class="math notranslate nohighlight">\(\widehat{\sigma}\)</span> using <span class="math notranslate nohighlight">\(\Mem\)</span>.</p>
<div class="figure align-center" id="fig-memory-required">
<img alt="../_images/1-fig:memory_required.png" src="../_images/1-fig:memory_required.png" />
<p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">A game where Eve has a winning strategy for <span class="math notranslate nohighlight">\(\Buchi(v_1) \wedge \Buchi(v_2)\)</span> using two memory states
but no positional winning strategy.</span><a class="headerlink" href="#fig-memory-required" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./1_Introduction"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="automata.html" title="previous page">Automata</a>
    <a class='right-next' id="next-link" href="reductions.html" title="next page">Reductions</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>