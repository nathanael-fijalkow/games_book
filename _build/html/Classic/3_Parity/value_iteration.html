
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A quasipolynomial time value iteration algorithm &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"set": ["\\left\\{ #1 \\right\\}", 1], "Eve": "\\textrm{Eve}", "Adam": "\\textrm{Adam}", "N": "\\mathbb{N}", "Z": "\\mathbb{Z}", "Zinfty": "\\Z \\cup \\set{\\pm \\infty}", "R": "\\mathbb{R}", "Rinfty": "\\R \\cup \\set{\\pm \\infty}", "Q": "\\mathbb{Q}", "Qinfty": "\\Q \\cup \\set{\\pm \\infty}", "argmax": "\\text{argmax}", "argmin": "\\text{argmin}", "Op": "\\mathbb{O}", "Prob": "\\mathbb{P}", "dist": "\\mathcal{D}", "Dist": "\\dist", "supp": "\\text{supp}", "game": "\\mathcal{G}", "Game": "\\game", "arena": "\\mathcal{A}", "Arena": "\\arena", "col": "\\textsf{col}", "Col": "\\col", "mEve": "\\mathrm{Eve}", "mAdam": "\\mathrm{Adam}", "mRandom": "\\mathrm{Random}", "vertices": "V", "VE": "V_\\mEve", "VA": "V_\\mAdam", "VR": "V_\\mRandom", "ing": "\\text{In}", "Ing": "\\ing", "out": "\\text{Out}", "Out": "\\out", "dest": "\\Delta", "WE": "W_\\mEve", "WA": "W_\\mAdam", "Paths": "\\text{Paths}", "play": "\\pi", "first": "\\text{first}", "last": "\\text{last}", "mem": "\\mathcal{M}", "Mem": "\\mem", "Pre": "\\text{Pre}", "PreE": "\\text{Pre}_\\mEve", "PreA": "\\text{Pre}_\\mAdam", "Attr": "\\text{Attr}", "AttrE": "\\text{Attr}_\\mEve", "AttrA": "\\text{Attr}_\\mAdam", "rank": "\\text{rank}", "Win": "\\textsc{Win}", "Lose": "\\textsc{Lose}", "Value": "\\text{val}", "ValueE": "\\text{val}_\\mEve", "ValueA": "\\text{val}_\\mAdam", "val": "\\Value", "Automaton": "\\mathbf{A}", "Safe": "\\mathtt{Safe}", "Reach": "\\mathtt{Reach}", "Buchi": "\\mathtt{Buchi}", "CoBuchi": "\\mathtt{CoBuchi}", "Parity": "\\mathtt{Parity}", "Muller": "\\mathtt{Muller}", "Rabin": "\\mathtt{Rabin}", "Streett": "\\mathtt{Streett}", "MeanPayoff": "\\mathtt{MeanPayoff}", "DiscountedPayoff": "\\mathtt{DiscountedPayoff}", "Energy": "\\mathtt{Energy}", "TotalPayoff": "\\mathtt{TotalPayoff}", "ShortestPath": "\\mathtt{ShortestPath}", "Sup": "\\mathtt{Sup}", "Inf": "\\mathtt{Inf}", "LimSup": "\\mathtt{LimSup}", "LimInf": "\\mathtt{LimInf}"}}, "tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Comparing the three families of algorithms" href="relationships.html" />
    <link rel="prev" title="A quasipolynomial time separating automata algorithm" href="separation.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../book.html">
   Games on Graphs
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../../Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../2_Regular/index.html">
   Regular
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/attractors.html">
     A linear time algorithm for reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/buchi.html">
     A quadratic time algorithm for Büchi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/parity.html">
     An exponential time algorithm for parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/zielonka.html">
     The Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Parity
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/Classic/3_Parity/value_iteration.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#universal-trees">
   Universal trees
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-quasipolynomial-universal-tree">
   A quasipolynomial universal tree
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#progress-measures">
   Progress measures
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-algorithm">
   The algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexity-analysis">
   Complexity analysis
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#data-structure">
     Data structure
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#encoding-branches">
     Encoding branches
    </a>
   </li>
  </ul>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="a-quasipolynomial-time-value-iteration-algorithm">
<span id="sec-value-iteration"></span><h1>A quasipolynomial time value iteration algorithm<a class="headerlink" href="#a-quasipolynomial-time-value-iteration-algorithm" title="Permalink to this headline">¶</a></h1>
<div class="theorem admonition" id="thm-value-iteration-quasipoly">
<p class="admonition-title">Theorem</p>
<p>There exists a value iteration algorithm for solving parity games in time</p>
<div class="math notranslate nohighlight">
\[
O\left(nm \log(n) \log(d) \cdot  \binom{\lceil \log(n) \rceil + d/2 - 1}{\lceil \log(n) \rceil} \right),
\]</div>
<p>which is quasipolynomial in general and polynomial if <span class="math notranslate nohighlight">\(d = O(\log(n))\)</span>.
The space complexity of the algorithm is <span class="math notranslate nohighlight">\(O(m + n \log(d))\)</span>.</p>
</div>
<p>We rely on the high-level presentation of value iteration algorithms given in  <a class="reference internal" href="../../Introduction/value_iteration.html#sec-value-iteration"><span class="std std-ref">Section</span></a>.
Let <span class="math notranslate nohighlight">\(\game = (\arena,\Parity[\col])\)</span> a parity game with <span class="math notranslate nohighlight">\(n\)</span> vertices and priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>,
and without loss of generality <span class="math notranslate nohighlight">\(d\)</span> is even.</p>
<p>The first step is to define a notion of value function <span class="math notranslate nohighlight">\(\val^\game : V \to Y\)</span> with <span class="math notranslate nohighlight">\((Y,\le)\)</span> a lattice satisfying the characterisation principle:
for all vertices <span class="math notranslate nohighlight">\(v\)</span> we have that Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if <span class="math notranslate nohighlight">\(\val^\game(v) \neq \bot\)</span>, where <span class="math notranslate nohighlight">\(\bot\)</span> is the least element in <span class="math notranslate nohighlight">\(Y\)</span>.
The goal of the algorithm is to compute <span class="math notranslate nohighlight">\(\val^\game\)</span>, from which we then easily obtain the winning region thanks to the characterisation principle.</p>
<p>To set the machinery of value iteration algorithms in motion we can either construct <span class="math notranslate nohighlight">\(\val^\game\)</span> as the unique fixed point of a contracting operator using Banach’s fixed point theorem or the greatest fixed point of a monotonic operator using Kleene’s fixed point theorem.</p>
<p>Let us here follow the second approach.
We let <span class="math notranslate nohighlight">\(F_V\)</span> be the lattice of functions <span class="math notranslate nohighlight">\(V \to Y\)</span> equipped with the componentwise order induced by <span class="math notranslate nohighlight">\(Y\)</span>.
We are looking for a monotonic function <span class="math notranslate nohighlight">\(\delta : Y \times [1,d] \to Y\)</span> inducing the operator <span class="math notranslate nohighlight">\(\Op : F_V \to F_V\)</span> defined by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Op(\mu)(v) = 
\begin{cases}
\max \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } v \in \VE, \\
\min \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } v \in \VA,
\end{cases}
\end{split}\]</div>
<p>such that <span class="math notranslate nohighlight">\(\val^\game\)</span> is the greatest fixed point of <span class="math notranslate nohighlight">\(\Op\)</span>.
The algorithm would then simply use  <a class="reference internal" href="../../Introduction/fixed_points.html#thm-kleene"><span class="std std-ref">Theorem</span></a> to compute <span class="math notranslate nohighlight">\(\val^\game\)</span> by iterating the operator <span class="math notranslate nohighlight">\(\Op\)</span>.</p>
<p>Let us look at this question using the notion of progress measures, which are post-fixed points of <span class="math notranslate nohighlight">\(\Op\)</span>,
meaning <span class="math notranslate nohighlight">\(\mu\)</span> such that <span class="math notranslate nohighlight">\(\mu \le \Op(\mu)\)</span>.
Since the greatest fixed point of <span class="math notranslate nohighlight">\(\Op\)</span> is also its greatest post-fixed point, an equivalent formulation of the characterisation principle above reads: for all vertices <span class="math notranslate nohighlight">\(v\)</span> we have that Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if there exists a progress measure <span class="math notranslate nohighlight">\(\mu\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.</p>
<p>To summarise this discussion, we are looking for a lattice <span class="math notranslate nohighlight">\((Y,\le)\)</span> and a monotonic function <span class="math notranslate nohighlight">\(\delta : Y \times [1,d] \to Y\)</span>
such that for all parity games <span class="math notranslate nohighlight">\(\Game\)</span> with <span class="math notranslate nohighlight">\(n\)</span> vertices and priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>,
for all vertices <span class="math notranslate nohighlight">\(v\)</span> we have that Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if there exists a progress measure <span class="math notranslate nohighlight">\(\mu\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.
Our next step is to show how the notion of universal trees provides a class of solutions to this problem.</p>
<div class="section" id="universal-trees">
<h2>Universal trees<a class="headerlink" href="#universal-trees" title="Permalink to this headline">¶</a></h2>
<p>The trees we consider have three properties:
they are rooted, every leaf has the same depth, and the children of a node are totally ordered.
Formally, a tree of height <span class="math notranslate nohighlight">\(0\)</span> is a leaf,
and a tree <span class="math notranslate nohighlight">\(t\)</span> of height <span class="math notranslate nohighlight">\(h + 1\)</span> is an ordered list <span class="math notranslate nohighlight">\([t_1,\dots,t_k]\)</span> of subtrees each of height <span class="math notranslate nohighlight">\(h\)</span>.</p>
<p>We consider two parameters for trees: the height, and the size which is defined to be the number of branches (equivalently, the number of leaves).
All trees we consider have height <span class="math notranslate nohighlight">\(h = d/2\)</span>.</p>
<p>\begin{figure*}[!ht]
\centering
\begin{tikzpicture}
\begin{scope}[xscale=1,yscale=1.6]
\path (0,0) node[coordinate] (root) {};
\foreach \x in {-2,…,2}
{\draw (root) – (\x,-1) node[coordinate] (n\x) {};}
\foreach \s/\x/\n in {-2/-2/,
-1/-1.4/,-1/-.6/,
0/-.4/,0/-.2/,0/0/,0/.2/,0/.4/,
1/.6/,1/1.4/,
2/2/}
{\draw (n\s) – (\x,-2) node[below] {<span class="math notranslate nohighlight">\(\n\)</span>};}
\end{scope}</p>
<p>\begin{scope}[xscale=.6,yscale=1]
\path (6,-1) node[coordinate] (root) {};
\foreach \x in {-1,0,1}
{\draw[red, thick] (root) – (6+\x,-2) node[coordinate] (m\x) {};}
\foreach \s/\x in {-1/-1.4,
-1/-.6,
0/-.4,
0/.4,
1/1}
{\draw[red, thick] (m\s) – (6+\x,-3);}</p>
<p>\path (10,-1) node[coordinate] (root) {};
\foreach \x in {-2,1}
{\draw (root) – (10+\x,-2) node[coordinate] (o\x) {};}
\foreach \x in {-1,0,2}
{\draw[red, thick] (root) – (10+\x,-2) node[coordinate] (o\x) {};}
\foreach \s/\x in {-2/-2,
0/-.4,
0/-.2,
0/.2,
1/.6,
1/1.4}
{\draw (o\s) – (10+\x,-3);}
\foreach \s/\x in {-1/-1.4,
-1/-.6,
0/0,
0/.4,
2/2}
{\draw[red, thick] (o\s) – (10+\x,-3);}
\end{scope}
\end{tikzpicture}
\caption{On the left, a tree for <span class="math notranslate nohighlight">\(d = 4\)</span>, which is the smallest <span class="math notranslate nohighlight">\((5,2)\)</span>-universal tree:
it has size <span class="math notranslate nohighlight">\(11\)</span> (meaning it has <span class="math notranslate nohighlight">\(11\)</span> branches).
On the right, a tree of size <span class="math notranslate nohighlight">\(5\)</span> and one possible embedding into the universal tree.}
\label{3-fig:example_universal}
\end{figure*}</p>
<p>We say that a tree <span class="math notranslate nohighlight">\(t\)</span> embeds into another tree <span class="math notranslate nohighlight">\(T\)</span> if:</p>
<ul class="simple">
<li><p>either both are leaves,</p></li>
<li><p>or let <span class="math notranslate nohighlight">\(t = [t_1,\dots,t_k]\)</span> and <span class="math notranslate nohighlight">\(T = [T_1,\dots,T_{k'}]\)</span>,
there exist <span class="math notranslate nohighlight">\(i_1 &lt; \dots &lt; i_k\)</span> such that for all <span class="math notranslate nohighlight">\(j \in [1,k]\)</span> we have that <span class="math notranslate nohighlight">\(t_j\)</span> embeds into <span class="math notranslate nohighlight">\(T_{i_j}\)</span>.</p></li>
</ul>
<div class="definition admonition">
<p class="admonition-title">Definition</p>
<p>A tree is <span class="math notranslate nohighlight">\((n,h)\)</span>-<strong>universal</strong> if it embeds all trees of size <span class="math notranslate nohighlight">\(n\)</span> and height <span class="math notranslate nohighlight">\(h\)</span>.</p>
</div>
<p>We refer to  <span class="xref std std-ref">Figure</span> for an example of a <span class="math notranslate nohighlight">\((5,2)\)</span>-universal tree.
A first example of an <span class="math notranslate nohighlight">\((n,h)\)</span>-universal tree is the tree where each node has degree <span class="math notranslate nohighlight">\(n\)</span>:
formally we define it recursively by <span class="math notranslate nohighlight">\(T_{n,0}\)</span> is a leaf, and <span class="math notranslate nohighlight">\(T_{n,h+1} = [\underbrace{T_{n,h},\dots,T_{n,h}}_{n \text{ copies}}]\)</span>.
It has size <span class="math notranslate nohighlight">\(n^h\)</span>.</p>
</div>
<div class="section" id="a-quasipolynomial-universal-tree">
<h2>A quasipolynomial universal tree<a class="headerlink" href="#a-quasipolynomial-universal-tree" title="Permalink to this headline">¶</a></h2>
<p>We present an inductive construction of a quasipolynomial universal tree.</p>
<div class="theorem admonition" id="thm-universal-tree">
<p class="admonition-title">Theorem</p>
<p>There exists an <span class="math notranslate nohighlight">\((n,h)\)</span>-universal tree with size <span class="math notranslate nohighlight">\(f(n,h)\)</span>, where <span class="math notranslate nohighlight">\(\mu\)</span> satisfies the following:
$<span class="math notranslate nohighlight">\(\begin{array}{lll}
f(n,h) &amp; = &amp; f(n,h-1) + f(\lfloor n/2 \rfloor,h) + f(\lceil n/2 \rceil - 1,h), \\
f(n,1) &amp; = &amp; n, \\
f(1,h) &amp; = &amp; 1.
\end{array}\)</span>$</p>
</div>
<p>An upper bound is given by</p>
<div class="math notranslate nohighlight">
\[
f(n,h) \le 2n \binom{\lceil \log(n) \rceil + h - 1}{\lceil \log(n) \rceil}.
\]</div>
<p>A generous upper bound on the expression above is <span class="math notranslate nohighlight">\(n^{O(\log(h))}\)</span>.
A refined analysis reveals that the expression is polynomial in <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(h\)</span> if <span class="math notranslate nohighlight">\(h = O(\log(n))\)</span>.</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>To construct the <span class="math notranslate nohighlight">\((n,h)\)</span>-universal tree <span class="math notranslate nohighlight">\(T\)</span>, let:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T_\text{left}\)</span> be a <span class="math notranslate nohighlight">\((\lfloor n/2 \rfloor,h)\)</span>-universal tree,</p></li>
<li><p><span class="math notranslate nohighlight">\(T_\text{middle}\)</span> be a <span class="math notranslate nohighlight">\((n,h-1)\)</span>-universal tree,</p></li>
<li><p><span class="math notranslate nohighlight">\(T_\text{right}\)</span> be a <span class="math notranslate nohighlight">\((\lceil n/2 \rceil - 1,h)\)</span>-universal tree.</p></li>
</ul>
<p>The intuitive construction of <span class="math notranslate nohighlight">\(T\)</span> is as follows:
we merge the roots of <span class="math notranslate nohighlight">\(T_\text{left}\)</span> and <span class="math notranslate nohighlight">\(T_\text{right}\)</span> and insert inbetween them
a child of the root to which is attached <span class="math notranslate nohighlight">\(T_\text{middle}\)</span>.
Formally, let <span class="math notranslate nohighlight">\(T_\text{left} = [T^1_{\text{left}},\dots,T^k_{\text{left}}]\)</span> and
<span class="math notranslate nohighlight">\(T_\text{right} = [T^1_{\text{right}},\dots,T^{k'}_{\text{right}}]\)</span>,
we define <span class="math notranslate nohighlight">\(T\)</span> as</p>
<div class="math notranslate nohighlight">
\[
[T^1_{\text{left}},\dots,T^k_{\text{left}},\ T_\text{middle},\ T^1_{\text{right}},\dots,T^{k'}_{\text{right}}].
\]</div>
<p>The construction is illustrated in  <a class="reference internal" href="#fig-smallest-tree-construction"><span class="std std-ref">Figure</span></a>.</p>
<div class="figure align-center" id="fig-smallest-tree-construction">
<img alt="../../_images/3-fig:smallest_tree_construction.png" src="../../_images/3-fig:smallest_tree_construction.png" />
<p class="caption"><span class="caption-number">Fig. 15 </span><span class="caption-text">The inductive construction.</span><a class="headerlink" href="#fig-smallest-tree-construction" title="Permalink to this image">¶</a></p>
</div>
</div>
<p>We argue that <span class="math notranslate nohighlight">\(T\)</span> is <span class="math notranslate nohighlight">\((n,h)\)</span>-universal.
Consider a tree <span class="math notranslate nohighlight">\(t = [t_1,\dots,t_k]\)</span> with <span class="math notranslate nohighlight">\(n\)</span> branches.
The question is where to cut, <strong>i.e.</strong> which subtree of <span class="math notranslate nohighlight">\(t\)</span> gets mapped to <span class="math notranslate nohighlight">\(T_\text{middle}\)</span>.
Let <span class="math notranslate nohighlight">\(n(t_i)\)</span> be the number of branches in <span class="math notranslate nohighlight">\(t_i\)</span>.
Since <span class="math notranslate nohighlight">\(t\)</span> has <span class="math notranslate nohighlight">\(n\)</span> branches, we have <span class="math notranslate nohighlight">\(n(t_1) + \cdots + n(t_k) = n\)</span>.
There exists a unique <span class="math notranslate nohighlight">\(p \in [1,k]\)</span> such that
<span class="math notranslate nohighlight">\(n(t_1) + \cdots + n(t_{p-1}) \le \lfloor n/2 \rfloor
\text{ and } 
n(t_1) + \cdots + n(t_p) &gt; \lfloor n/2 \rfloor\)</span>.
The choice of <span class="math notranslate nohighlight">\(p\)</span> implies that <span class="math notranslate nohighlight">\(n(t_{p+1}) + \cdots + n(t_k) \le \lceil n/2 \rceil - 1\)</span>.
To embed <span class="math notranslate nohighlight">\(t\)</span> into <span class="math notranslate nohighlight">\(T\)</span>, we proceed as follows:</p>
<ul class="simple">
<li><p>the tree <span class="math notranslate nohighlight">\([t_1,\dots,t_{p-1}]\)</span> has at most <span class="math notranslate nohighlight">\(\lfloor n/2 \rfloor\)</span> branches,
so it embeds into <span class="math notranslate nohighlight">\(T_\text{left}\)</span> by induction hypothesis;</p></li>
<li><p>the tree <span class="math notranslate nohighlight">\(t_p\)</span> has height <span class="math notranslate nohighlight">\(h-1\)</span> and at most <span class="math notranslate nohighlight">\(n\)</span> branches, so in embeds into <span class="math notranslate nohighlight">\(T_\text{middle}\)</span> by induction hypothesis;</p></li>
<li><p>the tree <span class="math notranslate nohighlight">\([t_{p+1},\dots,t_k]\)</span> has at most <span class="math notranslate nohighlight">\(\lceil n/2 \rceil - 1\)</span> branches,
so it embeds into <span class="math notranslate nohighlight">\(T_\text{right}\)</span> by induction hypothesis.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
\noindent The construction given in the proof yields the smallest $(5,2)$-universal tree illustrated in {ref}`Figure &lt;3-fig:example_universal&gt;`.

### Ordering the branches

Let us consider a tree $t$.
A branch is given by a list of directions that we define now.
For technical convenience that will manifest itself later, the list of directions is indexed by odd numbers $p \in [1,d]$ downwards:
for example for $d = 10$ a branch is $(D_9,D_7,D_5,D_3,D_1)$.
We often naturally identify a leaf, its branch, and the list of directions that represents it.

We write $B_t$ for the set of branches of $t$ and $\le$ for the lexicographic order on $B_t$.
Note that its interpretation on the tree is: for two branches $b,b&#39;$, we have $b \le b&#39;$ if and only if $b$ is to the left of $b&#39;$.
The strict version of $\le$ is $&lt;$.

We introduce a set of relations $\vartriangleleft_p$ over $B_t$ for each $p \in [1,d]$.
For a branch $b = (D_{d-1},\dots,D_3,D_1)$ we write $b_{\ge p}$ for the tuple $(D_{d-1},\dots,D_{p+2},D_p)$,
which we call the $p$-truncated branch of $b$.

*  For $p$ odd, we say that $b \vartriangleleft_p b&#39;$ 
if $b_{\ge p}\ &lt;\ b&#39;_{\ge p}$.
*  For $p$ even, we say that $b \vartriangleleft_p b&#39;$ 
if $b_{\ge p}\ \le\ b&#39;_{\ge p}$.

To interpret $\vartriangleleft_p$ on the tree, we label the levels by priorities from bottom to top as in {ref}`Figure &lt;3-fig:example_universal&gt;`.
Then $b \vartriangleleft_p b&#39;$ if and only if the $p$-truncated branch of $b$ is to the left of the $p$-truncated branch of $b&#39;$,
strictly if $p$ is odd, and non-strictly if $p$ is even.

\begin{figure*}[!ht]
\centering
\begin{tikzpicture}
  \begin{scope}[xscale=1.4,yscale=1.6]
  \path (0,0) node[coordinate] (root) {};
  \foreach \x in {-2,...,2}
    {\draw (root) -- (\x,-1) node[coordinate] (n\x) {};}
  \foreach \s/\x/\n in {-2/-2/,
    -1/-1.4/,-1/-.6/,
    0/-.4/,0/-.2/w,0/0/,0/.2/,0/.4/,
    1/.6/v,1/1.4/u,
    2/2/}
    {\draw (n\s) -- (\x,-2) node[below] {$\n$};}
  \foreach \y/\l in {0.2/4,.7/3,1.2/2,1.7/1}
    {\draw (2.5,-\y) node {\begin{Huge}\l\end{Huge}};}
  \end{scope}
\end{tikzpicture}
\caption{Illustration of the relations $\vartriangleleft_p$.}
\label{3-fig:example_relations}
\end{figure*}

We refer to  {ref}`Figure &lt;3-fig:example_relations&gt;` for some examples:

$$
v \vartriangleleft_1 u \quad ; \quad  
v \vartriangleleft_2 u \quad ; \quad 
u \vartriangleleft_2 v \quad ; \quad 
w \vartriangleleft_3 u \quad ; \quad 
w \vartriangleleft_2 v.
$$



```{admonition} Lemma
:class: lemma
:name: 3-lem:properties_tree

The relations $\vartriangleleft_p$ for $p \in [1,d]$ induced by a tree $t$ satisfy the following properties:

*  $\vartriangleleft_d$ is the full relation: for all $b,b&#39;$ we have $b \vartriangleleft_d b&#39;$;
*  if $b \vartriangleleft_p b&#39;$ and $b&#39; \vartriangleleft_q b&#39;&#39;$ then $b \vartriangleleft_{\max(p,q)} b&#39;&#39;$;
*  the relation $\vartriangleleft_p$ is non-reflexive if $p$ is odd;
*  the relation $\vartriangleleft_1$ is total;
*  for $p &lt; d$ even we have $b \vartriangleleft_p b&#39;$ if and only if $\neg (b&#39; \vartriangleleft_{p+1} b)$.

</pre></div>
</div>
<p>The following observation rephrases the notion of embeddings between trees using the ordering on branches.</p>
<div class="fact admonition" id="fact-embedding">
<p class="admonition-title">Fact</p>
<p>Let <span class="math notranslate nohighlight">\(t,T\)</span> be two trees.
Then <span class="math notranslate nohighlight">\(t\)</span> embeds into <span class="math notranslate nohighlight">\(T\)</span> if and only if there exists a function <span class="math notranslate nohighlight">\(\mu : B_t \to B_T\)</span>
such that for all branches <span class="math notranslate nohighlight">\(b,b'\)</span>:</p>
<div class="math notranslate nohighlight">
\[
b \vartriangleleft_p^t b' \implies \mu(b) \vartriangleleft_p^T \mu(b').
\]</div>
</div>
</div>
<div class="section" id="progress-measures">
<h2>Progress measures<a class="headerlink" href="#progress-measures" title="Permalink to this headline">¶</a></h2>
<p>We explain how a tree <span class="math notranslate nohighlight">\(t\)</span> induces both a lattice <span class="math notranslate nohighlight">\((Y_t,\le)\)</span> and a monotonic function <span class="math notranslate nohighlight">\(\delta_t : Y_t \times [1,d] \to Y_t\)</span>.
The set <span class="math notranslate nohighlight">\(Y_t\)</span> is the set of branches of <span class="math notranslate nohighlight">\(t\)</span> augmented with a new element <span class="math notranslate nohighlight">\(\bot\)</span>,
and <span class="math notranslate nohighlight">\(\le\)</span> is the lexicographic order on branches with <span class="math notranslate nohighlight">\(\bot\)</span> as least element.
For each <span class="math notranslate nohighlight">\(p \in [1,d]\)</span> and <span class="math notranslate nohighlight">\(b \in Y_t\)</span> we extend <span class="math notranslate nohighlight">\(\vartriangleleft_p\)</span> with <span class="math notranslate nohighlight">\(\bot \vartriangleleft_p b\)</span>.
We then define <span class="math notranslate nohighlight">\(\delta : Y_t \times [1,d] \to Y_t\)</span> by</p>
<div class="math notranslate nohighlight">
\[
\delta(b,p) = \max \set{b' : b' \vartriangleleft_p b}.
\]</div>
<p>This in turn induces a monotonic operator <span class="math notranslate nohighlight">\(\Op_t : F_V \to F_V\)</span> defined by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Op(\mu)(v) = 
\begin{cases}
\max \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } v \in \VE, \\
\min \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } v \in \VA.
\end{cases}
\end{split}\]</div>
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a parity game, a progress measure is a function <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> which is a post-fixed point: <span class="math notranslate nohighlight">\(\mu \le \Op_t(\mu)\)</span>.
Expanding the definitions, this means that for all vertices <span class="math notranslate nohighlight">\(v\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{llll}
\exists (v,v') \in E,\ &amp; \mu(v) \le \delta_t( \mu(v'), \col(v)) &amp; \text{ if } v \in \VE, \\
\forall (v,v') \in E,\ &amp; \mu(v) \le \delta_t( \mu(v'), \col(v)) &amp; \text{ if } v \in \VA.
\end{array}
\end{split}\]</div>
<p>The definition of <span class="math notranslate nohighlight">\(\delta_t\)</span> further simplifies it to: for all vertices <span class="math notranslate nohighlight">\(v\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{llll}
\exists (v,v') \in E,\ &amp; \mu(v) \vartriangleleft_{\col(v)} \mu(v') &amp; \text{ if } v \in \VE, \\
\forall (v,v') \in E,\ &amp; \mu(v) \vartriangleleft_{\col(v)} \mu(v') &amp; \text{ if } v \in \VA.
\end{array}
\end{split}\]</div>
<p>The following theorem is our first and main step towards proving the characterisation principle.</p>
<div class="theorem admonition" id="thm-progress-measure">
<p class="admonition-title">Theorem</p>
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a parity game and <span class="math notranslate nohighlight">\(v\)</span> a vertex.
Then Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.</p>
</div>
<p>In order to prove  <a class="reference internal" href="#thm-progress-measure"><span class="std std-ref">Theorem</span></a>, we first consider the case of parity graphs.
A progress measure in a parity graph is a function <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that
for all edges <span class="math notranslate nohighlight">\((v,v') \in E\)</span> we have <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.</p>
<p>Recall that a graph satisfies parity from <span class="math notranslate nohighlight">\(v\)</span> if all infinite paths from <span class="math notranslate nohighlight">\(v\)</span> satisfy parity.
This is equivalent to asking whether all cycles reachable from <span class="math notranslate nohighlight">\(v\)</span> are even, meaning the maximal priority appearing in the cycle is even.</p>
<div class="lemma admonition" id="lem-progress-measure">
<p class="admonition-title">Lemma</p>
<p>Let <span class="math notranslate nohighlight">\(G\)</span> be a parity graph and <span class="math notranslate nohighlight">\(v\)</span> a vertex.
Then <span class="math notranslate nohighlight">\(G\)</span> satisfies parity from <span class="math notranslate nohighlight">\(v\)</span> if and only if
there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.</p>
</div>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Let us assume that there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>
and for all edges <span class="math notranslate nohighlight">\((v,v') \in E\)</span> we have <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.
To show that <span class="math notranslate nohighlight">\(G\)</span> satisfies parity from <span class="math notranslate nohighlight">\(v\)</span> we show that any cycle reachable from <span class="math notranslate nohighlight">\(v\)</span> is even.
Let us consider such a cycle:</p>
<div class="math notranslate nohighlight">
\[
(v_1,v_2) (v_2,v_3) \cdots (v_k,v_1).
\]</div>
<p>Since the cycle is reachable from <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>, this implies that <span class="math notranslate nohighlight">\(\mu(v_i) \neq \bot\)</span> for <span class="math notranslate nohighlight">\(i \in [1,k]\)</span>.
Let us assume towards contradiction that its maximal priority is odd, and without loss of generality it is <span class="math notranslate nohighlight">\(\col(v_1)\)</span>.
Applying our hypothesis to each edge of the cycle we have</p>
<div class="math notranslate nohighlight">
\[
\mu(v_1) \vartriangleleft_{\col(v_1)} \mu(v_2) \vartriangleleft_{\col(v_2)} \cdots 
\vartriangleleft_{\col(v_{k-1})} \mu(v_k) \vartriangleleft_{\col(v_k)} \mu(v_1).
\]</div>
<p>The second item of  <span class="xref std std-ref">Lemma</span> implies that <span class="math notranslate nohighlight">\(\mu(v_1) \vartriangleleft_{\col(v_1)} \mu(v_1)\)</span>,
which contradicts the third item since <span class="math notranslate nohighlight">\(\vartriangleleft_{\col(v_1)}\)</span> is non-reflexive given that <span class="math notranslate nohighlight">\(\col(v_1)\)</span> is odd.</p>
<p>Let us now prove the converse implication.
We prove the following property by induction on the number of vertices:
for all graphs satisfying parity (without the usual assumption that every vertex has an outgoing edge),
there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>
for all vertices <span class="math notranslate nohighlight">\(v \in V\)</span>.</p>
<p>There are two cases: either the largest priority <span class="math notranslate nohighlight">\(d\)</span> in the graph is even or it is odd.
We write <span class="math notranslate nohighlight">\(V_d\)</span> for the set of vertices of priority <span class="math notranslate nohighlight">\(d\)</span>.</p>
<p><strong>Case <span class="math notranslate nohighlight">\(d\)</span> even.</strong>
Let us consider the graph induced by the set of vertices <span class="math notranslate nohighlight">\(V \setminus V_d\)</span>.
It satisfies parity, so by induction hypothesis there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu_d : V \setminus V_d \to Y_t\)</span>
such that <span class="math notranslate nohighlight">\(\mu_d(v) \neq \bot\)</span> for all vertices <span class="math notranslate nohighlight">\(v \in V \setminus V_d\)</span>.
We extend <span class="math notranslate nohighlight">\(\mu_d\)</span> to <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span>: for <span class="math notranslate nohighlight">\(v \in V_d\)</span> we let <span class="math notranslate nohighlight">\(\mu(v) = \ell_{\max}\)</span> where <span class="math notranslate nohighlight">\(\ell_{\max}\)</span> is the maximal element in <span class="math notranslate nohighlight">\(Y_t\)</span>.
Then <span class="math notranslate nohighlight">\(\mu\)</span> is a progress measure such that <span class="math notranslate nohighlight">\(\mu_d(v) \neq \bot\)</span> for all vertices <span class="math notranslate nohighlight">\(v \in V\)</span>.
Indeed the additional edges are of the form <span class="math notranslate nohighlight">\((v,v')\)</span> for either <span class="math notranslate nohighlight">\(v \in V_d\)</span> or <span class="math notranslate nohighlight">\(v' \in V_d\)</span>:
in the first case <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span> holds because <span class="math notranslate nohighlight">\(\vartriangleleft_d\)</span> is the full relation,
and in the second case because <span class="math notranslate nohighlight">\(\mu(v') = \ell_{\max}\)</span>.</p>
<p><strong>Case <span class="math notranslate nohighlight">\(d\)</span> odd.</strong>
We claim that there exists a non-trivial partition <span class="math notranslate nohighlight">\(V = W_1 \uplus W_2\)</span> such that there is no edge from <span class="math notranslate nohighlight">\(W_1\)</span> to <span class="math notranslate nohighlight">\(W_2\)</span>.
Let <span class="math notranslate nohighlight">\(u \in V_d\)</span>, define <span class="math notranslate nohighlight">\(U\)</span> the set of vertices reachable from <span class="math notranslate nohighlight">\(u\)</span> by a non-trivial path.
If <span class="math notranslate nohighlight">\(U\)</span> is empty, then <span class="math notranslate nohighlight">\(V = \set{u} \uplus (V \setminus \set{u})\)</span> is a non-trivial partition as desired.
Otherwise <span class="math notranslate nohighlight">\(U\)</span> is non empty, then <span class="math notranslate nohighlight">\(V = U \uplus (V \setminus U)\)</span> is a non-trivial partition as desired:
to see that <span class="math notranslate nohighlight">\(V \setminus U\)</span> is non empty we note that <span class="math notranslate nohighlight">\(u \in V \setminus U\)</span>, otherwise there would be an odd cycle
(containing the maximal and odd priority <span class="math notranslate nohighlight">\(d\)</span>).</p>
<p>We consider the graphs induced by <span class="math notranslate nohighlight">\(W_1\)</span> and <span class="math notranslate nohighlight">\(W_2\)</span>.
They both satisfy parity, so by induction hypothesis for <span class="math notranslate nohighlight">\(i \in \set{1,2}\)</span>
there exists a tree <span class="math notranslate nohighlight">\(t_i\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu_i : W_i \to Y_{t_i}\)</span>
such that <span class="math notranslate nohighlight">\(\mu_i(v) \neq \bot\)</span> for all vertices <span class="math notranslate nohighlight">\(v \in W_i\)</span>.
We let <span class="math notranslate nohighlight">\(t\)</span> denote the tree obtained by putting the two trees <span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span> side by side with <span class="math notranslate nohighlight">\(t_2\)</span> on the left of <span class="math notranslate nohighlight">\(t_1\)</span>.
Formally, <span class="math notranslate nohighlight">\(t_1 = [t^1_1,\dots,t^k_1]\)</span> and <span class="math notranslate nohighlight">\(t_2 = [t^1_2,\dots,t^{k'}_2]\)</span>, let
<span class="math notranslate nohighlight">\(t = [t^1_2,\dots,t^{k'}_2,\ t^1_1,\dots,t^k_1]\)</span>.
We define <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> by <span class="math notranslate nohighlight">\(\mu(v) = \mu_i(v)\)</span> if <span class="math notranslate nohighlight">\(v \in W_i\)</span>.
Then <span class="math notranslate nohighlight">\(\mu\)</span> is a progress measure: for edges in the graphs induced by <span class="math notranslate nohighlight">\(W_1\)</span> and <span class="math notranslate nohighlight">\(W_2\)</span> this is because <span class="math notranslate nohighlight">\(\mu_1\)</span> and <span class="math notranslate nohighlight">\(\mu_2\)</span> are,
and the additional edges are from <span class="math notranslate nohighlight">\(v \in W_2\)</span> to <span class="math notranslate nohighlight">\(v' \in W_1\)</span>, so indeed <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span> holds.
This finishes the inductive proof of the property.</p>
<p>We show that the property extends to graphs not satisfying parity.
Let <span class="math notranslate nohighlight">\(G\)</span> a parity graph and <span class="math notranslate nohighlight">\(W\)</span> the set of vertices <span class="math notranslate nohighlight">\(v\)</span> such that <span class="math notranslate nohighlight">\(G\)</span> satisfies parity from <span class="math notranslate nohighlight">\(v\)</span>.
Let <span class="math notranslate nohighlight">\(G'\)</span> the graph induced by <span class="math notranslate nohighlight">\(W\)</span>, it satisfies parity so
by the property above there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu_W : W \to Y_t\)</span> such that
<span class="math notranslate nohighlight">\(\mu_W(v) \neq \bot\)</span> for all vertices <span class="math notranslate nohighlight">\(v \in W\)</span>.
We extend <span class="math notranslate nohighlight">\(\mu_W\)</span> to <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span>: for <span class="math notranslate nohighlight">\(v \notin W\)</span> we let <span class="math notranslate nohighlight">\(\mu(v) = \bot\)</span>.
To see that <span class="math notranslate nohighlight">\(\mu\)</span> is a progress measure we make two remarks.
First, if <span class="math notranslate nohighlight">\(v \in W\)</span> then all successors of <span class="math notranslate nohighlight">\(v\)</span> are also in <span class="math notranslate nohighlight">\(W\)</span> (by prefix independence of parity),
so the edges in <span class="math notranslate nohighlight">\(G\)</span> are either in <span class="math notranslate nohighlight">\(G'\)</span> or from <span class="math notranslate nohighlight">\(v \in V \setminus W\)</span> to <span class="math notranslate nohighlight">\(v' \in W\)</span>.
In the first case <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span> holds because <span class="math notranslate nohighlight">\(\mu_W\)</span> is a progress measure,
and in the second case because <span class="math notranslate nohighlight">\(\mu(v) = \bot\)</span>.</p>
</div>
<p>We can now prove  <a class="reference internal" href="#thm-progress-measure"><span class="std std-ref">Theorem</span></a>.</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Assume that Eve wins from <span class="math notranslate nohighlight">\(v\)</span> and let <span class="math notranslate nohighlight">\(\sigma\)</span> be a positional strategy.
The parity graph <span class="math notranslate nohighlight">\(\Game[\sigma]\)</span> satisfies parity from <span class="math notranslate nohighlight">\(v\)</span>, so thanks to  <a class="reference internal" href="#lem-progress-measure"><span class="std std-ref">Lemma</span></a>
there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a function <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>
and for all edges <span class="math notranslate nohighlight">\((v,v') \in E\)</span> we have <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.
We remark that <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> is actually a progress measure: the condition for <span class="math notranslate nohighlight">\(v \in \VE\)</span> is ensured by the edge <span class="math notranslate nohighlight">\(\sigma(v)\)</span>,
and the condition for <span class="math notranslate nohighlight">\(v \in \VA\)</span> by assumption on <span class="math notranslate nohighlight">\(\mu\)</span>.</p>
<p>Conversely, assume that there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span>.
It induces a positional strategy defined by <span class="math notranslate nohighlight">\(\sigma(v) = (v,v')\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.
We argue that <span class="math notranslate nohighlight">\(\sigma\)</span> is a winning strategy from any vertex <span class="math notranslate nohighlight">\(v\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.
This is a consequence of  <a class="reference internal" href="#lem-progress-measure"><span class="std std-ref">Lemma</span></a> for the parity graph <span class="math notranslate nohighlight">\(\Game[\sigma]\)</span>.</p>
</div>
<p><a class="reference internal" href="#thm-progress-measure"><span class="std std-ref">Theorem</span></a> is very close to the characterisation principle we are after,
the only difference being that the lattice <span class="math notranslate nohighlight">\((Y_t,\le)\)</span> depends on an existentially quantified tree <span class="math notranslate nohighlight">\(t\)</span>.
This is where we use universal trees:</p>
<div class="corollary admonition" id="cor-progress-measure">
<p class="admonition-title">Corollary</p>
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a parity game with <span class="math notranslate nohighlight">\(n\)</span> vertices and priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>, and <span class="math notranslate nohighlight">\(v\)</span> a vertex.
Let <span class="math notranslate nohighlight">\(T\)</span> be a <span class="math notranslate nohighlight">\((n,d/2)\)</span>-universal tree.
Then Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if there exists a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_T\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.</p>
</div>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Assume that Eve wins from <span class="math notranslate nohighlight">\(v\)</span>, thanks to  <a class="reference internal" href="#thm-progress-measure"><span class="std std-ref">Theorem</span></a> there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span>
such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.
Since <span class="math notranslate nohighlight">\(T\)</span> is <span class="math notranslate nohighlight">\((n,d/2)\)</span>-universal and <span class="math notranslate nohighlight">\(t\)</span> has at most <span class="math notranslate nohighlight">\(n\)</span> branches, <span class="math notranslate nohighlight">\(t\)</span> embeds into <span class="math notranslate nohighlight">\(T\)</span>,
which thanks to \cref{3-fact:embedding} implies that there exists <span class="math notranslate nohighlight">\(\mu' : B_t \to B_T\)</span> respecting the relations <span class="math notranslate nohighlight">\(\vartriangleleft\)</span>.
We extend it to <span class="math notranslate nohighlight">\(\mu' : Y_t \to Y_T\)</span> by <span class="math notranslate nohighlight">\(\mu'(\bot) = \bot\)</span>.
Then the composition <span class="math notranslate nohighlight">\(\mu' \circ \mu : V \to Y_T\)</span> is a progress measure such that <span class="math notranslate nohighlight">\((\mu' \circ \mu)(v) \neq \bot\)</span>.</p>
<p>The converse implication is a direct consequence of  <a class="reference internal" href="#thm-progress-measure"><span class="std std-ref">Theorem</span></a>.</p>
</div>
<p>We have proved that the characterisation principle holds for any <span class="math notranslate nohighlight">\((n,d/2)\)</span>-universal tree.</p>
</div>
<div class="section" id="the-algorithm">
<h2>The algorithm<a class="headerlink" href="#the-algorithm" title="Permalink to this headline">¶</a></h2>
<p>Let us fix <span class="math notranslate nohighlight">\(T\)</span> an <span class="math notranslate nohighlight">\((n,d/2)\)</span>-universal tree.
It induces both a lattice <span class="math notranslate nohighlight">\((Y_T,\le)\)</span> and a monotonic function <span class="math notranslate nohighlight">\(\delta_T : Y_T \times [1,d] \to Y_T\)</span>,
which in turn induces a monotonic operator <span class="math notranslate nohighlight">\(\Op_T : F_V \to F_V\)</span>.
Since <span class="math notranslate nohighlight">\(T\)</span> is fixed we do not specify the subscript <span class="math notranslate nohighlight">\(T\)</span> for all these objects.</p>
<p>The last step is to construct an algorithm returning the maximal progress measure relying on Kleene’s fixed point theorem (stated as  <a class="reference internal" href="../../Introduction/fixed_points.html#thm-kleene"><span class="std std-ref">Theorem</span></a>).
The generic algorithm is explained in  <a class="reference internal" href="../../Introduction/value_iteration.html#sec-value-iteration"><span class="std std-ref">Section</span></a>, let us instantiate it here.</p>
<p>For the complexity analysis it is useful to decompose <span class="math notranslate nohighlight">\(\Op\)</span> into a set of operators:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Op_v(\mu)(u) = 
\begin{cases}
\mu(v) &amp; \text{ if } u \neq v, \\
\max \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } u = v \in \VE, \\
\min \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } u = v \in \VA.
\end{cases}
\end{split}\]</div>
<p>We introduce some terminology: we say that an edge <span class="math notranslate nohighlight">\(e = (v,v')\)</span> is <strong>neglected</strong> if <span class="math notranslate nohighlight">\(\neg (\mu(v) \vartriangleleft_{\col(v)} \mu(v'))\)</span>,
and a vertex <span class="math notranslate nohighlight">\(v\)</span> is <strong>neglected</strong> if <span class="math notranslate nohighlight">\(\neg (\mu(v) \le \Op_v(\mu)(v))\)</span>.</p>
<div class="figure align-center" id="fig-lifting">
<img alt="../../_images/3-fig:lifting.png" src="../../_images/3-fig:lifting.png" />
<p class="caption"><span class="caption-number">Fig. 16 </span><span class="caption-text">The operator <span class="math notranslate nohighlight">\(\Op_v\)</span> in action: <span class="math notranslate nohighlight">\(\Op_v(\mu)(v)\)</span> is the maximal leaf (meaning the rightmost leaf)
which satisfies <span class="math notranslate nohighlight">\(\Op_v(\mu)(v) \vartriangleleft_3 \mu(v')\)</span> and <span class="math notranslate nohighlight">\(\Op_v(\mu)(v) \vartriangleleft_3 \mu(v'')\)</span>.</span><a class="headerlink" href="#fig-lifting" title="Permalink to this image">¶</a></p>
</div>
<p>The pseudocode for the algorithm is given in  <span class="xref std std-ref">Algorithm</span>,
where we let <span class="math notranslate nohighlight">\(\ell_{\max}\)</span> denote the maximal leaf in <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p>\begin{algorithm}[ht]
\KwData{A parity game with <span class="math notranslate nohighlight">\(n\)</span> vertices priorities in <span class="math notranslate nohighlight">\([1,d]\)</span> and a <span class="math notranslate nohighlight">\((n,d/2)\)</span>-universal tree <span class="math notranslate nohighlight">\(T\)</span>.}
\DontPrintSemicolon</p>
<p>\For{<span class="math notranslate nohighlight">\(v \in V\)</span>}{
<span class="math notranslate nohighlight">\(\mu(v) \leftarrow \ell_{\max}\)</span>
}</p>
<p>\Repeat{<span class="math notranslate nohighlight">\(\forall v \in V,\ \mu \le \Op_v(\mu)\)</span>}{
Choose <span class="math notranslate nohighlight">\(v \in V\)</span> which is neglected</p>
<p><span class="math notranslate nohighlight">\(\mu \leftarrow \min(\mu, \Op_v(\mu))\)</span>}</p>
<p>\Return{<span class="math notranslate nohighlight">\(\mu\)</span>}
\caption{The value iteration algorithm.}
\label{3-algo:value_iteration}
\end{algorithm}</p>
<div class="theorem admonition">
<p class="admonition-title">Theorem</p>
<p>For all <span class="math notranslate nohighlight">\((n, d/2)\)</span>-universal tree <span class="math notranslate nohighlight">\(T\)</span>, for all parity games <span class="math notranslate nohighlight">\(\game\)</span> with <span class="math notranslate nohighlight">\(n\)</span> vertices and priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>,
the value iteration algorithm over the tree <span class="math notranslate nohighlight">\(T\)</span> returns the maximal progress measure <span class="math notranslate nohighlight">\(\mu\)</span> for <span class="math notranslate nohighlight">\(\game\)</span> over <span class="math notranslate nohighlight">\(T\)</span>.</p>
</div>
<p>Thanks to \cref{3-cor:progress_measure}, the maximal progress measure yields a solution for parity games:
Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.</p>
</div>
<div class="section" id="complexity-analysis">
<h2>Complexity analysis<a class="headerlink" href="#complexity-analysis" title="Permalink to this headline">¶</a></h2>
<p>The number of times the operator <span class="math notranslate nohighlight">\(\Op_v\)</span> is used is bounded by the number of leaves of <span class="math notranslate nohighlight">\(T\)</span>,
which we write <span class="math notranslate nohighlight">\(|T|\)</span>, implying that the total number of iterations is bounded by <span class="math notranslate nohighlight">\(n \cdot |T|\)</span>.
To determine the overall complexity we need to discuss two aspects of the algorithm:</p>
<ul class="simple">
<li><p>the data structure and in particular the choice of the vertex <span class="math notranslate nohighlight">\(v\)</span> in the loop;</p></li>
<li><p>the computation of <span class="math notranslate nohighlight">\(\Op_v\)</span> and in particular the encoding of branches of <span class="math notranslate nohighlight">\(T\)</span>.</p></li>
</ul>
<p>We note that a vertex <span class="math notranslate nohighlight">\(v \in \VE\)</span> is neglected if and only if all its outgoing edges are neglected,
and a vertex <span class="math notranslate nohighlight">\(v \in \VA\)</span> is neglected if and only if it has a neglected outgoing edge.
Hence checking whether a vertex <span class="math notranslate nohighlight">\(v\)</span> is neglected requires considering all of its outgoing edges <span class="math notranslate nohighlight">\((v,v')\)</span>
and checking whether <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.
Let us write <span class="math notranslate nohighlight">\(\Delta\)</span> for the complexity of checking whether <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.
Hence checking whether <span class="math notranslate nohighlight">\(v\)</span> is neglected costs
<span class="math notranslate nohighlight">\(O(|\Ing^{-1}(v)| \cdot \Delta)\)</span>, where <span class="math notranslate nohighlight">\(|\Ing^{-1}(v)|\)</span> is the number of outgoing edges of <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>A naive implementation of  <span class="xref std std-ref">Algorithm</span> would in each repeat loop go through every vertex <span class="math notranslate nohighlight">\(v\)</span>
to check whether it is neglected.
This would incur a linear cost: <span class="math notranslate nohighlight">\(\sum_{v \in V} O(|\Ing^{-1}(v)| \cdot \Delta) = O(m \cdot \Delta)\)</span>.
Thus the overall complexity would be</p>
<div class="math notranslate nohighlight">
\[
O((m \cdot \Delta) \cdot (n \cdot |T|)) = O(nm \cdot \Delta \cdot |T|).
\]</div>
<p>Typically <span class="math notranslate nohighlight">\(\Delta\)</span> is small (we will see that for a well chosen universal tree <span class="math notranslate nohighlight">\(T\)</span> it is polylogarithmic in <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(d\)</span>),
and <span class="math notranslate nohighlight">\(T\)</span> is the dominating factor (quasipolynomial in <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(d\)</span> thanks to  <a class="reference internal" href="#thm-universal-tree"><span class="std std-ref">Theorem</span></a>).</p>
<p>We first explain that using a better data structure we can maintain the list of vertices <span class="math notranslate nohighlight">\(v\)</span> such that <span class="math notranslate nohighlight">\(\neg (\mu \le \Op_v(\mu))\)</span>,
saving a linear factor in the complexity.
We then discuss the cost <span class="math notranslate nohighlight">\(\Delta\)</span> by choosing an appropriate encoding of the quasipolynomial universal tree constructed in <a class="reference internal" href="#thm-universal-tree"><span class="std std-ref">Theorem</span></a>.</p>
<div class="section" id="data-structure">
<h3>Data structure<a class="headerlink" href="#data-structure" title="Permalink to this headline">¶</a></h3>
<p>We use a data structure similar to the attractor computation presented in  <a class="reference internal" href="../2_Regular/attractors.html#sec-attractors"><span class="std std-ref">Section</span></a>.
The pseudocode is given in  <span class="xref std std-ref">Algorithm</span>.
We did not provide the pseudocode for the functions <span class="math notranslate nohighlight">\(\texttt{Init}\)</span> and <span class="math notranslate nohighlight">\(\texttt{Update}\)</span>.</p>
<p>The data structure consists of the following objects:</p>
<ul class="simple">
<li><p>a leaf of <span class="math notranslate nohighlight">\(T\)</span> for each vertex, representing the current function <span class="math notranslate nohighlight">\(\mu : V \to Y\)</span>;</p></li>
<li><p>a set <span class="math notranslate nohighlight">\(S\)</span> of vertices (each vertex appears at most once in <span class="math notranslate nohighlight">\(S\)</span>, the order in which vertices are stored and retrieved from the set does not matter);</p></li>
<li><p>for each vertex of Eve a number of edges.</p></li>
</ul>
<p>For our complexity analysis we use the unit cost RAM model, see  <a class="reference internal" href="../../Introduction/computation.html#sec-computation"><span class="std std-ref">Section</span></a> for details.
In the case at hand let us choose for the machine word size <span class="math notranslate nohighlight">\(w = \log(m) + \log(d)\)</span>,
so that an edge together with its priority can be stored in one machine word.
The space complexity of this data structure depends on the encoding of <span class="math notranslate nohighlight">\(T\)</span>, which we will discuss later.</p>
<p>The invariant of the algorithm satisfied before each iteration of the repeat loop is the following:</p>
<ul class="simple">
<li><p>for <span class="math notranslate nohighlight">\(v \in \VA\)</span>, the value of <span class="math notranslate nohighlight">\(\text{number}\)</span>-<span class="math notranslate nohighlight">\(\text{neglected}\)</span>-<span class="math notranslate nohighlight">\(\text{edges}(v)\)</span>
is the number of neglected edges of <span class="math notranslate nohighlight">\(v\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(S\)</span> is the set of neglected vertices.</p></li>
</ul>
<p>The invariant is satisfied initially thanks to the function <span class="math notranslate nohighlight">\(\texttt{Init}\)</span>.
Let us assume that we choose and remove <span class="math notranslate nohighlight">\(v\)</span> from <span class="math notranslate nohighlight">\(S\)</span>.
Since we modify only <span class="math notranslate nohighlight">\(\mu(v)\)</span> the only potentially neglected vertices are in <span class="math notranslate nohighlight">\(S\)</span> (minus <span class="math notranslate nohighlight">\(v\)</span>) and the incoming edges of <span class="math notranslate nohighlight">\(v\)</span>;
for the latter each of them is checked and added to <span class="math notranslate nohighlight">\(S\)</span> when required.
By monotonicity, neglected vertices remain neglected so all vertices in <span class="math notranslate nohighlight">\(S\)</span> (minus <span class="math notranslate nohighlight">\(v\)</span>) are still neglected.
Hence the invariant is satisfied.</p>
<p>The invariant implies that the algorithm indeed implements <span class="xref std std-ref">Algorithm</span> hence returns the maximal progress measure,
but it also has implications on the complexity.
Indeed one iteration of the repeat loop over some vertex <span class="math notranslate nohighlight">\(v\)</span> involves</p>
<div class="math notranslate nohighlight">
\[
O\left( (|\Ing^{-1}(v)| + |\Out^{-1}(v)|) \cdot \Delta \right)
\]</div>
<p>operations,
the first term corresponds to updating <span class="math notranslate nohighlight">\(\mu(v)\)</span> and <span class="math notranslate nohighlight">\(\text{number}\)</span>-<span class="math notranslate nohighlight">\(\text{neglected}\)</span>-<span class="math notranslate nohighlight">\(\text{edges}(v)\)</span>,
which requires for each outgoing edge of <span class="math notranslate nohighlight">\(v\)</span> to compute <span class="math notranslate nohighlight">\(\delta\)</span>,
and the second term corresponds to considering all incoming edges of <span class="math notranslate nohighlight">\(v\)</span> and treating the neglected ones.
Thus the overall complexity is</p>
<div class="math notranslate nohighlight">
\[
O\left( 
\sum_{v \in V} (|\Ing^{-1}(v)| + |\Out^{-1}(v)|) \cdot \Delta \cdot |T|
\right) 
= O(m \cdot \Delta \cdot |T|).
\]</div>
<p>\begin{algorithm}
\KwData{A parity game with <span class="math notranslate nohighlight">\(n\)</span> vertices priorities in <span class="math notranslate nohighlight">\([1,d]\)</span> and a <span class="math notranslate nohighlight">\((n,d/2)\)</span>-universal tree <span class="math notranslate nohighlight">\(T\)</span>.}
\SetKwFunction{FTreat}{Treat}
\SetKwFunction{FVI}{ValueIteration}
\SetKwFunction{FInit}{Initialise}
\SetKwFunction{FUpdate}{Update}
\SetKwProg{Fn}{Function}{:}{}
\DontPrintSemicolon</p>
<p>\Fn{\FVI{}}{</p>
<p>\FInit{<span class="math notranslate nohighlight">\(\mu\)</span>, <span class="math notranslate nohighlight">\(\text{number}\)</span>-<span class="math notranslate nohighlight">\(\text{neglected}\)</span>-<span class="math notranslate nohighlight">\(\text{edges}\)</span>, <span class="math notranslate nohighlight">\(S\)</span>}</p>
<p>\Repeat{<span class="math notranslate nohighlight">\(S\)</span> empty}{
Choose some <span class="math notranslate nohighlight">\(v\)</span> in <span class="math notranslate nohighlight">\(S\)</span> and remove it from <span class="math notranslate nohighlight">\(S\)</span></p>
<p><span class="math notranslate nohighlight">\(\mu \leftarrow \min(\mu, \Op_v(\mu))\)</span></p>
<p>\FUpdate{<span class="math notranslate nohighlight">\(\text{number}\)</span>-<span class="math notranslate nohighlight">\(\text{neglected}\)</span>-<span class="math notranslate nohighlight">\(\text{edges}(v)\)</span>}</p>
<p>\For{<span class="math notranslate nohighlight">\(e \in E\)</span> \text{ such that } <span class="math notranslate nohighlight">\(\Out(e) = v\)</span>}{
\If{<span class="math notranslate nohighlight">\(e\)</span> is neglected}{
\FTreat(<span class="math notranslate nohighlight">\(e\)</span>)
}
}
}</p>
<p>\Return{<span class="math notranslate nohighlight">\(\mu\)</span>}
}</p>
<p>\Fn{\FTreat{<span class="math notranslate nohighlight">\(e\)</span>}}{
<span class="math notranslate nohighlight">\(v \leftarrow \Ing(e)\)</span></p>
<p>\If{<span class="math notranslate nohighlight">\(v \in \VA\)</span> and <span class="math notranslate nohighlight">\(v \notin S\)</span>}{
Add <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(S\)</span>
}</p>
<p>\If{<span class="math notranslate nohighlight">\(v \in \VE\)</span> and <span class="math notranslate nohighlight">\(v \notin S\)</span>}{
<span class="math notranslate nohighlight">\(\text{number}\)</span>-<span class="math notranslate nohighlight">\(\text{neglected}\)</span>-<span class="math notranslate nohighlight">\(\text{edges}(v) \leftarrow \text{number}\)</span>-<span class="math notranslate nohighlight">\(\text{neglected}\)</span>-<span class="math notranslate nohighlight">\(\text{edges}(v) + 1\)</span></p>
<p>\If{<span class="math notranslate nohighlight">\(\text{number}\)</span>-<span class="math notranslate nohighlight">\(\text{neglected}\)</span>-<span class="math notranslate nohighlight">\(\text{edges}(v) = \)</span> number of outgoing edges of <span class="math notranslate nohighlight">\(v\)</span>}{
Add <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(S\)</span>
}
}
}
\caption{The value iteration algorithm with explicit data structure.}
\label{3-algo:value_iteration_data_structure}
\end{algorithm}</p>
</div>
<div class="section" id="encoding-branches">
<h3>Encoding branches<a class="headerlink" href="#encoding-branches" title="Permalink to this headline">¶</a></h3>
<p>Let us fix <span class="math notranslate nohighlight">\(T\)</span> to be the quasipolynomial universal tree constructed in  <a class="reference internal" href="#thm-universal-tree"><span class="std std-ref">Theorem</span></a>.</p>
<p>In our definition of trees we say that a tree is an ordered list of subtrees <span class="math notranslate nohighlight">\([t_1,\dots,t_k]\)</span>,
so we use <span class="math notranslate nohighlight">\([1,k]\)</span> with the natural order for ordering the subtrees.
Any other total order can be used to that effect, and a more appropriate order may lead to smaller encoding.
Indeed, using <span class="math notranslate nohighlight">\([1,k]\)</span> for ordering subtrees, if a tree has height <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(n\)</span> branches then a branch is a sequence of <span class="math notranslate nohighlight">\(h\)</span> numbers in <span class="math notranslate nohighlight">\([1,n]\)</span>,
so it uses <span class="math notranslate nohighlight">\(O(h \log(n))\)</span> bits.</p>
<p>Let us consider an order well suited for encoding <span class="math notranslate nohighlight">\(T\)</span>.
We use <span class="math notranslate nohighlight">\(\set{0,1}^*\)</span> the set of binary words and order them using the following three rules that apply for any <span class="math notranslate nohighlight">\(u,v \in \set{0,1}^*\)</span>:</p>
<div class="math notranslate nohighlight">
\[
0u &lt; \varepsilon &lt; 1u \quad ; \quad (0u &lt; 0v \Longleftrightarrow u &lt; v) \quad ; \quad (1u &lt; 1v \Longleftrightarrow u &lt; v).
\]</div>
<p>For words of length at most <span class="math notranslate nohighlight">\(2\)</span> the order is <span class="math notranslate nohighlight">\(00 &lt; 0 &lt; 01 &lt; \varepsilon &lt; 10 &lt; 1 &lt; 11\)</span>.</p>
<div class="figure align-center" id="fig-tree-encoded">
<img alt="../../_images/3-fig:tree_encoded.png" src="../../_images/3-fig:tree_encoded.png" />
<p class="caption"><span class="caption-number">Fig. 17 </span><span class="caption-text">The succinct encoding on the <span class="math notranslate nohighlight">\((5,2)\)</span>-universal tree.</span><a class="headerlink" href="#fig-tree-encoded" title="Permalink to this image">¶</a></p>
</div>
<p>We can now revisit the construction of the universal tree by defining directly the set of branches.
Recall that <span class="math notranslate nohighlight">\(T\)</span> is obtained from <span class="math notranslate nohighlight">\(T_\text{left},T_\text{middle}\)</span>, and <span class="math notranslate nohighlight">\(T_\text{right}\)</span>.
By induction hypothesis branches in <span class="math notranslate nohighlight">\(T_\text{left}\)</span> and <span class="math notranslate nohighlight">\(T_\text{right}\)</span> are tuples of length <span class="math notranslate nohighlight">\(h-1\)</span>
and branches in <span class="math notranslate nohighlight">\(T_\text{middle}\)</span> tuples of length <span class="math notranslate nohighlight">\(h\)</span>.
The branches of <span class="math notranslate nohighlight">\(T\)</span> are:</p>
<ul class="simple">
<li><p>branches of <span class="math notranslate nohighlight">\(T_\text{left}\)</span> where the first component is prefixed with a <span class="math notranslate nohighlight">\(0\)</span>;</p></li>
<li><p>branches of <span class="math notranslate nohighlight">\(T_\text{middle}\)</span> augmented with a new component <span class="math notranslate nohighlight">\(\varepsilon\)</span>;</p></li>
<li><p>branches of <span class="math notranslate nohighlight">\(T_\text{right}\)</span> where the first component is prefixed with a <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
</ul>
<p>We call this encoding the succinct encoding, it is illustrated in  <a class="reference internal" href="#fig-tree-encoded"><span class="std std-ref">Figure</span></a> for the <span class="math notranslate nohighlight">\((5,2)\)</span>-universal tree.
The leftmost branch is <span class="math notranslate nohighlight">\((00,\varepsilon)\)</span>, and the middle branch <span class="math notranslate nohighlight">\((\varepsilon,\varepsilon)\)</span>.
In general, the inductive construction implies that every branch is a tuple <span class="math notranslate nohighlight">\((D_{d-1},\dots,D_1)\)</span>
such that the sum of the lengths of the directions <span class="math notranslate nohighlight">\(D_i\)</span> is at most <span class="math notranslate nohighlight">\(\log(n)\)</span>.
Thus a branch is encoded using <span class="math notranslate nohighlight">\(O(\log(h) \log(n))\)</span> bits: for each of the <span class="math notranslate nohighlight">\(\log(n)\)</span> bits we need <span class="math notranslate nohighlight">\(\log(h)\)</span> bits to specify its component.</p>
<p>In terms of machine words of size <span class="math notranslate nohighlight">\(w = \log(n) + \log(d)\)</span>, this means that a branch can be stored using <span class="math notranslate nohighlight">\(\log(d)\)</span> machine words.
Hence the data structure uses <span class="math notranslate nohighlight">\(O(n \log(d))\)</span> machine words, with together with the input size <span class="math notranslate nohighlight">\(O(m)\)</span>
means that the space complexity of the algorithm is <span class="math notranslate nohighlight">\(O(m + n \log(d))\)</span>.</p>
<p>Using the succinct encoding and a tedious but simple case analysis we can compute <span class="math notranslate nohighlight">\(\delta(b,p)\)</span> in time <span class="math notranslate nohighlight">\(O(\log(n) \log(d))\)</span>.
Putting everything together we obtain the overall complexity</p>
<div class="math notranslate nohighlight">
\[
O\left(nm \log(n) \log(d) \cdot  \binom{\lceil \log(n) \rceil + d/2 - 1}{\lceil \log(n) \rceil} \right),
\]</div>
<p>as stated in  <a class="reference internal" href="#thm-value-iteration-quasipoly"><span class="std std-ref">Theorem</span></a>.</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./Classic/3_Parity"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="separation.html" title="previous page">A quasipolynomial time separating automata algorithm</a>
    <a class='right-next' id="next-link" href="relationships.html" title="next page">Comparing the three families of algorithms</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>