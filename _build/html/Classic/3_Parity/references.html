
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bibliographic references &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"set": ["\\left\\{ #1 \\right\\}", 1], "Eve": "\\textrm{Eve}", "Adam": "\\textrm{Adam}", "N": "\\mathbb{N}", "Z": "\\mathbb{Z}", "Zinfty": "\\Z \\cup \\set{\\pm \\infty}", "R": "\\mathbb{R}", "Rinfty": "\\R \\cup \\set{\\pm \\infty}", "Q": "\\mathbb{Q}", "Qinfty": "\\Q \\cup \\set{\\pm \\infty}", "argmax": "\\text{argmax}", "argmin": "\\text{argmin}", "Op": "\\mathbb{O}", "Prob": "\\mathbb{P}", "dist": "\\mathcal{D}", "Dist": "\\dist", "supp": "\\text{supp}", "game": "\\mathcal{G}", "Game": "\\game", "arena": "\\mathcal{A}", "Arena": "\\arena", "col": "\\textsf{col}", "Col": "\\col", "mEve": "\\mathrm{Eve}", "mAdam": "\\mathrm{Adam}", "mRandom": "\\mathrm{Random}", "vertices": "V", "VE": "V_\\mEve", "VA": "V_\\mAdam", "VR": "V_\\mRandom", "ing": "\\text{In}", "Ing": "\\ing", "out": "\\text{Out}", "Out": "\\out", "dest": "\\Delta", "WE": "W_\\mEve", "WA": "W_\\mAdam", "Paths": "\\text{Paths}", "play": "\\pi", "first": "\\text{first}", "last": "\\text{last}", "mem": "\\mathcal{M}", "Mem": "\\mem", "Pre": "\\text{Pre}", "PreE": "\\text{Pre}_\\mEve", "PreA": "\\text{Pre}_\\mAdam", "Attr": "\\text{Attr}", "AttrE": "\\text{Attr}_\\mEve", "AttrA": "\\text{Attr}_\\mAdam", "rank": "\\text{rank}", "Win": "\\textsc{Win}", "Lose": "\\textsc{Lose}", "Value": "\\text{val}", "ValueE": "\\text{val}_\\mEve", "ValueA": "\\text{val}_\\mAdam", "val": "\\Value", "Automaton": "\\mathbf{A}", "Safe": "\\mathtt{Safe}", "Reach": "\\mathtt{Reach}", "Buchi": "\\mathtt{Buchi}", "CoBuchi": "\\mathtt{CoBuchi}", "Parity": "\\mathtt{Parity}", "Muller": "\\mathtt{Muller}", "Rabin": "\\mathtt{Rabin}", "Streett": "\\mathtt{Streett}", "MeanPayoff": "\\mathtt{MeanPayoff}", "DiscountedPayoff": "\\mathtt{DiscountedPayoff}", "Energy": "\\mathtt{Energy}", "TotalPayoff": "\\mathtt{TotalPayoff}", "ShortestPath": "\\mathtt{ShortestPath}", "Sup": "\\mathtt{Sup}", "Inf": "\\mathtt{Inf}", "LimSup": "\\mathtt{LimSup}", "LimInf": "\\mathtt{LimInf}"}}, "tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Payoffs" href="../4_Payoffs/index.html" />
    <link rel="prev" title="Comparing the three families of algorithms" href="relationships.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../book.html">
   Games on Graphs
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../../Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../2_Regular/index.html">
   Regular
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/attractors.html">
     A linear time algorithm for reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/buchi.html">
     A quadratic time algorithm for BÃ¼chi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/parity.html">
     An exponential time algorithm for parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/zielonka.html">
     The Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Parity
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/Classic/3_Parity/references.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="bibliographic-references">
<span id="sec-references"></span><h1>Bibliographic references<a class="headerlink" href="#bibliographic-references" title="Permalink to this headline">Â¶</a></h1>
<p>We refer to <a class="reference internal" href="../2_Regular/references.html#sec-references"><span class="std std-ref">Section</span></a> for the role of parity objectives and how they emerged in automata theory as a subclass of Muller objectives.
Another related motivation comes from the works of Emerson, Jutla, and Sistla <span id="id1">[<span>Emerson&amp;Jutla&amp;Sistla:1993</span>]</span>,
who showed that solving parity games is linear-time equivalent to the model-checking problem for modal <span class="math notranslate nohighlight">\(\mu\)</span>-calculus.
This logical formalism is an established tool in program verification, and a common denominator to a wide range of modal, temporal and fixpoint logics used in various fields.</p>
<p>Let us discuss the progress obtained over the years for each of the three families of algorithms.</p>
<p><strong>Value iteration algorithms and separating automata</strong>.
The heart of value iteration algorithms is the value function, which in the context of parity games and related developments for automata
have been studied under the name progress measures or signatures.
They appear naturally in the context of fixed point computations so it is hard to determine who first introduced them.
Streett and Emerson <span id="id2">[<span>Streett&amp;Emerson:1984</span><span>Streett&amp;Emerson:1989</span>]</span> defined signatures for the study of the modal <span class="math notranslate nohighlight">\(\mu\)</span>-calculus,
and Stirling and Walker <span id="id3">[<span>Stirling&amp;Walker:1989</span>]</span> later developped the notion.
Both the proofs of Emerson and Jutla <span id="id4">[<span>Emerson&amp;Jutla:1991</span>]</span> and of Walukiewicz <span id="id5">[<span>Walukiewicz:1996</span>]</span> use signatures to show the positionality of parity games over infinite games.</p>
<p>JurdziÅski <span id="id6">[<span>Jurdzinski:2000</span>]</span> used this notion to give the first value iteration algorithm for parity games,
with running time <span class="math notranslate nohighlight">\(O(m n^{d/2})\)</span>.
The algorithm is called small progress measures and is an instance of the class of value iteration algorithms we construct
in <a class="reference internal" href="value_iteration.html#sec-value-iteration"><span class="std std-ref">Section</span></a> by considering the universal tree of size <span class="math notranslate nohighlight">\(n^h\)</span>.
Bernet, Janin, and Walukiewicz <span id="id7">[<span>Bernet&amp;Janin&amp;Walukiewicz:2002</span>]</span> investigated reductions from parity games to safety games
through the notion of permissive strategies, and constructed a separating automaton\footnote{We note that the general framework of separating automata came later, introduced by BojaÅczyk and CzerwiÅski <span id="id8">[<span>Bojanczyk&amp;Czerwinski:2018</span>]</span>.} corresponding to the universal tree of size <span class="math notranslate nohighlight">\(n^h\)</span>.</p>
<p>The new era for parity games started in 2017 when Calude, Jain, Khoussainov, Li, and Stephan <span id="id9">[<span>Calude&amp;Jain&amp;al:2017</span>]</span> constructed a quasipolynomial time algorithm.
Our presentation follows the technical developments of the subsequent paper by Fearnley, Jain, Schewe, Stephan, and Wojtczak <span id="id10">[<span>Fearnley&amp;Jain&amp;al:2017</span>]</span> which recasts the algorithm as a value iteration algorithm.
BojaÅczyk and CzerwiÅski <span id="id11">[<span>Bojanczyk&amp;Czerwinski:2018</span>]</span> introduce the separation framework to better understand the original algorithm.</p>
<p>Soon after two other quasipolynomial time algorithms emerged.
JurdziÅski and Lazi{âc} <span id="id12">[<span>Jurdzinski&amp;Lazic:2017</span>]</span> showed that the small progress measure algorithm can be adapted to a succinct progress measure algorithm, matching (and slightly improving) the quasipolynomial time complexity.
The presentation using universal tree that we follow in <a class="reference internal" href="value_iteration.html#sec-value-iteration"><span class="std std-ref">Section</span></a> and an almost matching lower bound on their sizes is due to Fijalkow <span id="id13">[<span>Fijalkow:2018</span>]</span>.
The connection between separating automata and universal trees was shown by CzerwiÅski, Daviaud, Fijalkow, JurdziÅski, Lazi{âc}, and Parys <span id="id14">[<span>Czerwinski&amp;Daviaud&amp;al:2018</span>]</span>.</p>
<p>The third quasipolynomial time algorithm is due to Lehtinen <span id="id15">[<span>Lehtinen:2018</span>]</span>.
The original algorithm has a slightly worse complexity (<span class="math notranslate nohighlight">\(n^{O(\log(n))}\)</span> instead of <span class="math notranslate nohighlight">\(n^{O(\log(d))}\)</span>),
but Parys <span id="id16">[<span>Parys:2020</span>]</span> later improved the construction to (essentially) match the complexity of the previous two algorithms.
Although not explicitly, the algorithm constructs an automaton with similar properties as a separating automaton,
but the automaton is non-deterministic.
Colcombet and Fijalkow <span id="id17">[<span>Colcombet&amp;Fijalkow:2019</span>]</span> revisited the link between separating automata and universal trees
and proposed the notion of good for small games automata, capturing the automaton defined by Lehtinenâs algorithm.
The equivalence result between separating automata, good for small games automata, and universal graphs, holds for any positionally determined objective, giving a strong theoretical foundation for the family of value iteration algorithms.</p>
<p><strong>Attractor decomposition algorithms</strong>.
The McNaughton Zielonkaâs algorithm has complexity <span class="math notranslate nohighlight">\(O(m n^d)\)</span>.
Parys <span id="id18">[<span>Parys:2019</span>]</span> constructed the fourth quasipolynomial time algorithm as an improved take over McNaughton Zielonkaâs algorithm.
As for Lehtinenâs algorithm, the original algorithm has a slightly worse complexity (<span class="math notranslate nohighlight">\(n^{O(\log(n))}\)</span> instead of <span class="math notranslate nohighlight">\(n^{O(\log(d))}\)</span>).
Lehtinen, Schewe, and Wojtczak <span id="id19">[<span>Lehtinen&amp;Schewe&amp;Wojtczak:2019</span>]</span> later improved the construction.
As discussed in <a class="reference internal" href="relationships.html#sec-relationships"><span class="std std-ref">Section</span></a> the complexity of this algorithm is quasipolynomial and of the form <span class="math notranslate nohighlight">\(n^{O(\log(d))}\)</span>,
but a bit worse than the three previous algorithms since the algorithm is symmetric and has a recursion depth of <span class="math notranslate nohighlight">\(d\)</span>,
while the value iteration algorithms only consider odd priorities hence replace <span class="math notranslate nohighlight">\(d\)</span> by <span class="math notranslate nohighlight">\(d/2\)</span>.</p>
<p>JurdziÅski and Morvan <span id="id20">[<span>Jurdzinksi&amp;Morvan:2020</span>]</span> constructed a generic McNaughton Zielonkaâs algorithm parameterised by the choice of two universal trees, one for each player.
\mynote{CONTINUE}</p>
<p><strong>Strategy improvement algorithms</strong>.
As we will see in <span class="xref std std-ref">Chapter</span>, parity games can be reduced to mean payoff games,
so any algorithm for solving mean payoff games can be used for solving parity games.
In particular, the existing strategy improvement algorithm for mean payoff games can be run on parity games.
V{âo}ge and JurdzinÅski <span id="id21">[<span>Voge&amp;Jurdzinski:2000</span>]</span> introduced the first discrete strategy improvement for parity games,
running in exponential time.
For some time there was some hope that the strategy improvement algorithm, for some well chosen policy on switching edges,
solves parity games in polynomial time.
Friedmann <span id="id22">[<span>Friedmann:2011</span>]</span> cast some serious doubts by constructing numerous exponential lower bounds applying to different variants of the algorithm.
Fearnley <span id="id23">[<span>Fearnley:2017</span>]</span> investigated efficient implementations of the algorithm, focussing on the cost of computing and updating the value function for a given strategy.
Our proof of correctness is original. \mynote{SAY MORE?}</p>
<p>The complexity was reduced to subexponential with randomised algorithms
by JurdzinÅski, Paterson, and Zwick <span id="id24">[<span>Jurdzinski&amp;Paterson&amp;Zwick:2008</span>]</span>.
A natural question is whether there exists a quasipolynomial strategy improvement algorithm;
as discussed in <a class="reference internal" href="relationships.html#sec-relationships"><span class="std std-ref">Section</span></a> the notion of universal trees cannot be used to achieve this,
and the question remains to this day open.</p>
<p id="id25"><dl class="citation">
<dt class="label" id="id26"><span class="brackets">BT97</span></dt>
<dd><p>Dimitris Bertsimas and JohnÂ N. Tsitsiklis. <em>Introduction to linear optimization</em>. VolumeÂ 6 of Athena scientific optimization and computation series. Athena Scientific, 1997. ISBN 978-1-886529-19-9.</p>
</dd>
<dt class="label" id="id43"><span class="brackets">Tho97</span></dt>
<dd><p>Wolfgang Thomas. Languages, automata, and logic. In <em>Handbook of Formal Languages, Volume 3: Beyond Words</em>, pages 389â455. Springer-Verlag, 1997.</p>
</dd>
<dt class="label" id="id46"><span class="brackets">Zer13</span></dt>
<dd><p>Ernst Zermelo. Uber eine anwendung der mengenlehre auf die theorie des schachspiels. In <em>Proceedings of the International Congress of Mathematicians, ICM'13</em>, volumeÂ 2, 501â504. Cambridge University Press, 1913.</p>
</dd>
<dt class="label" id="id39"><span class="brackets">Mar75</span></dt>
<dd><p>DonaldÂ A. Martin. Borel determinacy. <em>Annals of Mathematics</em>, 102(2):363â371, 1975.</p>
</dd>
<dt class="label" id="id34"><span class="brackets">GS53</span></dt>
<dd><p>David Gale and F.M. Stewart. Infinite games with perfect information. <em>Annals of Mathematical Studies</em>, 28:245â266, 1953.</p>
</dd>
<dt class="label" id="id29"><span class="brackets">Chu57</span></dt>
<dd><p>Alonzo Church. Applications of recursive arithmetic to the problem of cricuit synthesis. In <em>Summaries of the Summer Institute of Symbolic Logic</em>, volumeÂ I, pages 3â50. Cornell University, 1957.</p>
</dd>
<dt class="label" id="id30"><span class="brackets">Chu62</span></dt>
<dd><p>Alonzo Church. Logic, arithmetic, and automata. In <em>Proceedings of the International Congress of Mathematicians</em>, 23â35. 1962.</p>
</dd>
<dt class="label" id="id27"><span class="brackets">BuchiL69</span></dt>
<dd><p>J.Â Richard BÃ¼chi and LawrenceÂ H. Landweber. Solving sequential conditions by finite-state strategies. <em>Transactions of the American Mathematical Society</em>, 138:295â311, 1969.</p>
</dd>
<dt class="label" id="id38"><span class="brackets">Lan67</span></dt>
<dd><p>LawrenceÂ H. Landweber. Finite state gamesâa solvability algorithm for restricted second-order arithmetic. <em>Notices of the American Mathematical Society</em>, 14:129â130, 1967.</p>
</dd>
<dt class="label" id="id40"><span class="brackets">McN65</span></dt>
<dd><p>Robert McNaughton. Finite-state infinite games. Technical Report, Massachusetts Institute of Technology, 1965.</p>
</dd>
<dt class="label" id="id41"><span class="brackets">McN66</span></dt>
<dd><p>Robert McNaughton. Testing and generating infinite sequences by a finite automaton. <em>Information and Computation</em>, 9(5):521â530, 1966.</p>
</dd>
<dt class="label" id="id42"><span class="brackets">Tho09</span></dt>
<dd><p>Wolfgang Thomas. Facets of synthesis: revisiting Church's problem. In <em>Proceedings of the International Conference on the Foundations of Software Science and Computational Structures, FoSSaCS'09</em>, 1â14. 2009.</p>
</dd>
<dt class="label" id="id44"><span class="brackets">Rab69</span></dt>
<dd><p>MichaelÂ O. Rabin. Decidability of second-order theories and automata on infinite trees. <em>Transactions of the American Mathematical Society</em>, 141:1â35, 1969.</p>
</dd>
<dt class="label" id="id36"><span class="brackets">GH82</span></dt>
<dd><p>Yuri Gurevich and Leo Harrington. Trees, automata, and games. In <em>Proceedings of the Annual ACM Symposium on Theory of Computing, STOC'82</em>, 60â65. ACM Press, 1982.</p>
</dd>
<dt class="label" id="id28"><span class="brackets">Buchi77</span></dt>
<dd><p>J.Â Richard BÃ¼chi. Using determinancy of games to eliminate quantifiers. In <em>Fundamentals of Computation Theory77</em>, 367â378. 1977.</p>
</dd>
<dt class="label" id="id37"><span class="brackets">Hod93</span></dt>
<dd><p>Wilfrid Hodges. <em>Model theory</em>. VolumeÂ 42 of Encyclopedia of mathematics and its applications. Cambridge University Press, 1993.</p>
</dd>
<dt class="label" id="id35"><span class="brackets">Gradel02</span></dt>
<dd><p>Erich GrÃ¤del. Model checking games. <em>Electronic Notes in Theoretical Computer Science</em>, 67:15â34, 2002.</p>
</dd>
<dt class="label" id="id31"><span class="brackets">Ehr61</span></dt>
<dd><p>Andrzej Ehrenfeucht. An application of games to the completeness problem for formalized theories. <em>Comptes-rendus de l'AcadÃ©mie des Sciences</em>, 49:129â141, 1961.</p>
</dd>
</dl>
</p>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./Classic/3_Parity"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="relationships.html" title="previous page">Comparing the three families of algorithms</a>
    <a class='right-next' id="next-link" href="../4_Payoffs/index.html" title="next page">Payoffs</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>