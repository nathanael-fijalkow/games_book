
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rabin, Streett, and Muller games &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Zielonka tree" href="zielonka.html" />
    <link rel="prev" title="Parity games" href="parity.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../1_Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Regular Games
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="attractors.html">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="buchi.html">
     BÃ¼chi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../3_Parity/index.html">
   Parity Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Games with Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../5_MDP/index.html">
   Markov Decision Processes
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reachability.html">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../6_Stochastic/index.html">
   Stochastic Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/determinacy.html">
     Positional determinacy of stochastic reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/relations.html">
     Relations between all games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/algos.html">
     Algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Information
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../7_Concurrent/index.html">
   Concurrent Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/matrix_games.html">
     Matrix games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/reachability.html">
     Concurrent reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/mean_payoff.html">
     Concurrent mean-payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/references.html">
     Bibilographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../8_Imperfect/index.html">
   Games with Signals
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/finite_duration.html">
     Finite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/infinite_duration.html">
     Infinite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Infinite
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../9_Timed/index.html">
   Timed Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/state_space_representation.html">
     State-Space Representation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/controllable_predecessor_operator.html">
     Controllable-Predecessor Operator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/backward_algorithm.html">
     Backward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/forward_algorithm.html">
     Forward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../10_Pushdown/index.html">
   Pushdown Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/profiles.html">
     Profiles and regularity of the winning regions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/parity.html">
     Parity pushdown games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../11_Counters/index.html">
   Games with Counters
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/counters.html">
     Vector games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/dim1.html">
     Games in dimension one
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/avag.html">
     Asymmetric games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/resource.html">
     Resource-conscious games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/complexity.html">
     The complexity of asymmetric monotone games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Multi
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../12_Multiobjectives/index.html">
   Games with multiple objectives
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/mean_payoff_energy.html">
     Mean-payoff and energy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/total_payoff_shortest_path.html">
     Total-payoff and shortest path
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/beyond_worst_case.html">
     Beyond worst-case synthesis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/percentile.html">
     Percentile queries
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../13_Multiplayer/index.html">
   Multiplayer Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/nash_equilibria_normal_form.html">
     Nash Equilibria for games in normal form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/admissible_strategies.html">
     Admissible strategies
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#mcnaughton-algorithm-an-exponential-time-algorithm-for-muller-games">
   McNaughton algorithm: an exponential time algorithm for Muller games
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#positional-determinacy-for-rabin-games">
   Positional determinacy for Rabin games
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-complexity-of-solving-rabin-games">
   The complexity of solving Rabin games
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-complexity-of-solving-muller-games">
   The complexity of solving Muller games
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="rabin-streett-and-muller-games">
<span id="sec-muller"></span><h1>Rabin, Streett, and Muller games<a class="headerlink" href="#rabin-streett-and-muller-games" title="Permalink to this headline">Â¶</a></h1>
<div class="math notranslate nohighlight">
\[\newcommand{\F}{\mathcal{F}} 
\newcommand{\LAR}{\mathrm{LAR}}
\newcommand{\Zielonka}{\mathrm{Zielonka}}
\newcommand{\depth}{\mathrm{depth}}
\newcommand{\support}{\mathrm{supp}}
\newcommand{\Eve}{\textrm{Eve}}
\newcommand{\Adam}{\textrm{Adam}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zinfty}{\Z \cup \set{\pm \infty}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rinfty}{\R \cup \set{\pm \infty}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Qinfty}{\Q \cup \set{\pm \infty}}
\newcommand{\argmax}{\textrm{argmax}}
\newcommand{\argmin}{\textrm{argmin}}
\newcommand{\Op}{\mathbb{O}}
\newcommand{\Prob}{\mathbb{P}} \newcommand{\dist}{\mathcal{D}} \newcommand{\Dist}{\dist} \newcommand{\supp}{\textrm{supp}} 
\newcommand{\game}{\mathcal{G}} \renewcommand{\Game}{\game} \newcommand{\arena}{\mathcal{A}} \newcommand{\Arena}{\arena} 
\newcommand{\col}{\textsf{col}} \newcommand{\Col}{\col} 
\newcommand{\mEve}{\mathrm{Eve}}
\newcommand{\mAdam}{\mathrm{Adam}}
\newcommand{\mRandom}{\mathrm{Random}}
\newcommand{\vertices}{V} \newcommand{\VE}{V_\mEve} \newcommand{\VA}{V_\mAdam} \newcommand{\VR}{V_\mRandom} 
\newcommand{\ing}{\textrm{In}}
\newcommand{\Ing}{\ing}
\newcommand{\out}{\textrm{Out}}
\newcommand{\Out}{\out}
\newcommand{\dest}{\Delta} 
\newcommand{\WE}{W_\mEve} \newcommand{\WA}{W_\mAdam} 
\newcommand{\Paths}{\textrm{Paths}} \newcommand{\play}{\pi} \newcommand{\first}{\textrm{first}} \newcommand{\last}{\textrm{last}} 
\newcommand{\mem}{\mathcal{M}} \newcommand{\Mem}{\mem} 
\newcommand{\Pre}{\textrm{Pre}} \newcommand{\PreE}{\textrm{Pre}_\mEve} \newcommand{\PreA}{\textrm{Pre}_\mAdam} \newcommand{\Attr}{\textrm{Attr}} \newcommand{\AttrE}{\textrm{Attr}_\mEve} \newcommand{\AttrA}{\textrm{Attr}_\mAdam} \newcommand{\rank}{\textrm{rank}}
\newcommand{\Win}{\textrm{Win}} 
\newcommand{\Lose}{\textrm{Lose}} 
\newcommand{\Value}{\textrm{val}} 
\newcommand{\ValueE}{\textrm{val}_\mEve} 
\newcommand{\ValueA}{\textrm{val}_\mAdam}
\newcommand{\val}{\Value} 
\newcommand{\Automaton}{\mathbf{A}} 
\newcommand{\Safe}{\mathtt{Safe}}
\newcommand{\Reach}{\mathtt{Reach}} 
\newcommand{\Buchi}{\mathtt{Buchi}} 
\newcommand{\CoBuchi}{\mathtt{CoBuchi}} 
\newcommand{\Parity}{\mathtt{Parity}} 
\newcommand{\Muller}{\mathtt{Muller}} 
\newcommand{\Rabin}{\mathtt{Rabin}} 
\newcommand{\Streett}{\mathtt{Streett}} 
\newcommand{\MeanPayoff}{\mathtt{MeanPayoff}} 
\newcommand{\DiscountedPayoff}{\mathtt{DiscountedPayoff}}
\newcommand{\Energy}{\mathtt{Energy}}
\newcommand{\TotalPayoff}{\mathtt{TotalPayoff}}
\newcommand{\ShortestPath}{\mathtt{ShortestPath}}
\newcommand{\Sup}{\mathtt{Sup}}
\newcommand{\Inf}{\mathtt{Inf}}
\newcommand{\LimSup}{\mathtt{LimSup}}
\newcommand{\LimInf}{\mathtt{LimInf}}
\newcommand{\NL}{\textrm{NL}}
\newcommand{\PTIME}{\textrm{PTIME}}
\newcommand{\NP}{\textrm{NP}}
\newcommand{\UP}{\textrm{UP}}
\newcommand{\coNP}{\textrm{coNP}}
\newcommand{\coUP}{\textrm{coUP}}
\newcommand{\PSPACE}{\textrm{PSPACE}}
\newcommand{\EXPSPACE}{\textrm{EXPSPACE}}
\newcommand{\EXP}{\textrm{EXP}}
\newcommand{\kEXP}{\textrm{kEXP}}\]</div>
<p>The prefix independent objectives we studied so far are BÃ¼chi, CoBÃ¼chi, and their joint extension the parity objectives.
The definition of the latter may seem a bit arbitrary; the study of Muller objectives will show how parity objectives naturally emerge as a well-behaved class of objectives.</p>
<p>Let us start with a very general class of infinitary objectives, where infinitary means that the objective only considers the set of colours appearing infinitely many times.
For a sequence <span class="math notranslate nohighlight">\(\rho\)</span>, we let <span class="math notranslate nohighlight">\(\Inf(\rho)\)</span> denote the set of colours appearing infinitely many times in <span class="math notranslate nohighlight">\(\rho\)</span>.
The Muller objective is over the set of colours <span class="math notranslate nohighlight">\(C = [1,d]\)</span> and is parametrised by some <span class="math notranslate nohighlight">\(\F \subseteq 2^C\)</span>, <strong>i.e.</strong> a family of subsets of <span class="math notranslate nohighlight">\(C\)</span>.
The objective is defined as follows:</p>
<div class="math notranslate nohighlight">
\[
\Muller(\F) = \set{ \rho \in C^\omega : \Inf(\rho) \in \F }.
\]</div>
<p>Muller objectives include any objective specifying the set of colours appearing infinitely often.
There are different possible representations for a Muller objective, for instance using logical formulas or circuits.
We will here consider the most natural one which simply consists in listing the elements of <span class="math notranslate nohighlight">\(\F\)</span>.
Note that <span class="math notranslate nohighlight">\(\F\)</span> can have size up to <span class="math notranslate nohighlight">\(2^{2^d}\)</span>, and each element of <span class="math notranslate nohighlight">\(\F\)</span> (which is a subset of <span class="math notranslate nohighlight">\(C\)</span>)
requires up to <span class="math notranslate nohighlight">\(d\)</span> bits to be identified, so the representation of <span class="math notranslate nohighlight">\(\F\)</span> can be very large.</p>
<p>We note that the complement of a Muller objective is another Muller objective:
<span class="math notranslate nohighlight">\(C^\omega \setminus \Muller(\F) = \Muller(2^C \setminus \F)\)</span>.
In particular if Eve has a Muller objective then Adam also has a Muller objective.</p>
<p>To define subclasses of Muller objectives we make assumptions on <span class="math notranslate nohighlight">\(\F \subseteq 2^C\)</span>.
We say that <span class="math notranslate nohighlight">\(\F\)</span> is closed under union if whenever <span class="math notranslate nohighlight">\(X,Y \in \F\)</span> then <span class="math notranslate nohighlight">\(X \cup Y \in \F\)</span>.
Let us define Streett objectives as the subclass of Muller objectives given by <span class="math notranslate nohighlight">\(\F\)</span> closed under union.
The following purely combinatorial lemma gives a nice characterisation of these objectives.</p>
<div class="proof lemma admonition" id="2-lem:characterisation_Streett">
<p class="admonition-title"><span class="caption-number">Lemma 42 </span> (Characterisation of Streett among Muller objectives)</p>
<div class="lemma-content section" id="proof-content">
<p>A collection <span class="math notranslate nohighlight">\(\F \subseteq 2^C\)</span> is closed under union if and only if there exists a set of pairs <span class="math notranslate nohighlight">\((R_i,G_i)_{i \in [1,d]}\)</span>
with <span class="math notranslate nohighlight">\(R_i,G_i \subseteq C\)</span> such that <span class="math notranslate nohighlight">\(X \in \F\)</span> is equivalent to for all <span class="math notranslate nohighlight">\(i \in [1,d]\)</span>,
if <span class="math notranslate nohighlight">\(X \cap R_i \neq \emptyset\)</span> then <span class="math notranslate nohighlight">\(X \cap G_i \neq \emptyset\)</span>.</p>
</div>
</div><p>We will see in Section <a class="reference internal" href="zielonka.html#sec-zielonka"><span class="std std-ref">Zielonka tree</span></a> a natural and optimised way to construct these pairs using the Zielonka tree.
In the meantime let us give a direct proof of this result.</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Let <span class="math notranslate nohighlight">\(\F\)</span> closed under union.
We note that for any <span class="math notranslate nohighlight">\(S \notin \F\)</span>, either no subsets of <span class="math notranslate nohighlight">\(S\)</span> are in <span class="math notranslate nohighlight">\(\F\)</span> or there exists a maximal subset <span class="math notranslate nohighlight">\(S'\)</span> of <span class="math notranslate nohighlight">\(S\)</span> in <span class="math notranslate nohighlight">\(\F\)</span>:
indeed it is the union of all subsets of <span class="math notranslate nohighlight">\(S\)</span> in <span class="math notranslate nohighlight">\(\F\)</span>.
It directly follows that for a subset <span class="math notranslate nohighlight">\(X\)</span> we have the following equivalence:
<span class="math notranslate nohighlight">\(X \in \F\)</span> if and only if for any <span class="math notranslate nohighlight">\(S \notin \F\)</span>, if <span class="math notranslate nohighlight">\(X \subseteq S\)</span> then <span class="math notranslate nohighlight">\(X \subseteq S'\)</span>.
This is rewritten equivalently as: if <span class="math notranslate nohighlight">\(X \cap (C \setminus S') \neq \emptyset\)</span> then <span class="math notranslate nohighlight">\(X \cap (C \setminus S) \neq \emptyset\)</span>.
Hence a suitable set of pairs satisfying the required property is
<span class="math notranslate nohighlight">\(\set{(C \setminus S', C \setminus S) : S \notin \F}\)</span>.</p>
</div>
<p>Thanks to this lemma we can give a direct alternative definition of Streett objectives.
There is a parameter <span class="math notranslate nohighlight">\(d\)</span> controlling the number of pairs.
The set of colours is <span class="math notranslate nohighlight">\(C = \set{G_1,R_1,\dots,G_d,R_d}\)</span> and</p>
<div class="math notranslate nohighlight">
\[
\Streett = \set{ \rho \in C^\omega : \forall i \in [1,d],\ R_i \in \Inf(\rho) \implies G_i \in \Inf(\rho) }.
\]</div>
<p>It is customary to call <span class="math notranslate nohighlight">\(R_i\)</span> the <span class="math notranslate nohighlight">\(i\)</span>th request and <span class="math notranslate nohighlight">\(G_i\)</span> the corresponding response;
with this terminology the Streett objective requires that every request made infinitely many times must be responded to infinitely many times.</p>
<p>The Rabin objectives are the complement of the Streett objectives:</p>
<div class="math notranslate nohighlight">
\[
\Rabin = \set{ \rho \in C^\omega : \exists i \in [1,d],\ R_i \in \Inf(\rho) \wedge G_i \notin \Inf(\rho) }.
\]</div>
<div class="section" id="mcnaughton-algorithm-an-exponential-time-algorithm-for-muller-games">
<h2>McNaughton algorithm: an exponential time algorithm for Muller games<a class="headerlink" href="#mcnaughton-algorithm-an-exponential-time-algorithm-for-muller-games" title="Permalink to this headline">Â¶</a></h2>
<div class="proof theorem admonition" id="2-thm:muller">
<p class="admonition-title"><span class="caption-number">Theorem 43 </span> (Finite memory determinacy and complexity for Muller games)</p>
<div class="theorem-content section" id="proof-content">
<p>Muller objectives are determined with finite memory strategies of size <span class="math notranslate nohighlight">\(d!\)</span>.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>See \cref{2-rmk:finite_infinite} for the case of infinite games.</p>
</div>
<p>There exists an algorithm for computing the winning regions of Muller games in exponential time,
and more specifically of complexity <span class="math notranslate nohighlight">\(O(m d (dn)^d)\)</span>, and in polynomial space, and more specifically <span class="math notranslate nohighlight">\(O(dm)\)</span>.</p>
</div>
</div><p>The presentation of the recursive algorithm for computing the winning regions of Muller games follows the exact same lines as for parity games:
indeed, the Muller objective extends the parity objective, and specialising the algorithm for Muller games to parity games
yields the algorithm we presented above.%The finite memory determinacy actually holds for infinite games and the proof we present can be adapted to obtain this result.</p>
<p>The following lemma induces the recursive algorithm for computing the winning regions of Muller games.</p>
<div class="proof lemma admonition" id="2-lem:Muller_even">
<p class="admonition-title"><span class="caption-number">Lemma 44 </span> (Fixed point characterisation of the winning regions for Muller games)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a Muller game such that <span class="math notranslate nohighlight">\(C \in \F\)</span>.
For each <span class="math notranslate nohighlight">\(c \in C\)</span>, let <span class="math notranslate nohighlight">\(\Game_c\)</span> be the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrE(c)\)</span>.</p>
<ul class="simple">
<li><p>If for all <span class="math notranslate nohighlight">\(c \in C\)</span>, we have <span class="math notranslate nohighlight">\(\WA(\Game_c) = \emptyset\)</span>, then <span class="math notranslate nohighlight">\(\WE(\Game) = V\)</span>.</p></li>
<li><p>If there exists <span class="math notranslate nohighlight">\(c \in C\)</span> such that <span class="math notranslate nohighlight">\(\WA(\Game_c) \neq \emptyset\)</span>,
let <span class="math notranslate nohighlight">\(\Game'\)</span> be the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrA( \WA(\Game_c) )\)</span>,
then <span class="math notranslate nohighlight">\(\WE(\Game) = \WE(\Game')\)</span>.</p></li>
</ul>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We prove the first item.</p>
<p>For each <span class="math notranslate nohighlight">\(c \in C\)</span>, let <span class="math notranslate nohighlight">\(\sigma_c\)</span> be an attractor strategy ensuring to reach <span class="math notranslate nohighlight">\(c\)</span> from <span class="math notranslate nohighlight">\(\AttrE(c)\)</span>,
and consider a winning strategy for Eve from <span class="math notranslate nohighlight">\(V \setminus \AttrE(c)\)</span> in <span class="math notranslate nohighlight">\(\Game_c\)</span>, it induces a strategy <span class="math notranslate nohighlight">\(\sigma'_c\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
We construct a strategy <span class="math notranslate nohighlight">\(\sigma\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span> which will simulate the strategies above in turn; to do so it uses <span class="math notranslate nohighlight">\(C\)</span> as top-level memory states.
(We note that the strategies <span class="math notranslate nohighlight">\(\sigma'_c\)</span> may use memory as well, so <span class="math notranslate nohighlight">\(\sigma\)</span> may actually use more memory than just <span class="math notranslate nohighlight">\(C\)</span>.)
The strategy <span class="math notranslate nohighlight">\(\sigma\)</span> with memory <span class="math notranslate nohighlight">\(c\)</span> simulates <span class="math notranslate nohighlight">\(\sigma_c\)</span> from <span class="math notranslate nohighlight">\(\AttrE(c)\)</span> and <span class="math notranslate nohighlight">\(\sigma'_c\)</span> from <span class="math notranslate nohighlight">\(V \setminus \AttrE(c)\)</span>,
and if it ever reaches <span class="math notranslate nohighlight">\(c\)</span> it updates its memory state to <span class="math notranslate nohighlight">\(c + 1\)</span> and <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(c = d\)</span>.
Any play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> either updates its memory state infinitely many times,
or eventually remains in <span class="math notranslate nohighlight">\(V \setminus \AttrE(c)\)</span> and is eventually consistent with <span class="math notranslate nohighlight">\(\sigma'_c\)</span>.
In the first case it sees each colour infinitely many times, and since <span class="math notranslate nohighlight">\(C \in \F\)</span> the play satisfies <span class="math notranslate nohighlight">\(\Muller(\F)\)</span>,
and in the other case since <span class="math notranslate nohighlight">\(\sigma'_c\)</span> is winning the play satisfies <span class="math notranslate nohighlight">\(\Muller(\F)\)</span>.
Thus <span class="math notranslate nohighlight">\(\sigma\)</span> is winning from <span class="math notranslate nohighlight">\(V\)</span>.</p>
<p>We now look at the second item.</p>
<p>Let <span class="math notranslate nohighlight">\(\tau_a\)</span> denote an attractor strategy from <span class="math notranslate nohighlight">\(\AttrA(\WA(\Game_c)) \setminus \WA(\Game_c)\)</span>.
Consider a winning strategy for Adam from <span class="math notranslate nohighlight">\(\WA(\Game_c)\)</span> in <span class="math notranslate nohighlight">\(\Game_c\)</span>, it induces a strategy <span class="math notranslate nohighlight">\(\tau_c\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
Since <span class="math notranslate nohighlight">\(V \setminus \AttrE(c)\)</span> is a trap for Eve, this implies that <span class="math notranslate nohighlight">\(\tau_c\)</span> is a winning strategy in <span class="math notranslate nohighlight">\(\Game\)</span>.
Consider now a winning strategy in the game <span class="math notranslate nohighlight">\(\Game'\)</span> from <span class="math notranslate nohighlight">\(\WA(\Game')\)</span>, it induces a strategy <span class="math notranslate nohighlight">\(\tau'\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
The set <span class="math notranslate nohighlight">\(V \setminus \AttrA( \WA(\Game_c) )\)</span> may not be a trap for Eve, so we cannot conclude that <span class="math notranslate nohighlight">\(\tau'\)</span> is a winning strategy in <span class="math notranslate nohighlight">\(\Game\)</span>,
and it indeed may not be.
We construct a strategy <span class="math notranslate nohighlight">\(\tau\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span> as the (disjoint) union of the strategy <span class="math notranslate nohighlight">\(\tau_a\)</span> on <span class="math notranslate nohighlight">\(\AttrA(\WA(\Game_c)) \setminus \WA(\Game_c)\)</span>,
the strategy <span class="math notranslate nohighlight">\(\tau_c\)</span> on <span class="math notranslate nohighlight">\(\WA(\Game_c)\)</span> and the strategy <span class="math notranslate nohighlight">\(\tau'\)</span> on <span class="math notranslate nohighlight">\(\WA(\Game')\)</span>.
We argue that <span class="math notranslate nohighlight">\(\tau\)</span> is winning from <span class="math notranslate nohighlight">\(\AttrA( \WA(\Game_c) ) \cup \WA(\Game')\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
Indeed, any play consistent with this strategy in <span class="math notranslate nohighlight">\(\Game\)</span> either stays forever in <span class="math notranslate nohighlight">\(\WA(\Game')\)</span> hence is consistent with <span class="math notranslate nohighlight">\(\tau'\)</span>
or enters <span class="math notranslate nohighlight">\(\AttrA( \WA(\Game_c) )\)</span>, so it is eventually consistent with <span class="math notranslate nohighlight">\(\tau_c\)</span>.
In both cases this implies that the play is winning.
Thus we have proved that <span class="math notranslate nohighlight">\(\AttrA( \WA(\Game_c) ) \cup \WA(\Game') \subseteq \WA(\Game)\)</span>.</p>
<p>We now show that <span class="math notranslate nohighlight">\(\WE(\Game') \subseteq \WE(\Game)\)</span>, which implies the converse inclusion.
Consider a winning strategy from <span class="math notranslate nohighlight">\(\WE(\Game')\)</span> in <span class="math notranslate nohighlight">\(\Game'\)</span>, it induces a strategy <span class="math notranslate nohighlight">\(\sigma\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
Since <span class="math notranslate nohighlight">\(\Game'\)</span> is a trap for Adam, any play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> stays forever in <span class="math notranslate nohighlight">\(\WE(\Game')\)</span>,
implying that <span class="math notranslate nohighlight">\(\sigma\)</span> is winning from <span class="math notranslate nohighlight">\(\WE(\Game')\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.</p>
</div>
<p>To get the full algorithm we need the analogous lemma for the case where <span class="math notranslate nohighlight">\(C \notin \F\)</span>.
We do not prove it as it is the exact dual of the previous lemma, and the proof is the same swapping the two players.</p>
<div class="proof lemma admonition" id="2-lem:Muller_odd">
<p class="admonition-title"><span class="caption-number">Lemma 45 </span> (Dual fixed point characterisation of the winning regions for Muller games)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a Muller game such that <span class="math notranslate nohighlight">\(C \notin \F\)</span>.
For each <span class="math notranslate nohighlight">\(c \in C\)</span>, let <span class="math notranslate nohighlight">\(\Game_c\)</span> be the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrA(c)\)</span>.</p>
<ul class="simple">
<li><p>If for all <span class="math notranslate nohighlight">\(c \in C\)</span>, we have <span class="math notranslate nohighlight">\(\WE(\Game_c) = \emptyset\)</span>, then <span class="math notranslate nohighlight">\(\WA(\Game) = V\)</span>.</p></li>
<li><p>If there exists <span class="math notranslate nohighlight">\(c \in C\)</span> such that <span class="math notranslate nohighlight">\(\WE(\Game_c) \neq \emptyset\)</span>,
let <span class="math notranslate nohighlight">\(\Game'\)</span> be the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrE( \WE(\Game_c) )\)</span>,
then <span class="math notranslate nohighlight">\(\WA(\Game) = \WA(\Game')\)</span>.</p></li>
</ul>
</div>
</div><p>The algorithm is presented in pseudocode in <a class="reference internal" href="#algo-mcnaughton"><span class="std std-numref">Fig. 12</span></a>.
We only give the case where <span class="math notranslate nohighlight">\(C \in \F\)</span>, the other case being symmetric.
The base case is when there is only one colour <span class="math notranslate nohighlight">\(c\)</span>, in wich case Eve wins everywhere if <span class="math notranslate nohighlight">\(\F = \set{c}\)</span>
and Adam wins everywhere if <span class="math notranslate nohighlight">\(\F = \emptyset\)</span>.</p>
<p>We now perform a complexity analysis of the algorithm.</p>
<p>Let us start with time complexity and write <span class="math notranslate nohighlight">\(f(n,d)\)</span> for the number of recursive calls performed by the algorithm on Muller games with <span class="math notranslate nohighlight">\(n\)</span> vertices and <span class="math notranslate nohighlight">\(d\)</span> colours.
We have <span class="math notranslate nohighlight">\(f(n,1) = f(0,d) = 0\)</span>, with the general induction:</p>
<div class="math notranslate nohighlight">
\[
f(n,d) \le d \cdot f(n,d-1) + f(n-1,d) + d + 1.
\]</div>
<p>The term <span class="math notranslate nohighlight">\(d \cdot f(n,d-1)\)</span> corresponds to the recursive call to <span class="math notranslate nohighlight">\(\Game_c\)</span> for each <span class="math notranslate nohighlight">\(c \in C\)</span>,
the term <span class="math notranslate nohighlight">\(f(n-1,d)\)</span> to the recursive call to <span class="math notranslate nohighlight">\(\Game'\)</span>.
We obtain <span class="math notranslate nohighlight">\(f(n,d) \le d n \cdot f(n,d-1) + (d+1)n\)</span>,
so <span class="math notranslate nohighlight">\(f(n,d) \le (d+1)n (1 + dn + (dn)^2 + \dots + (dn)^{d-2}) = O((dn)^d)\)</span>.
In each recursive call we perform <span class="math notranslate nohighlight">\(d+1\)</span> attractor computations so the number of operations in one recursive call is <span class="math notranslate nohighlight">\(O(dm)\)</span>.
Thus the overall time complexity is <span class="math notranslate nohighlight">\(O(m d (dn)^d)\)</span>.</p>
<p>The proofs of  <a class="reference internal" href="#2-lem:Muller_even">Lemma 44</a> and  <a class="reference internal" href="#2-lem:Muller_odd">Lemma 45</a> also imply that Muller games are determined with finite memory of size <span class="math notranslate nohighlight">\(d!\)</span>.
We do not make it more precise here because an improved analysis of the memory requirements will be conducted in Section <a class="reference internal" href="zielonka.html#sec-zielonka"><span class="std std-ref">Zielonka tree</span></a>
using a variant of this algorithm.</p>
<div class="figure align-center" id="algo-mcnaughton">
<img alt="../_images/2-algo:mcnaughton.png" src="../_images/2-algo:mcnaughton.png" />
<p class="caption"><span class="caption-number">Fig. 12 </span><span class="caption-text">A recursive algorithm for computing the winning regions of Muller games.</span><a class="headerlink" href="#algo-mcnaughton" title="Permalink to this image">Â¶</a></p>
</div>
</div>
<div class="section" id="positional-determinacy-for-rabin-games">
<h2>Positional determinacy for Rabin games<a class="headerlink" href="#positional-determinacy-for-rabin-games" title="Permalink to this headline">Â¶</a></h2>
<div class="proof theorem admonition" id="2-thm:Rabin_positional_determinacy">
<p class="admonition-title"><span class="caption-number">Theorem 46 </span> (Positional determinacy for Rabin games)</p>
<div class="theorem-content section" id="proof-content">
<p>Rabin games are uniformly positionally determined.</p>
</div>
</div><p><a class="reference internal" href="#2-thm:Rabin_positional_determinacy">Theorem 46</a> holds for infinite games.
However the proof we give here only applies to finite games and does not easily extend to infinite ones.
A different approach is required to obtain the positionality result for infinite games, see  <a class="reference internal" href="zielonka.html#2-thm:characterisation_Zielonka_tree">Theorem 56</a>.</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We proceed by induction over the following quantity: total outdegree of vertices controlled by Eve minus number of vertices controller by Eve.
Since we assume that every vertex has an outgoing edge, the base case is when each vertex of Eve has only one successor.
In that case Eve has only one strategy and it is positional, so the property holds.</p>
<p>In the inductive step, we consider a Rabin game <span class="math notranslate nohighlight">\(\game\)</span> where Eve has a winning strategy <span class="math notranslate nohighlight">\(\sigma\)</span>.
Let <span class="math notranslate nohighlight">\(v \in \VE\)</span> with at least two successors.
We partition the outgoing edges of <span class="math notranslate nohighlight">\(v\)</span> in two non-empty subsets which we call <span class="math notranslate nohighlight">\(E^v_1\)</span> and <span class="math notranslate nohighlight">\(E^v_2\)</span>.
Let us define two games <span class="math notranslate nohighlight">\(\game_1\)</span> and <span class="math notranslate nohighlight">\(\game_2\)</span>: the game <span class="math notranslate nohighlight">\(\game_1\)</span> is obtained from <span class="math notranslate nohighlight">\(\game\)</span> by removing the edges from <span class="math notranslate nohighlight">\(E^v_2\)</span>, and symmetrically for <span class="math notranslate nohighlight">\(\game_2\)</span>.</p>
<p>We claim that Eve has a winning strategy in either <span class="math notranslate nohighlight">\(\game_1\)</span> or <span class="math notranslate nohighlight">\(\game_2\)</span>.
Let us assume towards contradiction that this is not the case: then there exist <span class="math notranslate nohighlight">\(\tau_1\)</span> and <span class="math notranslate nohighlight">\(\tau_2\)</span> two strategies for Adam
which are winning in <span class="math notranslate nohighlight">\(\game_1\)</span> and <span class="math notranslate nohighlight">\(\game_2\)</span> respectively.
We construct a strategy <span class="math notranslate nohighlight">\(\tau\)</span> for Adam in <span class="math notranslate nohighlight">\(\game\)</span> as follows: it has two modes, <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span>. The initial mode is <span class="math notranslate nohighlight">\(1\)</span>, and the strategy simulates <span class="math notranslate nohighlight">\(\tau_1\)</span> from the mode <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(\tau_2\)</span> from the mode <span class="math notranslate nohighlight">\(2\)</span>. Whenever <span class="math notranslate nohighlight">\(v\)</span> is visited, the mode is adjusted: if the outgoing edge is in <span class="math notranslate nohighlight">\(E^v_1\)</span> then the new mode is <span class="math notranslate nohighlight">\(1\)</span>, otherwise it is <span class="math notranslate nohighlight">\(2\)</span>.
To be more specific: when simulating <span class="math notranslate nohighlight">\(\tau_1\)</span> we play ignoring the parts of the play using mode <span class="math notranslate nohighlight">\(2\)</span>, so removing them yields a play consistent with <span class="math notranslate nohighlight">\(\tau_1\)</span>. The same goes for <span class="math notranslate nohighlight">\(\tau_2\)</span>.</p>
<p>Consider a play <span class="math notranslate nohighlight">\(\play\)</span> consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(\tau\)</span>.
Since <span class="math notranslate nohighlight">\(\sigma\)</span> is winning, the play <span class="math notranslate nohighlight">\(\play\)</span> is winning. It can be decomposed following which mode the play is in:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{ccccccccc}
\text{mode } 1 &amp; \overbrace{v_0 \cdots v}^{\play_1^0} &amp; &amp; 
\overbrace{v \cdots v}^{\play_1^1} &amp; &amp; \ \cdots \\
\text{mode } 2 &amp;&amp; \underbrace{v \cdots v}_{\play_2^0} 
&amp; &amp; \underbrace{v \cdots v}_{\play_2^1} &amp; \ \cdots
\end{array}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\play_1 = \play_1^0 \play_1^1 \cdots\)</span> is consistent with <span class="math notranslate nohighlight">\(\tau_1\)</span> and <span class="math notranslate nohighlight">\(\play_2 = \play_2^0 \play_2^1 \cdots\)</span> is consistent with <span class="math notranslate nohighlight">\(\tau_2\)</span>.
Since <span class="math notranslate nohighlight">\(\tau_1\)</span> and <span class="math notranslate nohighlight">\(\tau_2\)</span> are winning strategies for Adam, <span class="math notranslate nohighlight">\(\play_1\)</span> and <span class="math notranslate nohighlight">\(\play_2\)</span> do not satisfy <span class="math notranslate nohighlight">\(\Rabin\)</span>.</p>
<p>There are two cases: the decomposition is either finite or infinite.
If it is finite we get a contradiction: since <span class="math notranslate nohighlight">\(\play\)</span> is winning and <span class="math notranslate nohighlight">\(\Rabin\)</span> is prefix independent any suffix of <span class="math notranslate nohighlight">\(\play\)</span> is winning as well, contradicting that it is consistent with either <span class="math notranslate nohighlight">\(\tau_1\)</span> or <span class="math notranslate nohighlight">\(\tau_2\)</span> hence cannot be winning.</p>
<p>In the second case to get a contradiction we observe the following property of the Rabin objective:
let <span class="math notranslate nohighlight">\((\rho_1^\ell)_{\ell \in \N}\)</span> and <span class="math notranslate nohighlight">\((\rho_2^\ell)_{\ell \in \N}\)</span> such that:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{lccccccccccc}
&amp; \rho_1 &amp; = &amp; \rho_1^0 &amp; &amp; \rho_1^1 &amp; &amp; \cdots &amp; \rho_1^\ell &amp; &amp; \cdots &amp; \notin \Rabin \\
\text{and} &amp; \rho_2 &amp; = &amp; &amp; \rho_2^0 &amp; &amp; \rho_2^1 &amp; \cdots &amp; &amp; \rho_2^\ell &amp; \cdots &amp; \notin \Rabin, \\ 
\text{then: } &amp; \rho_1 \Join \rho_2 &amp; = &amp; \rho_1^0 &amp; \rho_2^0 &amp; \rho_1^1 &amp; \rho_2^1 &amp; \cdots &amp; \rho_1^\ell &amp; \rho_2^\ell &amp; \cdots &amp; \notin \Rabin.
\end{array}
\end{split}\]</div>
<p>Indeed, since neither <span class="math notranslate nohighlight">\(\rho_1\)</span> nor <span class="math notranslate nohighlight">\(\rho_2\)</span> satisfy <span class="math notranslate nohighlight">\(\Rabin\)</span>, in both for all <span class="math notranslate nohighlight">\(i \in [1,d]\)</span> if <span class="math notranslate nohighlight">\(R_i \in \Inf(\rho)\)</span>, then <span class="math notranslate nohighlight">\(G_i \in \Inf(\rho)\)</span>.
Since <span class="math notranslate nohighlight">\(\Inf(\rho_1~\Join~\rho_2) = \Inf(\rho_1) \cup \Inf(\rho_2)\)</span>, this implies that <span class="math notranslate nohighlight">\(\rho_1 \Join \rho_2\)</span> does not satisfy <span class="math notranslate nohighlight">\(\Rabin\)</span>.</p>
<p>This directly yields a contradiction: neither <span class="math notranslate nohighlight">\(\play_1\)</span> nor <span class="math notranslate nohighlight">\(\play_2\)</span> satisfy <span class="math notranslate nohighlight">\(\Rabin\)</span>, yet their shuffle <span class="math notranslate nohighlight">\(\play\)</span> does.</p>
</div>
<p>The proof of  <a class="reference internal" href="#2-thm:Rabin_positional_determinacy">Theorem 46</a> yields a stronger result: every prefix independent submixing objective is positionally determined over finite arenas, where the submixing property is defined as follows for the objective <span class="math notranslate nohighlight">\(\Omega\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{lccccccccccc}
\text{if} &amp; \rho_1 &amp; = &amp; \rho_1^0 &amp; &amp; \rho_1^1 &amp; &amp; \cdots &amp; \rho_1^\ell &amp; &amp; \cdots &amp; \notin \Omega \\
\text{and} &amp; \rho_2 &amp; = &amp; &amp; \rho_2^0 &amp; &amp; \rho_2^1 &amp; \cdots &amp; &amp; \rho_2^\ell &amp; \cdots &amp; \notin \Omega, \\ 
\text{then: } &amp; \rho_1 \Join \rho_2 &amp; = &amp; \rho_1^0 &amp; \rho_2^0 &amp; \rho_1^1 &amp; \rho_2^1 &amp; \cdots &amp; \rho_1^\ell &amp; \rho_2^\ell &amp; \cdots &amp; \notin \Omega.
\end{array}
\end{split}\]</div>
<div class="proof theorem admonition" id="2-thm:submixing_positional">
<p class="admonition-title"><span class="caption-number">Theorem 47 </span> (Submixing property implies uniform positional determinacy)</p>
<div class="theorem-content section" id="proof-content">
<p>Every prefix independent submixing objective is uniformly positionally determined over finite arenas.</p>
</div>
</div></div>
<div class="section" id="the-complexity-of-solving-rabin-games">
<h2>The complexity of solving Rabin games<a class="headerlink" href="#the-complexity-of-solving-rabin-games" title="Permalink to this headline">Â¶</a></h2>
<div class="proof theorem admonition" id="2-thm:Rabin_complexity">
<p class="admonition-title"><span class="caption-number">Theorem 48 </span> (Complexity of solving Rabin games)</p>
<div class="theorem-content section" id="proof-content">
<p>Solving Rabin games is <span class="math notranslate nohighlight">\(\NP\)</span>-complete.</p>
</div>
</div><p>In order to simplify the reduction for proving <a class="reference internal" href="#2-thm:Rabin_complexity">Theorem 48</a> let us make some remarks about colouring functions.
We defined colouring functions as <span class="math notranslate nohighlight">\(\col : V \to C\)</span>, meaning that we label vertices.
Let us discuss here three more general definitions and how to reduce them to the vertex colouring functions
in the case of Rabin games.</p>
<ul class="simple">
<li><p>Partial colouring functions: <span class="math notranslate nohighlight">\(\col : V \to C \cup \set{\emptyset}\)</span>.</p></li>
</ul>
<p>We introduce a new Rabin pair <span class="math notranslate nohighlight">\((R,G)\)</span> and colour all uncoloured vertices by <span class="math notranslate nohighlight">\(G\)</span>.
The Rabin condition will never be satisfied because of this new addition
since the colour <span class="math notranslate nohighlight">\(R\)</span> does not appear at all in the game.</p>
<ul class="simple">
<li><p>Edge colouring functions: <span class="math notranslate nohighlight">\(\col : E \to C\)</span>.</p></li>
</ul>
<p>We reduce from an edge colouring function to a partial vertex colouring function as illustrated in <a class="reference internal" href="#fig-reduction-edge-colouring"><span class="std std-numref">Fig. 13</span></a>:
we add a dummy vertex for each edge and colour it with the colour of its edge, leaving already existing vertices without colours.</p>
<div class="figure align-center" id="fig-reduction-edge-colouring">
<img alt="../_images/2-fig:reduction_edge_colouring.png" src="../_images/2-fig:reduction_edge_colouring.png" />
<p class="caption"><span class="caption-number">Fig. 13 </span><span class="caption-text">Reduction from edge colouring to partial vertex colouring.</span><a class="headerlink" href="#fig-reduction-edge-colouring" title="Permalink to this image">Â¶</a></p>
</div>
<ul class="simple">
<li><p>Multiset colouring functions: <span class="math notranslate nohighlight">\(\col : V \to 2^C\)</span>.</p></li>
</ul>
<p>We reduce from a multiset colouring function to a vertex colouring function as illustrated in <a class="reference internal" href="#fig-reduction-multiset-colouring"><span class="std std-numref">Fig. 14</span></a>:
for each vertex <span class="math notranslate nohighlight">\(v\)</span> coloured by a set <span class="math notranslate nohighlight">\(S\)</span> we add a dummy vertex for each colour <span class="math notranslate nohighlight">\(c \in S\)</span> and replace <span class="math notranslate nohighlight">\(v\)</span> by the line of dummy vertices.</p>
<div class="figure align-center" id="fig-reduction-multiset-colouring">
<img alt="../_images/2-fig:reduction_multiset_colouring.png" src="../_images/2-fig:reduction_multiset_colouring.png" />
<p class="caption"><span class="caption-number">Fig. 14 </span><span class="caption-text">Reduction from multiset edge colouring to vertex colouring, here for two colours.</span><a class="headerlink" href="#fig-reduction-multiset-colouring" title="Permalink to this image">Â¶</a></p>
</div>
<p>The three reductions described above yield equivalent Rabin games which are at most polynomially larger.
We note that they are not general reductions in the sense that they use properties of the Rabin objecttives.
In the reduction below we use these more general definitions to simplify the presentation.</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>The proof that solving Rabin games is in <span class="math notranslate nohighlight">\(\NP\)</span> follows the same lines as for solving parity games: the algorithm guesses a positional strategy and checks whether it is indeed winning. This requires proving that solving Rabin games where Adam control all vertices can be done in polynomial time, which is indeed true and easy to see so we will not elaborate further on this.</p>
<p>To prove the <span class="math notranslate nohighlight">\(\NP\)</span>-hardness we reduce the satisfiability problem for boolean formulas in conjunctive normal form (<span class="math notranslate nohighlight">\(\SAT\)</span>) to solving Rabin games.</p>
<p>Let <span class="math notranslate nohighlight">\(\Phi\)</span> be a formula in conjunctive normal form with <span class="math notranslate nohighlight">\(n\)</span> variables <span class="math notranslate nohighlight">\(x_1 \ldots x_n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> clauses <span class="math notranslate nohighlight">\(C_1 \dots C_m\)</span>, where each <span class="math notranslate nohighlight">\(C_j\)</span> is of the form <span class="math notranslate nohighlight">\(\ell_{j_1} \vee \ell_{j_2} \vee \ell_{j_3}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\Phi = \bigwedge_{j=1}^m \ell_{j_1} \vee \ell_{j_2} \vee \ell_{j_3}.
\]</div>
<p>A literal <span class="math notranslate nohighlight">\(\ell\)</span> is either a variable <span class="math notranslate nohighlight">\(x\)</span> or its negation <span class="math notranslate nohighlight">\(\bar{x}\)</span>, and we write <span class="math notranslate nohighlight">\(\bar{\ell}\)</span> for the negation of a literal.
The question whether <span class="math notranslate nohighlight">\(\Phi\)</span> is satisfiable reads: does there exist a valuation <span class="math notranslate nohighlight">\(\mathbf{v} : \set{x_1,\dots,x_n} \to \set{0,1}\)</span>
satisfying <span class="math notranslate nohighlight">\(\Phi\)</span>.</p>
<p>We construct a Rabin game <span class="math notranslate nohighlight">\(\game\)</span> with <span class="math notranslate nohighlight">\(m+1\)</span> vertices (one per clause, all controlled by Eve, plus a unique vertex controlled by Adam),
<span class="math notranslate nohighlight">\(4m\)</span> edges (<span class="math notranslate nohighlight">\(4\)</span> per clause), and <span class="math notranslate nohighlight">\(2n\)</span> Rabin pairs (one per literal).
We will show that the formula <span class="math notranslate nohighlight">\(\Phi\)</span> is satisfiable if and only if Eve has a winning strategy in the Rabin game <span class="math notranslate nohighlight">\(\game\)</span>.</p>
<p>We first describe the Rabin condition.
There is a Rabin pair <span class="math notranslate nohighlight">\((R_\ell,G_\ell)\)</span> for each literal <span class="math notranslate nohighlight">\(\ell\)</span>, so the Rabin condition requires that there exists a literal <span class="math notranslate nohighlight">\(\ell\)</span> such that <span class="math notranslate nohighlight">\(R_\ell\)</span> is visited infinitely many times and <span class="math notranslate nohighlight">\(G_\ell\)</span> is not.
Let us now describe the arena.
A play consists in an infinite sequence of rounds, where in each round first Adam chooses a clause and second Eve chooses a literal in this clause.
When Eve chooses a literal <span class="math notranslate nohighlight">\(\ell\)</span> she visits <span class="math notranslate nohighlight">\(R_\ell\)</span> and <span class="math notranslate nohighlight">\(G_{\bar{\ell}}\)</span>.
This completes the description of the Rabin game <span class="math notranslate nohighlight">\(\game\)</span>, it is illustrated in <a class="reference internal" href="#fig-hardness-rabin"><span class="std std-numref">Fig. 15</span></a>.
Let us now prove that this yields a reduction from <span class="math notranslate nohighlight">\(\SAT\)</span> to solving Rabin games.</p>
<p>Let us first assume that <span class="math notranslate nohighlight">\(\Phi\)</span> is satisfiable, and let <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> be a satisfying assignment: there is a literal <span class="math notranslate nohighlight">\(\ell\)</span> in each clause satisfied by <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>.
Let <span class="math notranslate nohighlight">\(\sigma\)</span> be the memoryless strategy choosing such a literal in each clause.
We argue that in any play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> there is at least one litteral <span class="math notranslate nohighlight">\(\ell\)</span> that Eve chooses infinitely many times without ever choosing <span class="math notranslate nohighlight">\(\bar{\ell}\)</span>: this implies that <span class="math notranslate nohighlight">\(R_\ell\)</span> is visited infinitely often and <span class="math notranslate nohighlight">\(G_\ell\)</span> is not.
Indeed, some clause is chosen infinitely many times, so the corresponding literal chosen by Eve is also chosen infinitely many times.
Since all the literals chosen by Eve satisfy the same assignment <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> she does not choose both a literal and its negation, so she never chooses <span class="math notranslate nohighlight">\(\bar{\ell}\)</span>.
It follows that <span class="math notranslate nohighlight">\(\sigma\)</span> is a winning strategy for Eve.</p>
<p>Conversely, let us assume that Eve has a winning strategy.
Thanks to  <a class="reference internal" href="#2-thm:Rabin_positional_determinacy">Theorem 46</a> she has a positional winning strategy <span class="math notranslate nohighlight">\(\sigma\)</span>.
We argue that <span class="math notranslate nohighlight">\(\sigma\)</span> cannot choose some literal <span class="math notranslate nohighlight">\(\ell\)</span> in some clause <span class="math notranslate nohighlight">\(C\)</span> and the literal <span class="math notranslate nohighlight">\(\bar{\ell}\)</span> in another clause <span class="math notranslate nohighlight">\(C'\)</span>.
If this would be the case, consider the strategy of Adam alternating between the two clauses <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(C'\)</span> and play it against <span class="math notranslate nohighlight">\(\sigma\)</span>:
both <span class="math notranslate nohighlight">\(\ell\)</span> and <span class="math notranslate nohighlight">\(\bar{\ell}\)</span> are chosen infinitely many times, and no other literals.
Hence <span class="math notranslate nohighlight">\(R_\ell, G_\ell, R_{\bar{\ell}}\)</span>, and <span class="math notranslate nohighlight">\(G_{\bar{\ell}}\)</span> are all visited infinitely many times,
implying that this play does not satisfy <span class="math notranslate nohighlight">\(\Rabin\)</span>, contradicting that <span class="math notranslate nohighlight">\(\sigma\)</span> is winning.</p>
<p>There exists a valuation <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> which satisfies each literal chosen by Eve, implying that it satisfies <span class="math notranslate nohighlight">\(\Phi\)</span> which is then satisfiable.</p>
</div>
<div class="figure align-center" id="fig-hardness-rabin">
<img alt="../_images/2-fig:hardness_Rabin.png" src="../_images/2-fig:hardness_Rabin.png" />
<p class="caption"><span class="caption-number">Fig. 15 </span><span class="caption-text">The Rabin game for <span class="math notranslate nohighlight">\(\Phi = (x \vee y \vee z) \bigwedge (x \vee \bar{y} \vee \bar{z}) \bigwedge (\bar{x} \vee y \vee \bar{z})\)</span>.</span><a class="headerlink" href="#fig-hardness-rabin" title="Permalink to this image">Â¶</a></p>
</div>
</div>
<div class="section" id="the-complexity-of-solving-muller-games">
<h2>The complexity of solving Muller games<a class="headerlink" href="#the-complexity-of-solving-muller-games" title="Permalink to this headline">Â¶</a></h2>
<div class="proof theorem admonition" id="2-thm:complexity_Muller">
<p class="admonition-title"><span class="caption-number">Theorem 49 </span> (Complexity of solving Muller games)</p>
<div class="theorem-content section" id="proof-content">
<p>Solving Muller games is <span class="math notranslate nohighlight">\(\PSPACE\)</span>-complete.</p>
</div>
</div><p>As for the previous reduction, in the Muller game constructed in the reduction below we label edges rather than vertices,
and some edges have more than one colour.
As for Rabin games this can be reduced to the original definition of colouring functions (labelling vertices with exactly one colour each) with a polynomial increase in size.</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>The <span class="math notranslate nohighlight">\(\PSPACE\)</span> algorithm was constructed in  <a class="reference internal" href="#2-thm:muller">Theorem 43</a>.</p>
<p>To prove the <span class="math notranslate nohighlight">\(\PSPACE\)</span>-hardness we reduce the evaluation of quantified boolean formulas in disjunctive normal form (<span class="math notranslate nohighlight">\(\QBF\)</span>) to solving Muller games.</p>
<p>Let <span class="math notranslate nohighlight">\(\Psi\)</span> be a quantified boolean formula in disjunctive normal form with <span class="math notranslate nohighlight">\(n\)</span> variables <span class="math notranslate nohighlight">\(x_1 \ldots x_n\)</span> and <span class="math notranslate nohighlight">\(m\)</span> clauses <span class="math notranslate nohighlight">\(C_1 \dots C_m\)</span>, where each <span class="math notranslate nohighlight">\(C_j\)</span> is of the form <span class="math notranslate nohighlight">\(\ell_{j_1} \wedge \ell_{j_2} \wedge \ell_{j_3}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\Psi = \exists x_1,\forall x_2,\ldots,\exists x_n,\ \Phi(x_1,\dots,x_n) \text{ and } 
\Phi(x_1,\dots,x_n) = \bigvee_{j=1}^m \ell_{j_1} \wedge \ell_{j_2} \wedge \ell_{j_3}.
\]</div>
<p>We construct a Muller game <span class="math notranslate nohighlight">\(\Game\)</span> with <span class="math notranslate nohighlight">\(m+1\)</span> vertices (one per clause, all controlled by Adam, plus a unique vertex controlled by Eve), <span class="math notranslate nohighlight">\(4m\)</span> edges (<span class="math notranslate nohighlight">\(4\)</span> per clause), and <span class="math notranslate nohighlight">\(2n\)</span> colours (one per literal).
We will show that the formula <span class="math notranslate nohighlight">\(\Psi\)</span> evaluates to true if and only if Eve has a winning strategy in the Muller game <span class="math notranslate nohighlight">\(\Game\)</span>.</p>
<p>We first describe the Muller condition.
The set of colours is the set of literals.
We let <span class="math notranslate nohighlight">\(x\)</span> denote the lowest quantified variable such that <span class="math notranslate nohighlight">\(x\)</span> or <span class="math notranslate nohighlight">\(\bar{x}\)</span> is visited infinitely many times.
The Muller condition requires that:</p>
<ul class="simple">
<li><p>either <span class="math notranslate nohighlight">\(x\)</span> is existential and only one of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(\bar{x}\)</span> is visited infinitely many times,</p></li>
<li><p>or <span class="math notranslate nohighlight">\(x\)</span> is universal and both <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(\bar{x}\)</span> are visited infinitely many times,</p></li>
</ul>
<p>and for all variables <span class="math notranslate nohighlight">\(y\)</span> quantified after <span class="math notranslate nohighlight">\(x\)</span>, both <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(\bar{y}\)</span> are visited infinitely many times.
Formally, let <span class="math notranslate nohighlight">\(S_{&gt; i} = \set{x_q, \bar{x_q} : q &gt; p}\)</span> and:</p>
<div class="math notranslate nohighlight">
\[
\F = \set{ S_{&gt; p},\ \set{x_p} \cup S_{&gt; p},\ \set{\bar{x_p}} \cup S_{&gt; p} : x_p \text{ existential}} \cup \set{ S_{\ge p} : x_p \text{ universal}}.
\]</div>
<p>Note that <span class="math notranslate nohighlight">\(\F\)</span> contains <span class="math notranslate nohighlight">\(O(n)\)</span> elements.</p>
<p>Let us now describe the arena. A play consists in an infinite sequence of rounds, where in each round first Eve chooses
a clause and second Adam chooses a literal <span class="math notranslate nohighlight">\(\ell\)</span> in this clause corresponding to some variable <span class="math notranslate nohighlight">\(x_p\)</span>,
and visits the colour <span class="math notranslate nohighlight">\(\ell\)</span> as well as each colour in <span class="math notranslate nohighlight">\(S_{&gt; p}\)</span>.</p>
<p>The reduction is illustrated in <a class="reference internal" href="#fig-hardness-muller"><span class="std std-numref">Fig. 16</span></a>.
Note that the edges from the vertex controlled by Eve to the other ones do not have a colour,
which does not fit our definitions.
For this reason we introduce a new colour <span class="math notranslate nohighlight">\(c\)</span> and colour all these edges by <span class="math notranslate nohighlight">\(c\)</span>.
We define a new Muller objective by adding <span class="math notranslate nohighlight">\(c\)</span> to each set in <span class="math notranslate nohighlight">\(\F\)</span>:
since every play in the game visit <span class="math notranslate nohighlight">\(c\)</span> infinitely many times, the two games are equivalent.
We note that this construction works for this particular game but not in general.</p>
<p>For a valuation <span class="math notranslate nohighlight">\(\mathbf{v} : \set{x_1,\dots,x_n} \to \set{0,1}\)</span> and <span class="math notranslate nohighlight">\(p \in [1,n]\)</span>,
we write <span class="math notranslate nohighlight">\(\Psi_{\mathbf{v},p}\)</span> for the formula obtained from <span class="math notranslate nohighlight">\(\Psi\)</span> by fixing the variables <span class="math notranslate nohighlight">\(x_1,\dots,x_{p-1}\)</span>
to <span class="math notranslate nohighlight">\(\mathbf{v}(x_1),\dots,\mathbf{v}(x_{p-1})\)</span> and quantifying only over the remaining variables.
Let us say that a valuation <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is <strong>positive</strong> if for every <span class="math notranslate nohighlight">\(p \in [1,n]\)</span>, the formula <span class="math notranslate nohighlight">\(\Psi_{\mathbf{v},p}\)</span> evaluates to true,
and similarly a valuation is <strong>negative</strong> if for every <span class="math notranslate nohighlight">\(p \in [1,n]\)</span>, the formula <span class="math notranslate nohighlight">\(\Psi_{\mathbf{v},p}\)</span> evaluates to false.</p>
<p>Let us first assume that <span class="math notranslate nohighlight">\(\Psi\)</span> evaluates to true.
We construct a winning strategy <span class="math notranslate nohighlight">\(\sigma\)</span> for Eve.
It uses <strong>positive</strong> valuations over the variables <span class="math notranslate nohighlight">\(x_1,\ldots,x_n\)</span> as memory states.
Note that the fact that <span class="math notranslate nohighlight">\(\Psi\)</span> evaluates to true implies that there exists a positive valuation.
Let us choose an arbitrary positive valuation as initial valuation.
We first explain what the strategy <span class="math notranslate nohighlight">\(\sigma\)</span> does and then how to update its memory.</p>
<p>Assume that the current valuation is <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, since it is positive there exists a clause satisfying <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>, the strategy <span class="math notranslate nohighlight">\(\sigma\)</span> chooses such a clause.
Therefore, any literal that Adam chooses is necessarily true under <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>.</p>
<p>The memory is updated as follows:
assume that the current valuation is <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and that Adam chose a literal corresponding to the variable <span class="math notranslate nohighlight">\(x_p\)</span>.
If <span class="math notranslate nohighlight">\(x_p\)</span> is existential the valuation is unchanged.
If <span class="math notranslate nohighlight">\(x_p\)</span> is universal, we construct a new positive valuation as follows.
We swap the value of <span class="math notranslate nohighlight">\(x_p\)</span> in <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and write <span class="math notranslate nohighlight">\(\mathbf{v}[x_p]\)</span> for this new valuation.
Since <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> is positive and <span class="math notranslate nohighlight">\(x_p\)</span> is universally quantified, the formula <span class="math notranslate nohighlight">\(\Psi_{\mathbf{v}[x_p],p+1}\)</span> evaluates to true,
so there exists a positive valuation <span class="math notranslate nohighlight">\(\mathbf{v}_{p+1} : \set{x_{p+1},\dots,x_n} \to \set{0,1}\)</span> for this formula.
The new valuation is defined as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{v}'(x_q) = 
\begin{cases}
\mathbf{v}(x_q) &amp; \text{ if } q &lt; p, \\[.5em]
\overline{\mathbf{v}(x_q)} &amp; \text{ if } q = p, \\
\mathbf{v}_{p+1}(x_q) &amp; \text{ if } q &gt; p,
\end{cases}
\end{split}\]</div>
<p>it is positive by construction.</p>
<p>Let <span class="math notranslate nohighlight">\(\play\)</span> be a play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> and <span class="math notranslate nohighlight">\(x_p\)</span> be the lowest quantified variable chosen infinitely many times by Adam.
First, all colours in <span class="math notranslate nohighlight">\(S_{&gt; p}\)</span> are visited infinitely many times (when visiting <span class="math notranslate nohighlight">\(x\)</span> or <span class="math notranslate nohighlight">\(\bar{x}\)</span>).
Let us look at the sequence <span class="math notranslate nohighlight">\((\mathbf{v}_i(x_p))_{i \in \N}\)</span> where <span class="math notranslate nohighlight">\(\mathbf{v}_i\)</span> is the valuation in the <span class="math notranslate nohighlight">\(i\)</span>th round.
If <span class="math notranslate nohighlight">\(x_p\)</span> is existential, the sequence is ultimately constant as it can only change when a lower quantified variable is visited.
If <span class="math notranslate nohighlight">\(x_p\)</span> is universal, the value changes each time the variable <span class="math notranslate nohighlight">\(x_p\)</span> is chosen.
Since any literal that Adam chooses is necessarily true under the current valuation,
this implies that in both cases <span class="math notranslate nohighlight">\(\play\)</span> satisfies <span class="math notranslate nohighlight">\(\Muller(\F)\)</span>.</p>
<p>For the converse implication we show that if <span class="math notranslate nohighlight">\(\Psi\)</span> evaluates to false, then there exists a winning strategy <span class="math notranslate nohighlight">\(\tau\)</span> for Adam.
The construction is similar but using <strong>negative</strong> valuations.
The memory states are negative valuations. The initial valuation is any negative valuation.
If the current valuation is <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and Eve chose the clause <span class="math notranslate nohighlight">\(C\)</span>, since the valuation is negative <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> does not satisfy <span class="math notranslate nohighlight">\(C\)</span>,
the strategy <span class="math notranslate nohighlight">\(\tau\)</span> chooses a literal in <span class="math notranslate nohighlight">\(C\)</span> witnessing this failure.
The memory is updated as follows: assume that the current valuation is <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and that the strategy <span class="math notranslate nohighlight">\(\tau\)</span> chose a literal corresponding to the variable <span class="math notranslate nohighlight">\(x_p\)</span>.
If <span class="math notranslate nohighlight">\(x_p\)</span> is universal the valuation is unchanged.
If <span class="math notranslate nohighlight">\(x_p\)</span> is existential, we proceed as above to construct another negative valuation where the value of <span class="math notranslate nohighlight">\(x_p\)</span> is swapped.</p>
<p>Let <span class="math notranslate nohighlight">\(\play\)</span> be a play consistent with <span class="math notranslate nohighlight">\(\tau\)</span> and <span class="math notranslate nohighlight">\(x\)</span> be the lowest quantified variable chosen infinitely many times by Adam.
As before, we look at the sequence <span class="math notranslate nohighlight">\((\mathbf{v}_i(x))_{i \in \N}\)</span> where <span class="math notranslate nohighlight">\(\mathbf{v}_i\)</span> is the valuation in the <span class="math notranslate nohighlight">\(i\)</span>th round.
If <span class="math notranslate nohighlight">\(x\)</span> is existential, the value changes each time the variable <span class="math notranslate nohighlight">\(x\)</span> is chosen.
If <span class="math notranslate nohighlight">\(x\)</span> is universal, the sequence is ultimately constant.
Since any literal that Adam chooses is necessarily false under the current valuation,
this implies that in both cases <span class="math notranslate nohighlight">\(\play\)</span> does not satisfy <span class="math notranslate nohighlight">\(\Muller(\F)\)</span>.</p>
</div>
<div class="figure align-center" id="fig-hardness-muller">
<img alt="../_images/2-fig:hardness_Muller.png" src="../_images/2-fig:hardness_Muller.png" />
<p class="caption"><span class="caption-number">Fig. 16 </span><span class="caption-text">The Muller game for <span class="math notranslate nohighlight">\(\Psi = \exists x, \forall y, \exists z, (x \wedge y \wedge z) \bigvee (x \wedge \bar{y} \wedge \bar{z}) \bigvee (\bar{x} \wedge y \wedge \bar{z})\)</span>. For a variable <span class="math notranslate nohighlight">\(v\)</span> we write <span class="math notranslate nohighlight">\(S_{&gt; v}\)</span> for the set of literals corresponding to variables quantified after <span class="math notranslate nohighlight">\(v\)</span>, so for instance <span class="math notranslate nohighlight">\(S_{&gt; x} = \set{y,\bar{y},z,\bar{z}}\)</span>.</span><a class="headerlink" href="#fig-hardness-muller" title="Permalink to this image">Â¶</a></p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./2_Regular"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="parity.html" title="previous page">Parity games</a>
    <a class='right-next' id="next-link" href="zielonka.html" title="next page">Zielonka tree</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>