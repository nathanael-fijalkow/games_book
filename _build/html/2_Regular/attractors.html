
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reachability games &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Büchi games" href="buchi.html" />
    <link rel="prev" title="Regular Games" href="index.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../1_Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Regular Games
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="buchi.html">
     Büchi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../3_Parity/index.html">
   Parity Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Games with Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../5_MDP/index.html">
   Markov Decision Processes
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reachability.html">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="reachability-games">
<span id="sec-attractors"></span><h1>Reachability games<a class="headerlink" href="#reachability-games" title="Permalink to this headline">¶</a></h1>
<div class="math notranslate nohighlight">
\[\newcommand{\F}{\mathcal{F}} 
\newcommand{\LAR}{\mathrm{LAR}}
\newcommand{\Zielonka}{\mathrm{Zielonka}}
\newcommand{\depth}{\mathrm{depth}}
\newcommand{\support}{\mathrm{supp}}
\newcommand{\Eve}{\textrm{Eve}}
\newcommand{\Adam}{\textrm{Adam}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zinfty}{\Z \cup \set{\pm \infty}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rinfty}{\R \cup \set{\pm \infty}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Qinfty}{\Q \cup \set{\pm \infty}}
\newcommand{\argmax}{\textrm{argmax}}
\newcommand{\argmin}{\textrm{argmin}}
\newcommand{\Op}{\mathbb{O}}
\newcommand{\Prob}{\mathbb{P}} \newcommand{\dist}{\mathcal{D}} \newcommand{\Dist}{\dist} \newcommand{\supp}{\textrm{supp}} 
\newcommand{\game}{\mathcal{G}} \renewcommand{\Game}{\game} \newcommand{\arena}{\mathcal{A}} \newcommand{\Arena}{\arena} 
\newcommand{\col}{\textsf{col}} \newcommand{\Col}{\col} 
\newcommand{\mEve}{\mathrm{Eve}}
\newcommand{\mAdam}{\mathrm{Adam}}
\newcommand{\mRandom}{\mathrm{Random}}
\newcommand{\vertices}{V} \newcommand{\VE}{V_\mEve} \newcommand{\VA}{V_\mAdam} \newcommand{\VR}{V_\mRandom} 
\newcommand{\ing}{\textrm{In}}
\newcommand{\Ing}{\ing}
\newcommand{\out}{\textrm{Out}}
\newcommand{\Out}{\out}
\newcommand{\dest}{\Delta} 
\newcommand{\WE}{W_\mEve} \newcommand{\WA}{W_\mAdam} 
\newcommand{\Paths}{\textrm{Paths}} \newcommand{\play}{\pi} \newcommand{\first}{\textrm{first}} \newcommand{\last}{\textrm{last}} 
\newcommand{\mem}{\mathcal{M}} \newcommand{\Mem}{\mem} 
\newcommand{\Pre}{\textrm{Pre}} \newcommand{\PreE}{\textrm{Pre}_\mEve} \newcommand{\PreA}{\textrm{Pre}_\mAdam} \newcommand{\Attr}{\textrm{Attr}} \newcommand{\AttrE}{\textrm{Attr}_\mEve} \newcommand{\AttrA}{\textrm{Attr}_\mAdam} \newcommand{\rank}{\textrm{rank}}
\newcommand{\Win}{\textrm{Win}} 
\newcommand{\Lose}{\textrm{Lose}} 
\newcommand{\Value}{\textrm{val}} 
\newcommand{\ValueE}{\textrm{val}_\mEve} 
\newcommand{\ValueA}{\textrm{val}_\mAdam}
\newcommand{\val}{\Value} 
\newcommand{\Automaton}{\mathbf{A}} 
\newcommand{\Safe}{\mathtt{Safe}}
\newcommand{\Reach}{\mathtt{Reach}} 
\newcommand{\Buchi}{\mathtt{Buchi}} 
\newcommand{\CoBuchi}{\mathtt{CoBuchi}} 
\newcommand{\Parity}{\mathtt{Parity}} 
\newcommand{\Muller}{\mathtt{Muller}} 
\newcommand{\Rabin}{\mathtt{Rabin}} 
\newcommand{\Streett}{\mathtt{Streett}} 
\newcommand{\MeanPayoff}{\mathtt{MeanPayoff}} 
\newcommand{\DiscountedPayoff}{\mathtt{DiscountedPayoff}}
\newcommand{\Energy}{\mathtt{Energy}}
\newcommand{\TotalPayoff}{\mathtt{TotalPayoff}}
\newcommand{\ShortestPath}{\mathtt{ShortestPath}}
\newcommand{\Sup}{\mathtt{Sup}}
\newcommand{\Inf}{\mathtt{Inf}}
\newcommand{\LimSup}{\mathtt{LimSup}}
\newcommand{\LimInf}{\mathtt{LimInf}}
\newcommand{\NL}{\textrm{NL}}
\newcommand{\PTIME}{\textrm{PTIME}}
\newcommand{\NP}{\textrm{NP}}
\newcommand{\UP}{\textrm{UP}}
\newcommand{\coNP}{\textrm{coNP}}
\newcommand{\coUP}{\textrm{coUP}}
\newcommand{\PSPACE}{\textrm{PSPACE}}\]</div>
<p>Recall that the objective <span class="math notranslate nohighlight">\(\Reach\)</span> requires that the colour <span class="math notranslate nohighlight">\(\Win\)</span> appears at least once and
<span class="math notranslate nohighlight">\(\Safe\)</span> requires the the colour <span class="math notranslate nohighlight">\(\Lose\)</span> never appears.
We identify the colour <span class="math notranslate nohighlight">\(\Win\)</span> with <span class="math notranslate nohighlight">\(\col^{-1}(\Win)\)</span> the set of vertices labelled <span class="math notranslate nohighlight">\(\Win\)</span>,
so we write <span class="math notranslate nohighlight">\(v \in \Win\)</span> when <span class="math notranslate nohighlight">\(\col(v) = \Win\)</span>, and similarly for <span class="math notranslate nohighlight">\(\Lose\)</span>.</p>
<div class="proof theorem admonition" id="2-thm:reachability">
<p class="admonition-title"><span class="caption-number">Theorem 33 </span> (Positional determinacy and complexity of reachability games)</p>
<div class="theorem-content section" id="proof-content">
<p>Reachability objectives are uniformly positionally determined for both players.
There exists an algorithm for computing the winning regions of reachability games in linear time and space.
More precisely the time and space complexity are both <span class="math notranslate nohighlight">\(O(m)\)</span>.</p>
</div>
</div><p>The first sentence implies that safety games are also uniformly positionally determined,
and both positional determinacy results hold for infinite games.</p>
<p>The complexity results are stated in the unit cost RAM model with machine word size <span class="math notranslate nohighlight">\(w = \log(m)\)</span> with <span class="math notranslate nohighlight">\(m\)</span> the number of edges.
We refer to Section <a class="reference internal" href="../1_Introduction/computation.html#sec-computation"><span class="std std-ref">Computational models</span></a> for more details about the model, which is in subtle ways different than the Turing model.
The complexity would be slightly different in the Turing model: an additional <span class="math notranslate nohighlight">\(\log(m)\)</span> factor would be incurred for manipulating numbers of order <span class="math notranslate nohighlight">\(m\)</span>, which the unit cost RAM model allows us to conveniently hide.</p>
<p>In the litterature the complexity <span class="math notranslate nohighlight">\(O(n + m)\)</span> is often reported for solving reachability games.
Since we make the assumption that every vertex has an outgoing edge this implies that <span class="math notranslate nohighlight">\(n \le m\)</span>, so <span class="math notranslate nohighlight">\(O(n + m) = O(m)\)</span>.</p>
<p>Towards proving  <a class="reference internal" href="#2-thm:reachability">Theorem 33</a> let us introduce some notations.
Let us consider a reachability game <span class="math notranslate nohighlight">\(\Game = (\arena, \Reach[\col])\)</span>.
For a subset <span class="math notranslate nohighlight">\(F \subseteq V\)</span>, we let <span class="math notranslate nohighlight">\(\PreE(F) \subseteq V\)</span> the set of vertices from which Eve can ensure
that the next vertex is in <span class="math notranslate nohighlight">\(F\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{lll}
\PreE(F) &amp; = &amp; \set{v \in V_E : \exists (v,v') \in E,\ v' \in F} \\
        &amp; \cup &amp; \set{v \in V_A : \forall (v,v') \in E,\ v' \in F}.
\end{array}
\end{split}\]</div>
<p>Let us define the following operator on subsets of vertices:</p>
<div class="math notranslate nohighlight">
\[
X \mapsto \Win \cup \PreE(X).
\]</div>
<p>We note that this operator is monotonic when equipping the powerset of vertices with the inclusion preorder:
if <span class="math notranslate nohighlight">\(F \subseteq F'\)</span> then <span class="math notranslate nohighlight">\(\PreE(F) \subseteq \PreE(F')\)</span>.
Hence  <a class="reference internal" href="../1_Introduction/fixed_points.html#1-thm:kleene">Theorem 24</a> applies: this operator has a least fixed point
which we call the attractor of <span class="math notranslate nohighlight">\(\Win\)</span> for Eve and write <span class="math notranslate nohighlight">\(\AttrE(\Win)\)</span>,
and it is computed by the following sequence: we let <span class="math notranslate nohighlight">\(\AttrE^0(\Win) = \Win\)</span> and</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>For technical convenience we shift the sequence by one, ignoring the first term which is the empty set```</p>
<div class="math notranslate nohighlight">
\[
\AttrE^{k+1}(\Win) = \AttrE^{k}(\Win)\ \cup\ \PreE(\AttrE^{k}(\Win)).
\]</div>
<p>This constructs a sequence <span class="math notranslate nohighlight">\((\AttrE^{k}(\Win))_{k \in \N}\)</span> of non-decreasing subsets of <span class="math notranslate nohighlight">\(V\)</span>.
If the game is finite and <span class="math notranslate nohighlight">\(n\)</span> is the number of vertices,
the sequence stabilises after at most <span class="math notranslate nohighlight">\(n-1\)</span> steps, <strong>i.e.</strong> <span class="math notranslate nohighlight">\(\AttrE^{n-1}(\Win) = \AttrE^{n}(\Win) = \AttrE(\Win)\)</span>.</p>
<p>Let us drop the finiteness assumption: if the game is infinite but has finite outdegree, meaning that for any vertex there is a finite number of outgoing edges, then the operator above preserves suprema so thanks to  <a class="reference internal" href="../1_Introduction/fixed_points.html#1-thm:kleene">Theorem 24</a>
we have <span class="math notranslate nohighlight">\(\AttrE(\Win) = \bigcup_{k \in \N} \AttrE^k(\Win)\)</span>.
In full generality the operator does not preserve suprema and the use of ordinals is necessary:
we define the sequence <span class="math notranslate nohighlight">\((\AttrE^{\alpha}(\Win))\)</span> indexed by ordinals up to the cardinal of <span class="math notranslate nohighlight">\(\Game\)</span>,
the case of a limit ordinal <span class="math notranslate nohighlight">\(\alpha\)</span> being <span class="math notranslate nohighlight">\(\AttrE^{\alpha}(\Win) = \bigcup_{\beta &lt; \alpha} \AttrE^{\beta}(\Win)\)</span>.
We then show that <span class="math notranslate nohighlight">\(\AttrE(\Win)\)</span> is the union of all elements in this sequence.</p>
<p>We do not elaborate further this most general case but note that the overhead is mostly technical, the proof below of  <a class="reference internal" href="#2-lem:reachability">Lemma 34</a> can be adapted with little changes using a transfinite induction.</p>
<p>The following lemma shows how the attractor yields a solution to reachability games and directly implies  <a class="reference internal" href="#2-thm:reachability">Theorem 33</a>.</p>
<div class="proof lemma admonition" id="2-lem:reachability">
<p class="admonition-title"><span class="caption-number">Lemma 34 </span> (Characterisation of the winning region of reachability games using attractors)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\game\)</span> a reachability game.
Then <span class="math notranslate nohighlight">\(\WE(\game) = \AttrE(\Win)\)</span>, and:</p>
<ul class="simple">
<li><p>there exists a uniform positional strategy <span class="math notranslate nohighlight">\(\sigma\)</span> for Eve called the attractor strategy defined on <span class="math notranslate nohighlight">\(\AttrE(\Win) \setminus \Win\)</span>
which ensures <span class="math notranslate nohighlight">\(\Reach[\Win]\)</span> from any vertex in <span class="math notranslate nohighlight">\(\AttrE(\Win)\)</span>,
with the property that for any <span class="math notranslate nohighlight">\(k \in \N\)</span> all plays consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> from <span class="math notranslate nohighlight">\(\AttrE^{k}(\Win)\)</span> reach <span class="math notranslate nohighlight">\(\Win\)</span> within <span class="math notranslate nohighlight">\(k\)</span> steps
and remain in <span class="math notranslate nohighlight">\(\AttrE(\Win)\)</span> until doing so;</p></li>
<li><p>there exists a uniform positional strategy <span class="math notranslate nohighlight">\(\tau\)</span> for Adam called the counter-attractor strategy defined on <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win)\)</span>
which ensures <span class="math notranslate nohighlight">\(\Safe[\Win]\)</span> from any vertex in <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win)\)</span>,
with the property that all plays consistent with <span class="math notranslate nohighlight">\(\tau\)</span> remain in <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win)\)</span>.</p></li>
</ul>
</div>
</div></div>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We first show that <span class="math notranslate nohighlight">\(\AttrE(\Win) \subseteq \WE(\game)\)</span>.
For <span class="math notranslate nohighlight">\(v \in \AttrE(\Win)\)</span>, the rank of <span class="math notranslate nohighlight">\(v\)</span> is the smallest <span class="math notranslate nohighlight">\(k \in \N\)</span> such that <span class="math notranslate nohighlight">\(v \in \AttrE^{k}(\Win)\)</span>.
We use the rank to define a positional strategy <span class="math notranslate nohighlight">\(\sigma\)</span> for Eve.
Let <span class="math notranslate nohighlight">\(v \in \VE\)</span> of rank <span class="math notranslate nohighlight">\(k+1\)</span>, then <span class="math notranslate nohighlight">\(v \in \PreE(\AttrE^{k}(\Win))\)</span>,
so there exists <span class="math notranslate nohighlight">\((v,v') \in E\)</span> such that <span class="math notranslate nohighlight">\(v' \in \AttrE^{k}(\Win)\)</span>,
define <span class="math notranslate nohighlight">\(\sigma(v) = (v,v')\)</span>.</p>
<p>We argue that <span class="math notranslate nohighlight">\(\sigma\)</span> ensures <span class="math notranslate nohighlight">\(\Reach[\Win]\)</span>.
By construction in any play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> the rank is either <span class="math notranslate nohighlight">\(0\)</span> or decreases by at least one
at each step.
Since <span class="math notranslate nohighlight">\(\Win\)</span> is the set of vertices of rank <span class="math notranslate nohighlight">\(0\)</span>, any play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> from <span class="math notranslate nohighlight">\(\AttrE(\Win)\)</span> reaches <span class="math notranslate nohighlight">\(\Win\)</span>.</p>
<p>We now show that <span class="math notranslate nohighlight">\(\WE(\game) \subseteq \AttrE(\Win)\)</span>.
For this we actually show</p>
<div class="math notranslate nohighlight">
\[
V \setminus \AttrE(\Win) \subseteq \WA(\game).
\]</div>
<p>Indeed, <span class="math notranslate nohighlight">\(\WA(\game) \subseteq V \setminus \WE(\game)\)</span>, because Eve and Adam cannot have a winning strategy from the same vertex.
This property is clear and holds for any game, it should not be confused with determinacy.</p>
<p>We define a positional strategy <span class="math notranslate nohighlight">\(\tau\)</span> for Adam from <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win)\)</span>.
Let <span class="math notranslate nohighlight">\(v \in \VA\)</span> in <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win)\)</span>, there exists <span class="math notranslate nohighlight">\((v,v') \in E\)</span> such that <span class="math notranslate nohighlight">\(v' \in V \setminus \AttrE(\Win)\)</span>,
define <span class="math notranslate nohighlight">\(\tau(v) = (v,v')\)</span>.
Similarly, if <span class="math notranslate nohighlight">\(v \in \VE\)</span> then for all <span class="math notranslate nohighlight">\((v,v') \in E\)</span> we have <span class="math notranslate nohighlight">\(v' \in V \setminus \AttrE(\Win)\)</span>.
It follows that any play consistent with <span class="math notranslate nohighlight">\(\tau\)</span> remain in <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win)\)</span> and in particular
never reaches <span class="math notranslate nohighlight">\(\Win\)</span>,
in other words <span class="math notranslate nohighlight">\(\tau\)</span> ensures <span class="math notranslate nohighlight">\(\Safe[\Win]\)</span> from <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win)\)</span>.</p>
</div>
<p><a class="reference internal" href="#algo-reachability"><span class="std std-numref">Fig. 8</span></a> is an efficient implementation of the attractor computation.
Let us emphasise that it does not compute the sequence <span class="math notranslate nohighlight">\((\AttrE^k(\Win))_{k \in \N}\)</span> as suggested in  <a class="reference internal" href="#2-lem:reachability">Lemma 34</a>.
In Section <a class="reference internal" href="../4_Payoffs/shortest_path.html#sec-shortest-path"><span class="std std-ref">Shortest path games</span></a> we will generalise this algorithm to a quantitative setting
and construct an algorithm which does compute (as a special case) the sequence <span class="math notranslate nohighlight">\((\AttrE^k(\Win))_{k \in \N}\)</span>,
however with a higher complexity.</p>
<p>We introduce some terminology for analysing the algorithm.
The algorithm uses the set variable <span class="math notranslate nohighlight">\(A\)</span> for the current attractor.
At any point during the execution of the algorithm we say that an edge is <strong>winning</strong> if it has been treated, and <strong>undecisive</strong> otherwise.</p>
<p>The data structure contains the following objects:</p>
<ul class="simple">
<li><p>a set <span class="math notranslate nohighlight">\(A\)</span> of vertices representing the current attractor,</p></li>
<li><p>a set <span class="math notranslate nohighlight">\(S\)</span> of vertices (the order in which vertices are stored and retrieved from <span class="math notranslate nohighlight">\(S\)</span> does not matter),</p></li>
<li><p>for each vertex of Adam a number of edges.</p></li>
</ul>
<p>Recall that we are using the unit cost RAM model, see Section <a class="reference internal" href="../1_Introduction/computation.html#sec-computation"><span class="std std-ref">Computational models</span></a>;
since the machine word size is <span class="math notranslate nohighlight">\(w = \log(m)\)</span>, a number of edges can be stored in one machine word.
Hence the space complexity of the data structure of <span class="math notranslate nohighlight">\(O(n)\)</span>,
which together with the size of the input yields a space complexity <span class="math notranslate nohighlight">\(O(m)\)</span>.</p>
<p>We note that each vertex is added to <span class="math notranslate nohighlight">\(A\)</span> at most once since we check whether it is not already in <span class="math notranslate nohighlight">\(A\)</span> and vertices are never removed from <span class="math notranslate nohighlight">\(A\)</span>.
When we add <span class="math notranslate nohighlight">\(v\)</span> to <span class="math notranslate nohighlight">\(A\)</span> we also add it to <span class="math notranslate nohighlight">\(S\)</span>, so each edge is treated at most once.
This has two consequences: the announced <span class="math notranslate nohighlight">\(O(m)\)</span> time complexity, and the fact that for <span class="math notranslate nohighlight">\(v \in \VA\)</span>,
the value of <span class="math notranslate nohighlight">\(\text{number}\)</span>-<span class="math notranslate nohighlight">\(\text{edges}(v)\)</span> is the number of undecisive outgoing edges of <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>Let us write <span class="math notranslate nohighlight">\(\game_t\)</span> for the game obtained from <span class="math notranslate nohighlight">\(\game\)</span> by removing all winning edges\footnote{We note that in <span class="math notranslate nohighlight">\(\game_t\)</span> some vertices may not have outgoing edges violating the definition of games, but in that case they belong to <span class="math notranslate nohighlight">\(A\)</span>
so this does not affect the reasoning below.}.
The invariant of the algorithm satisfied before each iteration of the repeat loop is the following:</p>
<div class="math notranslate nohighlight">
\[
S \subseteq A \text{ and } \AttrE^\game(\Win) = A \cup \AttrE^{\game_t}(S).
\]</div>
<p>The invariant is satisfied initially because <span class="math notranslate nohighlight">\(A = S = \Win\)</span> and <span class="math notranslate nohighlight">\(\Game_t = \Game\)</span>.
To show that it is preserved by one iteration of the repeat loop, let us assume that we choose and remove <span class="math notranslate nohighlight">\(v'\)</span> from <span class="math notranslate nohighlight">\(S\)</span>.
Let us write <span class="math notranslate nohighlight">\(\game_{\text{before}}\)</span> for the game before considering <span class="math notranslate nohighlight">\(v'\)</span>, and <span class="math notranslate nohighlight">\(\game_{\text{after}}\)</span> for the game after considering <span class="math notranslate nohighlight">\(v'\)</span>:
all incoming edges to <span class="math notranslate nohighlight">\(v'\)</span> have been removed in <span class="math notranslate nohighlight">\(\game_{\text{after}}\)</span>.
The set <span class="math notranslate nohighlight">\(A\)</span> is replaced by <span class="math notranslate nohighlight">\(A' = A \cup \Pre^{\game_{\text{before}}}(v')\)</span>, and the set <span class="math notranslate nohighlight">\(S\)</span> by
<span class="math notranslate nohighlight">\(S' = (S \cup \Pre^{\game_{\text{before}}}(v')) \setminus \set{v'}\)</span>,
so we need to show that <span class="math notranslate nohighlight">\(A' \cup \AttrE^{\game_{\text{after}}}(S') = A \cup \AttrE^{\game_{\text{before}}}(S)\)</span>.
Both inclusions are easily obtained using a case analysis.</p>
<p>The invariant implies the correctness of the algorithm: when <span class="math notranslate nohighlight">\(S\)</span> is empty we obtain that <span class="math notranslate nohighlight">\(A = \AttrE(\Win)\)</span>.</p>
<div class="admonition-remark admonition">
<p class="admonition-title">Remark</p>
<p>We note that in the complexity analysis the cost of manipulating (and in particular decrementing) the counters for the number of edges is constant, which holds in the unit cost RAM model of computation.
The same algorithm analysed in the Turing model of computation would have an additional <span class="math notranslate nohighlight">\(O(\log(n))\)</span> multiplicative factor in the time complexity to take this into account.</p>
</div>
<div class="figure align-center" id="algo-reachability">
<img alt="../_images/2-algo:reachability.png" src="../_images/2-algo:reachability.png" />
<p class="caption"><span class="caption-number">Fig. 8 </span><span class="caption-text">The linear time algorithm for reachability games.</span><a class="headerlink" href="#algo-reachability" title="Permalink to this image">¶</a></p>
</div>
<p>The notion of attractors induces a common way of constructing traps as stated in the following very useful lemma.</p>
<div class="proof lemma admonition" id="2-lem:attractors_trap">
<p class="admonition-title"><span class="caption-number">Lemma 35 </span> (Attractors induce traps)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> a game and <span class="math notranslate nohighlight">\(F \subseteq V\)</span> a subset of edges.
Then <span class="math notranslate nohighlight">\(V \setminus \AttrE(F)\)</span> is a trap for Eve and symmetrically <span class="math notranslate nohighlight">\(V \setminus \AttrA(F)\)</span> is a trap for Adam.</p>
</div>
</div></div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./2_Regular"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="index.html" title="previous page">Regular Games</a>
    <a class='right-next' id="next-link" href="buchi.html" title="next page">Büchi games</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>