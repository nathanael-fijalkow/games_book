
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shortest path games &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Total payoff games" href="total_payoff.html" />
    <link rel="prev" title="Discounted payoff games" href="discounted_payoff.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../1_Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../2_Regular/index.html">
   Regular Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/attractors.html">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/buchi.html">
     Büchi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../3_Parity/index.html">
   Parity Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Games with Payoffs
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../5_MDP/index.html">
   Markov Decision Processes
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reachability.html">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../6_Stochastic/index.html">
   Stochastic Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/determinacy.html">
     Positional determinacy of stochastic reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/relations.html">
     Relations between all games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/algos.html">
     Algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Information
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../7_Concurrent/index.html">
   Concurrent Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/matrix_games.html">
     Matrix games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/reachability.html">
     Concurrent reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/mean_payoff.html">
     Concurrent mean-payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/references.html">
     Bibilographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../8_Imperfect/index.html">
   Games with Signals
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/finite_duration.html">
     Finite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/infinite_duration.html">
     Infinite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Infinite
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../9_Timed/index.html">
   Timed Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/state_space_representation.html">
     State-Space Representation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/controllable_predecessor_operator.html">
     Controllable-Predecessor Operator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/backward_algorithm.html">
     Backward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/forward_algorithm.html">
     Forward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../10_Pushdown/index.html">
   Pushdown Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/profiles.html">
     Profiles and regularity of the winning regions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/parity.html">
     Parity pushdown games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../11_Counters/index.html">
   Games with Counters
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/counters.html">
     Vector games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/dim1.html">
     Games in dimension one
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/avag.html">
     Asymmetric games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/resource.html">
     Resource-conscious games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/complexity.html">
     The complexity of asymmetric monotone games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Multi
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../12_Multiobjectives/index.html">
   Games with multiple objectives
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/mean_payoff_energy.html">
     Mean-payoff and energy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/total_payoff_shortest_path.html">
     Total-payoff and shortest path
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/beyond_worst_case.html">
     Beyond worst-case synthesis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/percentile.html">
     Percentile queries
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../13_Multiplayer/index.html">
   Multiplayer Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/nash_equilibria_normal_form.html">
     Nash Equilibria for games in normal form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/admissible_strategies.html">
     Admissible strategies
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#shortest-path-games-with-non-negative-weights">
   Shortest path games with non-negative weights
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#detection-of-infty-vertices-with-mean-payoff-games">
   Detection of
   <span class="math notranslate nohighlight">
    \(-\infty\)
   </span>
   vertices with mean payoff games
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-pseudopolynomial-time-value-iteration-algorithm">
   A pseudopolynomial time value iteration algorithm
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="shortest-path-games">
<span id="sec-shortest-path"></span><h1>Shortest path games<a class="headerlink" href="#shortest-path-games" title="Permalink to this headline">¶</a></h1>
<p>The quantitative objective <span class="math notranslate nohighlight">\(\mathtt{Sup}\)</span> generalises the qualitative
objective <span class="math notranslate nohighlight">\(\mathtt{Reach}\)</span> by stating numerical preferences on the target.
Another quantitative extension of the reachability objective is to quantify the cost of a path towards the target.
We define the quantitative objective <span class="math notranslate nohighlight">\(\mathtt{ShortestPath}\)</span> over the set of colours <span class="math notranslate nohighlight">\(C =  \mathbb{Z} \cup  \left\{  \textrm{Win \right\}}\)</span> by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
 \mathtt{ShortestPath}(\rho) =
  \begin{cases}
    - \infty &amp; \text{if } \rho_k \neq  \textrm{Win} \text{ for all } k \\
    - \sum_{i = 0}^{k-1} \rho_i &amp; \text{for $k$ the first index such that } \rho_k =  \textrm{Win}.
  \end{cases}
\end{split}\]</div>
<p>Two remarks are in order.</p>
<ul class="simple">
<li><p>Recall that in our definition of quantitative objectives Eve wants to maximise the outcome,
which is why we introduce <span class="math notranslate nohighlight">\(\mathtt{ShortestPath}\)</span> with a minus sign:
we interpret the weights as costs and Eve is trying to reach the target with the smallest possible cost.</p></li>
<li><p>We use the same abusive terminology as for the shortest path graph problem: the cost of a path is the sum of the weights along it
(until the first occurence of <span class="math notranslate nohighlight">\(\textrm{Win}\)</span>) and we are looking for a path of minimal cost, hence not necessarily the shortest in number of edges.</p></li>
</ul>
<p>Solving shortest path games in full generality is not easy; we will come back to it at the end of this chapter using some results obtained along the way.
Let us first illustrate the difficulties, and then solve the special case where the weights are non-negative.
We fix a shortest path game <span class="math notranslate nohighlight">\(\mathcal{G}\)</span>.
Recall that by definition:</p>
<div class="math notranslate nohighlight">
\[
  \textrm{val}(v) = \sup_{\sigma} \inf_{\tau}  \mathtt{ShortestPath}(\pi^v_{\sigma,\tau}).\]</div>
<p>Hence for a vertex <span class="math notranslate nohighlight">\(v\)</span> there are three possibilities:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(val(v) = -\infty\)</span>, meaning that Eve cannot ensure to reach <span class="math notranslate nohighlight">\(\textrm{Win}\)</span> with a finite cost,</p></li>
<li><p><span class="math notranslate nohighlight">\(\textrm{val}(v) \in  \mathbb{Z}\)</span>, meaning that Eve can ensure to reach <span class="math notranslate nohighlight">\(\textrm{Win}\)</span> with a finite cost,</p></li>
<li><p><span class="math notranslate nohighlight">\(\textrm{val}(v) = \infty\)</span>, meaning that Eve can ensure to reach <span class="math notranslate nohighlight">\(\textrm{Win}\)</span> with arbitrarily negative cost.</p></li>
</ul>
<p>As we will see, detecting whether <span class="math notranslate nohighlight">\(\textrm{val}(v) = -\infty\)</span> is easy: this is equivalent to asking whether
<span class="math notranslate nohighlight">\(v \notin  \textrm{Attr}_\mathrm{Eve}( \textrm{Win})\)</span> as stated in <a class="reference internal" href="#4-lem:detecting_minus_infinity">Lemma 129</a>.
The second case where <span class="math notranslate nohighlight">\(\textrm{val}(v) \in  \mathbb{Z}\)</span> will be an occasion to revisit the attractor computation from Section <a class="reference internal" href="../2_Regular/attractors.html#sec-attractors"><span class="std std-ref">Reachability games</span></a>
in a quantitative setting.
Most of the difficulty lies in the third case, where</p>
<div class="proof lemma admonition" id="4-lem:detecting_minus_infinity">
<p class="admonition-title"><span class="caption-number">Lemma 129 </span> (Detection of infinite value)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> a shortest path game and <span class="math notranslate nohighlight">\(v\)</span> a vertex.
Then <span class="math notranslate nohighlight">\(\textrm{val}(v) = -\infty\)</span> if and only if <span class="math notranslate nohighlight">\(v \notin  \textrm{Attr}_\mathrm{Eve}( \textrm{Win})\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>\mynote{TO DO}</p>
</div>
<div class="figure align-center" id="fig-optimal-strategies-shortest-path-game">
<img alt="../_images/1-fig:optimal_strategies_shortest_path_game.png" src="../_images/1-fig:optimal_strategies_shortest_path_game.png" />
<p class="caption"><span class="caption-number">Fig. 41 </span><span class="caption-text">An example of a shortest path game with negative weights Eve does not have an optimal strategy.
Indeed <span class="math notranslate nohighlight">\(\textrm{val}(v_0) = \infty\)</span> since for any <span class="math notranslate nohighlight">\(k\)</span>, Eve has a strategy ensuring that <span class="math notranslate nohighlight">\(\mathtt{ShortestPath}\)</span> is <span class="math notranslate nohighlight">\(k\)</span>
by using <span class="math notranslate nohighlight">\(k\)</span> times the self loop <span class="math notranslate nohighlight">\(-1\)</span> before reaching <span class="math notranslate nohighlight">\(\textrm{Win}\)</span>.
However, if she never reaches <span class="math notranslate nohighlight">\(\textrm{Win}\)</span> the outcome is <span class="math notranslate nohighlight">\(-\infty\)</span>.</span><a class="headerlink" href="#fig-optimal-strategies-shortest-path-game" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="shortest-path-games-with-non-negative-weights">
<h2>Shortest path games with non-negative weights<a class="headerlink" href="#shortest-path-games-with-non-negative-weights" title="Permalink to this headline">¶</a></h2>
<div class="proof theorem admonition" id="4-thm:shortest path-positive">
<p class="admonition-title"><span class="caption-number">Theorem 130 </span> (Positional determinacy and value iteration algorithm)</p>
<div class="theorem-content section" id="proof-content">
<p>Shortest path games with non-negative weights are uniformly positionally determined for both players.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p>This positionality result does not extend to infinite games.</p>
</div>
<p>There exists a value iteration algorithm for computing the value function of these games in polynomial time and space.
\mynote{More precisely},</p>
</div>
</div><p>We rely on the high-level presentation of value iteration algorithms given in Section <a class="reference internal" href="../1_Introduction/value_iteration.html#sec-value-iteration"><span class="std std-ref">Value iteration algorithms</span></a>.</p>
<div class="proof lemma admonition" id="4-lem:optimal_strategies_shortest_path_games">
<p class="admonition-title"><span class="caption-number">Lemma 131 </span> (Optimal strategies)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> be a shortest path game with non-negative weights, then there exists an optimal strategy <span class="math notranslate nohighlight">\(\sigma\)</span> for Eve.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Thanks to the assumption that the weights are positive,
<span class="math notranslate nohighlight">\(\mathtt{ShortestPath}\)</span> takes value in the non-positive integers, in particular is a set of integers bounded from above.
This implies that the supremum is indeed a maximum.</p>
</div>
<p><a class="reference internal" href="#fig-optimal-strategies-shortest-path-game"><span class="std std-numref">Fig. 41</span></a> shows that the assumption that all weights are non-negative
in <a class="reference internal" href="#4-lem:optimal_strategies_shortest_path_games">Lemma 131</a> is necessary.</p>
<p>We consider the complete lattice <span class="math notranslate nohighlight">\(Y = - \mathbb{N} \cup  \left\{ -\infty \right\}\)</span> equipped with the natural order and the function <span class="math notranslate nohighlight">\(\delta : Y \times C \to Y\)</span> defined by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\delta(x, w) = 
\begin{cases}
0 &amp; \text{ if } w =  \textrm{Win} \\
x - w &amp; \text{ if } w \in  \mathbb{N}.
\end{cases}
\end{split}\]</div>
<p>We let <span class="math notranslate nohighlight">\(F_V\)</span> be the lattice of functions <span class="math notranslate nohighlight">\(V \to Y\)</span> equipped with the componentwise order induced by <span class="math notranslate nohighlight">\(Y\)</span>.
Note that <span class="math notranslate nohighlight">\(\delta\)</span> is monotonic, it induces the monotonic operator <span class="math notranslate nohighlight">\(\mathbb{O} : F_V \to F_V\)</span> defined by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
 \mathbb{O}(f)(v) = 
\begin{cases}
\max  \left\{ \delta( f(v'), w) : (v,w,v') \in E \right\} &amp; \text{ if } v \in  V_\mathrm{Eve}, \\
\min  \left\{ \delta( f(v'), w) : (v,w,v') \in E \right\} &amp; \text{ if } v \in  V_\mathrm{Adam}.
\end{cases}
\end{split}\]</div>
<p>Thanks to <a class="reference internal" href="../1_Introduction/fixed_points.html#1-thm:kleene">Theorem 26</a>, the operator <span class="math notranslate nohighlight">\(\mathbb{O}\)</span> has a greatest fixed point which is also the greatest post-fixed point of <span class="math notranslate nohighlight">\(\mathbb{O}\)</span>.
The latter are functions <span class="math notranslate nohighlight">\(f \in F_V\)</span> such that <span class="math notranslate nohighlight">\(f \le  \mathbb{O}(f)\)</span> and called progress measures.</p>
<div class="proof lemma admonition" id="4-lem:SP-greatest-fixed-point">
<p class="admonition-title"><span class="caption-number">Lemma 132 </span> (Greatest fixed point)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> be a shortest path game with non-negative weights, then <span class="math notranslate nohighlight">\(\textrm{val}\)</span> is the greatest fixed point of <span class="math notranslate nohighlight">\(\mathbb{O}\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We show the following two properties:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\textrm{val}\)</span> is a progress measure;</p></li>
<li><p>for every progress measure <span class="math notranslate nohighlight">\(f\)</span> we have <span class="math notranslate nohighlight">\(f \le   \textrm{val}\)</span>.</p></li>
</ul>
<p>Since the greatest fixed point of <span class="math notranslate nohighlight">\(\mathbb{O}\)</span> is also the greatest progress measure, this implies the result.</p>
<p>We show the first item.
Thanks to <a class="reference internal" href="#4-lem:optimal_strategies_shortest_path_games">Lemma 131</a> there exists <span class="math notranslate nohighlight">\(\sigma\)</span> an optimal strategy for Eve.</p>
<p>Consider a vertex <span class="math notranslate nohighlight">\(v\)</span>.
If <span class="math notranslate nohighlight">\(v \in  V_\mathrm{Eve}\)</span> we need to show that</p>
<div class="math notranslate nohighlight">
\[
  \textrm{val}(v) \le \max  \left\{ \delta(  \textrm{val}(v'), w) : (v,w,v') \in E \right\},
\]</div>
<p>and if <span class="math notranslate nohighlight">\(v \in  V_\mathrm{Adam}\)</span> that</p>
<div class="math notranslate nohighlight">
\[
  \textrm{val}(v) \le \min  \left\{ \delta(  \textrm{val}(v'), w) : (v,w,v') \in E \right\}.
\]</div>
<p>Let <span class="math notranslate nohighlight">\((v,w,v') \in E\)</span> a move consistent with <span class="math notranslate nohighlight">\(\sigma\)</span>: if <span class="math notranslate nohighlight">\(v \in  V_\mathrm{Eve}\)</span> then
<span class="math notranslate nohighlight">\(\sigma(v) = (v,w,v')\)</span>, if <span class="math notranslate nohighlight">\(v \in  V_\mathrm{Adam}\)</span> this is any outgoing edge of <span class="math notranslate nohighlight">\(v\)</span>,
we show that <span class="math notranslate nohighlight">\(\textrm{val}(v) \le \delta(  \textrm{val}(v'), w)\)</span> which implies both inequalities.</p>
<p>If <span class="math notranslate nohighlight">\(\textrm{val}(v) = -\infty\)</span> then the inequality holds, so we can assume that <span class="math notranslate nohighlight">\(\textrm{val}(v) \neq -\infty\)</span>.</p>
<p>We distinguish two cases.
If <span class="math notranslate nohighlight">\(w =  \textrm{Win}\)</span> then <span class="math notranslate nohighlight">\(\delta(  \textrm{val}(v'),  \textrm{Win}) = 0\)</span> so the inequality holds.
Otherwise <span class="math notranslate nohighlight">\(w \in  \mathbb{N}\)</span>.
Let us assume towards contradiction that <span class="math notranslate nohighlight">\(\textrm{val}(v) &gt; \delta(  \textrm{val}(v'), w) =   \textrm{val}(v') - w\)</span>.
Let <span class="math notranslate nohighlight">\(\sigma' = \sigma_{\mid (v,w,v')}\)</span> the strategy induced by <span class="math notranslate nohighlight">\(\sigma\)</span> after playing <span class="math notranslate nohighlight">\((v,w,v')\)</span>.
Let <span class="math notranslate nohighlight">\(\pi'\)</span> a play consistent with <span class="math notranslate nohighlight">\(\sigma'\)</span> from <span class="math notranslate nohighlight">\(v'\)</span>.
The play <span class="math notranslate nohighlight">\(\pi = (v,w,v')  \pi'\)</span> is consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> from <span class="math notranslate nohighlight">\(v\)</span> and since <span class="math notranslate nohighlight">\(\sigma\)</span> is optimal
this implies that <span class="math notranslate nohighlight">\(\mathtt{ShortestPath}( \pi) \ge   \textrm{val}(v)\)</span>.
Hence every play consistent with <span class="math notranslate nohighlight">\(\sigma'\)</span> from <span class="math notranslate nohighlight">\(v'\)</span> ensure <span class="math notranslate nohighlight">\(\textrm{val}(v) + w\)</span>, which is strictly greater than <span class="math notranslate nohighlight">\(\textrm{val}(v')\)</span>
contradicting the definition of <span class="math notranslate nohighlight">\(\textrm{val}(v')\)</span>.
Thus the inequality <span class="math notranslate nohighlight">\(\textrm{val}(v) \le \delta(  \textrm{val}(v'), w)\)</span> holds.</p>
<p>We now show the second item.
Let <span class="math notranslate nohighlight">\(f\)</span> be a progress measure, we define a positional strategy <span class="math notranslate nohighlight">\(\sigma\)</span>
by <span class="math notranslate nohighlight">\(\sigma(v) = (v,w,v')\)</span> such that <span class="math notranslate nohighlight">\(f(v) \le \delta(f(v'), w)\)</span>, and show that <span class="math notranslate nohighlight">\(f \le   \textrm{val}\)</span>.
We consider a vertex <span class="math notranslate nohighlight">\(v\)</span> and show that for every play <span class="math notranslate nohighlight">\(\pi\)</span> consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> from <span class="math notranslate nohighlight">\(v\)</span> we have
<span class="math notranslate nohighlight">\(f(v) \le  \mathtt{ShortestPath}( \pi)\)</span>.
This is easily shown for finite plays by induction on the length and then for infinite plays by taking the limit.
This implies that <span class="math notranslate nohighlight">\(f(v) \le   \textrm{val}^\sigma(v) = \inf_\tau  \mathtt{ShortestPath}( \pi^v_{\sigma,\tau})\)</span>,
and then <span class="math notranslate nohighlight">\(f(v) \le \sup_{\sigma}   \textrm{val}^\sigma(v) =   \textrm{val}(v)\)</span>.</p>
</div>
<p>Thanks to <a class="reference internal" href="../1_Introduction/fixed_points.html#1-thm:kleene">Theorem 26</a> <span class="math notranslate nohighlight">\(\textrm{val}\)</span> can be computed by a greatest fixed point algorithm.
To obtain the announced complexity we carefully define the data structure.</p>
<p>The pseudocode is given in <a class="reference internal" href="#algo-value-iteration-shortest-path-non-negative"><span class="std std-numref">Fig. 42</span></a>.</p>
<div class="figure align-center" id="algo-value-iteration-shortest-path-non-negative">
<img alt="../_images/4-algo:value_iteration_shortest_path_non_negative.png" src="../_images/4-algo:value_iteration_shortest_path_non_negative.png" />
<p class="caption"><span class="caption-number">Fig. 42 </span><span class="caption-text">The value iteration algorithm for shortest path games with non-negative weights.</span><a class="headerlink" href="#algo-value-iteration-shortest-path-non-negative" title="Permalink to this image">¶</a></p>
</div>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We follow a similar approach as in Dijkstra’s algorithm, keeping an
estimation <span class="math notranslate nohighlight">\(\ell(v)\in \mathbb{R}\)</span> of the shortest paths towards the target
<span class="math notranslate nohighlight">\(\textrm{Win}\)</span> from vertices <span class="math notranslate nohighlight">\(v\)</span> in a set <span class="math notranslate nohighlight">\(S\)</span>, still to be considered; these
estimations are refined greedily along the computation. We
initialise <span class="math notranslate nohighlight">\(S\)</span> to <span class="math notranslate nohighlight">\(V\)</span>, and all values <span class="math notranslate nohighlight">\(\ell(v)\)</span> to <span class="math notranslate nohighlight">\(+\infty\)</span>, except
for vertices just after an edge of the target <span class="math notranslate nohighlight">\(\textrm{Win}\)</span> that we put at
<span class="math notranslate nohighlight">\(0\)</span>. For vertices <span class="math notranslate nohighlight">\(u\)</span> of Eve, we need more information and thus keep
track of a mapping from successors of <span class="math notranslate nohighlight">\(u\)</span> towards the value
<span class="math notranslate nohighlight">\(\ell(u,v)\in \mathbb{R}\)</span> of the current shortest path from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(\textrm{Win}\)</span>,
going through the edge <span class="math notranslate nohighlight">\((u,v)\)</span>. We have that <span class="math notranslate nohighlight">\(\ell(u)\)</span> is the
maximal value of <span class="math notranslate nohighlight">\(\ell(u,v)\)</span> for all successor vertices <span class="math notranslate nohighlight">\(v\)</span>: in
particular, as long as one of the successors <span class="math notranslate nohighlight">\(v\)</span> still has value
<span class="math notranslate nohighlight">\(\ell(v)=+\infty\)</span>, the value <span class="math notranslate nohighlight">\(\ell(u)\)</span> remains <span class="math notranslate nohighlight">\(+\infty\)</span>.</p>
<p>The algorithm consists in iteratively picking a minimal element <span class="math notranslate nohighlight">\(v\)</span>
of <span class="math notranslate nohighlight">\(S\)</span>, with respect to <span class="math notranslate nohighlight">\(\ell(v)\)</span>, remove it from <span class="math notranslate nohighlight">\(S\)</span>, and update
<span class="math notranslate nohighlight">\(\ell(u)\)</span> for all vertices <span class="math notranslate nohighlight">\(u\)</span> such that <span class="math notranslate nohighlight">\((u,v)\in E\)</span>:</p>
<ul class="simple">
<li><p>if <span class="math notranslate nohighlight">\(u\in  V_\mathrm{Adam}\)</span>, <span class="math notranslate nohighlight">\(\ell(u)\)</span> is updated to <span class="math notranslate nohighlight">\(c(u,v)+\ell(v)\)</span>
whenever the latter value is smaller than <span class="math notranslate nohighlight">\(\ell(u)\)</span>;</p></li>
<li><p>if <span class="math notranslate nohighlight">\(u\in  V_\mathrm{Eve}\)</span>, <span class="math notranslate nohighlight">\(\ell(u,v)\)</span> is updated to <span class="math notranslate nohighlight">\(c(u,v)+\ell(v)\)</span>, and
the value of <span class="math notranslate nohighlight">\(\ell(u)\)</span> is updated accordingly.</p></li>
</ul>
<p>This continues until there are no more vertices in <span class="math notranslate nohighlight">\(S\)</span> after which
we return the values <span class="math notranslate nohighlight">\(\ell(u)\)</span> that we can prove to be the actual
values <span class="math notranslate nohighlight">\(\textrm{val}(u)\)</span> of each vertex <span class="math notranslate nohighlight">\(u\)</span>. Let us denote by <span class="math notranslate nohighlight">\(S_i\)</span> and
<span class="math notranslate nohighlight">\(\ell_i(u)\)</span> the values of <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(\ell(u)\)</span> in iteration <span class="math notranslate nohighlight">\(i\)</span>. We
prove the following invariants:</p>
<ol class="simple">
<li><p>for all iterations <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(\ell_i(u)\)</span> is equal to the value
<span class="math notranslate nohighlight">\(\textrm{val}_{ \mathcal{G}_i}(u)\)</span> in the shortest path game <span class="math notranslate nohighlight">\(\mathcal{G}_i\)</span> obtained
from <span class="math notranslate nohighlight">\(i\)</span> by replacing the cost <span class="math notranslate nohighlight">\(c(v,w)\)</span> of each edge with
<span class="math notranslate nohighlight">\(+\infty\)</span> if both endpoints <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span> are still in <span class="math notranslate nohighlight">\(S_i\)</span>;</p></li>
<li><p>moreover,
<span class="math notranslate nohighlight">\(\min\{\ell_i(v)\mid v\in S_i\}\geq \max\{ \textrm{val}_{ \mathcal{G}}(v)\mid
v\notin S_i\}\)</span> which generalises the greedy property crucial to
the correctness of Dijkstra’s algorithm.</p></li>
</ol>
<p>Since the cost of each edge in <span class="math notranslate nohighlight">\(\mathcal{G}_i\)</span> only decreases along the
various iterations, it is also the case for the values
<span class="math notranslate nohighlight">\(\textrm{val}_{ \mathcal{G}_i}(u)\)</span>. More precisely, the invariant shows that
<span class="math notranslate nohighlight">\(\ell_i(u)= \textrm{val}_{ \mathcal{G}_i}(u)\)</span> for all <span class="math notranslate nohighlight">\(u\in S_i\)</span>, and
<span class="math notranslate nohighlight">\(\ell_i(u)= \textrm{val}_{ \mathcal{G}}(u)\)</span> for all <span class="math notranslate nohighlight">\(u\notin S_i\)</span>. The proofs are
very similar to the usual proofs and can be found in great details
in <span id="id1">[<a class="reference internal" href="references.html#id100"><span>KBB+08</span></a>]</span>.</p>
<p>From a complexity point of view, there is no doubt that the various
computations can be performed in polynomial time. A careful
analysis, using (minimum) Fibonacci heaps, as in Dijkstra’s
algorithm, allows one to obtain an overall complexity
<span class="math notranslate nohighlight">\(O(m+n\log(n))\)</span>.</p>
</div>
</div>
<div class="section" id="detection-of-infty-vertices-with-mean-payoff-games">
<h2>Detection of <span class="math notranslate nohighlight">\(-\infty\)</span> vertices with mean payoff games<a class="headerlink" href="#detection-of-infty-vertices-with-mean-payoff-games" title="Permalink to this headline">¶</a></h2>
<p>However, contrary to the previous payoffs, the <strong>positional</strong>
determinacy result no longer holds as shows the example
in <a class="reference internal" href="#fig-memory"><span class="std std-numref">Fig. 43</span></a>. In this game, there are two positional
strategies for Adam: <span class="math notranslate nohighlight">\(\tau_1(v_1)=(v_1,v_0)\)</span> and
<span class="math notranslate nohighlight">\(\tau_2(v_1)=(v_1,v_2)\)</span>. Strategy <span class="math notranslate nohighlight">\(\tau_1\)</span> does not guarantee Adam to
reach the target, since Eve can play the cycle <span class="math notranslate nohighlight">\((v_1,v_0)\)</span> forever and
obtain payoff <span class="math notranslate nohighlight">\(+\infty\)</span>. Strategy <span class="math notranslate nohighlight">\(\tau_2\)</span> guarantees payoff
<span class="math notranslate nohighlight">\(0\)</span>. However, Adam can play smarter by scaring Eve. Imagine that Adam
plays once to <span class="math notranslate nohighlight">\(v_0\)</span>, and then switches to <span class="math notranslate nohighlight">\(v_2\)</span>: he then guarantees a
value <span class="math notranslate nohighlight">\(-1\)</span>. Doing so one more time, he can guarantee value <span class="math notranslate nohighlight">\(-2\)</span>. And
so on, until he decides to do it <span class="math notranslate nohighlight">\(50\)</span> times, showing to Eve that he is
able to get <span class="math notranslate nohighlight">\(-50\)</span>. Then, the optimal decision for Eve is to go
directly to the target. Therefore, Adam needs memory to play optimally
in this example: his optimal strategy is to go to <span class="math notranslate nohighlight">\(v_0\)</span> the first 50
times the play visits <span class="math notranslate nohighlight">\(v_1\)</span>, and switch to <span class="math notranslate nohighlight">\(v_2\)</span> after the 50th
time. However Eve still has a positional optimal strategy that
consists in always going to <span class="math notranslate nohighlight">\(v_2\)</span>. This is always the case as we
discuss later. Notice that the possible absence of optimal positional
strategies for Adam makes non-trivial an upper bound of the form
<span class="math notranslate nohighlight">\(\textrm{NP}\cap \textrm{coNP}\)</span> in the complexity of solving shortest path games.</p>
<div class="figure align-center" id="fig-memory">
<img alt="../_images/4-fig:memory.png" src="../_images/4-fig:memory.png" />
<p class="caption"><span class="caption-number">Fig. 43 </span><span class="caption-text">A shortest path game, with <span class="math notranslate nohighlight">\(v_2\)</span> being the target vertex,
where Adam needs memory to play optimally</span><a class="headerlink" href="#fig-memory" title="Permalink to this image">¶</a></p>
</div>
<p>Apart from the complication on the memory requirement for Adam to play
optimally, one other technical difficulty arises from the presence of
vertices with optimal value <span class="math notranslate nohighlight">\(-\infty\)</span>: this is the case when Adam may
reach a target of <span class="math notranslate nohighlight">\(\textrm{Win}\)</span> while controlling a negative cycle along the
way. As previously announced, this is closely related with mean payoff
games: <span id="id2">[<a class="reference internal" href="references.html#id90"><span>BGHM17</span></a>]</span></p>
<div class="proof theorem admonition" id="4-thm:-infty-MP">
<p class="admonition-title"><span class="caption-number">Theorem 133 </span> (Detection of infinite values)</p>
<div class="theorem-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> be an arena.</p>
<ul class="simple">
<li><p>If the game <span class="math notranslate nohighlight">\(\mathcal{G}=( \mathcal{A}, \mathtt{ShortestPath}( \textrm{Win}))\)</span> has no
vertices <span class="math notranslate nohighlight">\(v\)</span> of value <span class="math notranslate nohighlight">\(\textrm{val}^ \mathcal{G}(v)=+\infty\)</span>, and the only
outgoing edges of vertices in <span class="math notranslate nohighlight">\(\textrm{Win}\)</span> are self loops of weight <span class="math notranslate nohighlight">\(0\)</span>,
then for all vertices <span class="math notranslate nohighlight">\(v\)</span>, <span class="math notranslate nohighlight">\(\textrm{val}^ \mathcal{G}(v)=-\infty\)</span> if and only
if <span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}'}(v)&lt;0\)</span> if <span class="math notranslate nohighlight">\(\mathcal{G}'=( \mathcal{A}, \mathtt{MeanPayoff})\)</span> is the
associated mean payoff game on the same arena.</p></li>
<li><p>Reciprocally, if <span class="math notranslate nohighlight">\(\mathcal{G}=( \mathcal{A}, \mathtt{MeanPayoff})\)</span>, we can build in
polynomial time a game <span class="math notranslate nohighlight">\(\mathcal{G}'=( \mathcal{A}', \mathtt{ShortestPath}( \textrm{Win}))\)</span> such
that <span class="math notranslate nohighlight">\(\textrm{val}^ \mathcal{G}(v)&lt;0\)</span> if and only if
<span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}'}(v) =-\infty\)</span>.</p></li>
</ul>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>For the first item, if <span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}'}(v)&lt;0\)</span>, there exists a
profile of optimal positional strategies <span class="math notranslate nohighlight">\((\sigma^*,\tau^*)\)</span>: the
outcome starting in <span class="math notranslate nohighlight">\(v\)</span> and following this profile ends up in a loop
with total cost <span class="math notranslate nohighlight">\(&lt;0\)</span>. For every <span class="math notranslate nohighlight">\(M&gt;0\)</span>, we can construct a strategy
<span class="math notranslate nohighlight">\(\tau^M\)</span> for Adam that ensures in <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> a payoff at most <span class="math notranslate nohighlight">\(-M\)</span>,
which then proves that <span class="math notranslate nohighlight">\(\textrm{val}^ \mathcal{G}(v)=-\infty\)</span>: strategy <span class="math notranslate nohighlight">\(\tau^M\)</span>
is obtained by playing strategy <span class="math notranslate nohighlight">\(\tau^*\)</span> until the accumulated cost
is less than <span class="math notranslate nohighlight">\(-M-nW\)</span>, with <span class="math notranslate nohighlight">\(W=\max_{(v,c,v')\in E} |c|\)</span>, after
which he switches to an attractor strategy towards <span class="math notranslate nohighlight">\(\textrm{Win}\)</span> (which
exists from every vertex of the game, since no vertices have value
<span class="math notranslate nohighlight">\(+\infty\)</span>). Since the attractor strategy reaches the target in at
most <span class="math notranslate nohighlight">\(n\)</span> steps, the value of <span class="math notranslate nohighlight">\(\tau^M\)</span> from <span class="math notranslate nohighlight">\(v\)</span> is at most <span class="math notranslate nohighlight">\(-M\)</span>.</p>
<p>Reciprocally, if <span class="math notranslate nohighlight">\(\textrm{val}^ \mathcal{G}(v)=-\infty\)</span>, for <span class="math notranslate nohighlight">\(M=nW\)</span>,
consider a strategy <span class="math notranslate nohighlight">\(\tau^M\)</span> of Adam guaranteeing a payoff less than
<span class="math notranslate nohighlight">\(-M\)</span>. Consider, towards a contradiction, a positional strategy
<span class="math notranslate nohighlight">\(\sigma\)</span> of Eve that secures a non-negative mean payoff. The play of
<span class="math notranslate nohighlight">\(\mathcal{G}\)</span> following the profile <span class="math notranslate nohighlight">\((\sigma,\tau^M)\)</span> necessarily leads to
<span class="math notranslate nohighlight">\(\textrm{Win}\)</span>, while visiting at least one negative cycle, around a given
vertex <span class="math notranslate nohighlight">\(v'\)</span>. If <span class="math notranslate nohighlight">\(v'\in  V_\mathrm{Eve}\)</span>, Eve is not the one choosing to exit the
cycle (since she is following a positional strategy), so Adam can
modify its strategy to stay forever in the negative cycle, which
contradicts the fact that <span class="math notranslate nohighlight">\(\sigma\)</span> secures a non-negative
mean payoff. If <span class="math notranslate nohighlight">\(v'\in  V_\mathrm{Adam}\)</span>, Adam can also choose to stay forever in
the negative cycle by modifying his strategy. Therefore, Eve cannot
have a positional strategy securing a non-negative mean payoff: by
positional determinacy of mean payoff games
(<a class="reference internal" href="mean_payoff.html#4-thm:mean_payoff_positional">Theorem 101</a>), Eve cannot have any strategy securing
a non-negative mean payoff.</p>
<p>For the second item, without loss of generality, suppose
that <span class="math notranslate nohighlight">\(\mathcal{A}\)</span> is a bipartite arena,
i.e. <span class="math notranslate nohighlight">\(E\subseteq  V_\mathrm{Adam}\times  V_\mathrm{Eve}\cup V_\mathrm{Eve}\times  V_\mathrm{Adam}\)</span>. The new arena
<span class="math notranslate nohighlight">\(\mathcal{A}'\)</span> is obtained by adding a fresh target <span class="math notranslate nohighlight">\(v_t\)</span> with edges
<span class="math notranslate nohighlight">\((v,v_t)\)</span> for all <span class="math notranslate nohighlight">\(v\in  V_\mathrm{Adam}\)</span>, as well as an edge <span class="math notranslate nohighlight">\((v_t,v_t)\)</span>, all of
cost 0. Consider the game <span class="math notranslate nohighlight">\(\mathcal{G}'=( \mathcal{A}', \mathtt{ShortestPath}( \textrm{Win}))\)</span>
with <span class="math notranslate nohighlight">\(\textrm{Win} = \{v_t\}\)</span>. By construction and using the bipartite
hypothesis, Adam always has a strategy to reach <span class="math notranslate nohighlight">\(\textrm{Win}\)</span>, so that no
vertices <span class="math notranslate nohighlight">\(v\)</span> have a value <span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}'}(v)=+\infty\)</span>. By letting
<span class="math notranslate nohighlight">\(\mathcal{G}''=( \mathcal{A}', \mathtt{MeanPayoff})\)</span>, the previous item shows that
<span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}'}(v)=-\infty\)</span> if and only if
<span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}''}(v)&lt;0\)</span>. To conclude, it only remains to show that
<span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}}(v)&lt;0\)</span> if and only if <span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}''}(v)&lt;0\)</span>. By
mapping positional strategies from <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> to <span class="math notranslate nohighlight">\(\mathcal{G}''\)</span>, we easily
obtain <span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}''}(v)\leq  \textrm{val}^ \mathcal{G}(v)\)</span>, so the direct
implication holds. For the converse, if <span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}''}(v)&lt;0\)</span>, the
target <span class="math notranslate nohighlight">\(v_t\)</span> cannot be visited by a profile of positional optimal
strategies (otherwise the mean payoff would be 0): projecting the
play from <span class="math notranslate nohighlight">\(\mathcal{G}''\)</span> on <span class="math notranslate nohighlight">\(\mathcal{G}\)</span> therefore shows that
<span class="math notranslate nohighlight">\(\textrm{val}^{ \mathcal{G}}(v)\leq  \textrm{val}^{ \mathcal{G}''}(v) &lt;0\)</span>.</p>
</div>
</div>
<div class="section" id="a-pseudopolynomial-time-value-iteration-algorithm">
<h2>A pseudopolynomial time value iteration algorithm<a class="headerlink" href="#a-pseudopolynomial-time-value-iteration-algorithm" title="Permalink to this headline">¶</a></h2>
<p>As shown above, we can detect vertices of value <span class="math notranslate nohighlight">\(+\infty\)</span> and
<span class="math notranslate nohighlight">\(-\infty\)</span> if needed. We now explain how to compute the exact optimal
value of other vertices, by a value iteration algorithm. Similarly to
the case of mean payoff or discounted games, the algorithm consists in
an iterative search of a fixed point of the operator
<span class="math notranslate nohighlight">\(F\colon  \mathbb{R}^V\to  \mathbb{R}^V\)</span> mapping every vector <span class="math notranslate nohighlight">\(\vec x=(x_v)_{v\in V}\)</span> to
the new vector <span class="math notranslate nohighlight">\((y_v)_{v\in V}\)</span>, defined, for all <span class="math notranslate nohighlight">\(v\in V\)</span>, by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}y_v =
  \begin{cases}
    0 &amp; \text{ if } v\in  \textrm{Win}\\
    \max_{(v,v')\in E} [c(v,v') + x_{v'}] &amp;
    \text{ if } v\in  V_\mathrm{Eve}\setminus  \textrm{Win}\\
    \min_{(v,v')\in E} [c(v,v') + x_{v'}] &amp; \text{ if } v\in
     V_\mathrm{Adam}\setminus  \textrm{Win}
  \end{cases}\end{split}\]</div>
<p>Notice the similarity with respect to the <span class="math notranslate nohighlight">\(\textrm{Lift}\)</span> operator used in the
value iteration algorithm for mean payoff
(<a class="reference internal" href="mean_payoff.html#algo-value-iteration-mp"><span class="std std-numref">Fig. 38</span></a>): the following arguments are thus
very resembling to the ones already presented in the case of
mean payoff. Here, we obtain a more precise information though, since
it directly gives us the values for the shortest path objective
towards a fixed target.</p>
<p>In the presence of vertices of value <span class="math notranslate nohighlight">\(-\infty\)</span>, the iterative fixed
point computation would not terminate. However, thanks to the
following lemma (where we again let <span class="math notranslate nohighlight">\(W=\max_{(v,c,v')\in E} |c|\)</span>), we
know that finite values are bounded below, so that an intermediate
step of speed-up can detect the vertices of value <span class="math notranslate nohighlight">\(-\infty\)</span>.</p>
<div class="proof lemma admonition" id="4-lem:-infty">
<p class="admonition-title"><span class="caption-number">Lemma 134 </span> (Lower bound on values)</p>
<div class="lemma-content section" id="proof-content">
<p>In a shortest path game <span class="math notranslate nohighlight">\(\mathcal{G}\)</span>, all vertices <span class="math notranslate nohighlight">\(v\)</span> with a value
<span class="math notranslate nohighlight">\(\textrm{val}(v)&lt;-(n-1) W\)</span> have value <span class="math notranslate nohighlight">\(\textrm{val}(v)=-\infty\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Consider a strategy <span class="math notranslate nohighlight">\(\tau\)</span> of Adam securing a value <span class="math notranslate nohighlight">\(&lt;-(n-1) W\)</span>
from a given vertex <span class="math notranslate nohighlight">\(v\)</span>. We show that in the mean payoff game
<span class="math notranslate nohighlight">\(\mathcal{G}'\)</span> described in <a class="reference internal" href="#4-thm:-infty-MP">Theorem 133</a>, vertex <span class="math notranslate nohighlight">\(v\)</span> has value
<span class="math notranslate nohighlight">\(&lt;0\)</span>, which allows us to conclude. Let <span class="math notranslate nohighlight">\(\sigma\)</span> be a positional
strategy of Eve. By hypothesis, the play <span class="math notranslate nohighlight">\(\pi\)</span> starting in <span class="math notranslate nohighlight">\(v\)</span> and
following the profile <span class="math notranslate nohighlight">\((\sigma,\tau)\)</span> has a payoff
<span class="math notranslate nohighlight">\(\mathtt{ShortestPath}(\pi)&lt;-(n-1) W\)</span>: therefore, it contains a negative
cycle. As before, Adam can therefore modify its strategy so that he
sticks to the choices he does in the first cycle he visits: this new
strategy is indeed independent of <span class="math notranslate nohighlight">\(\sigma\)</span>, so that the according
strategy indeed secures a negative mean payoff.</p>
</div>
<p>Thus, we let <span class="math notranslate nohighlight">\(G\colon\overline \mathbb{R}^V\to\overline \mathbb{R}^V\)</span> mapping each
vertex <span class="math notranslate nohighlight">\(\vec x = (x_v)_{v\in V}\)</span> to the mapping <span class="math notranslate nohighlight">\((y_v)_{v\in V}\)</span>
defined by <span class="math notranslate nohighlight">\(y_v = x_v\)</span> if <span class="math notranslate nohighlight">\(x_v\geq -(n-1)W\)</span> and <span class="math notranslate nohighlight">\(y_v=-\infty\)</span>
otherwise. We consider then the sequence
<span class="math notranslate nohighlight">\((\vec x^n = (GF)^n(\top))_{n\in  \mathbb{N}}\)</span>, with <span class="math notranslate nohighlight">\(\top\)</span> the vector having
all components equal to <span class="math notranslate nohighlight">\(+\infty\)</span>. Since it generalises the attractor
computation, after <span class="math notranslate nohighlight">\(n\)</span> steps, vertices with a value
<span class="math notranslate nohighlight">\(\textrm{val}(v)&lt;+\infty\)</span> have been discovered: they are the only ones such
that <span class="math notranslate nohighlight">\(x^{n}_v &lt; +\infty\)</span>. Moreover, these vertices satisfy
<span class="math notranslate nohighlight">\(x^{n}_v\leq n W\)</span> since a given path towards the target has been
discovered along the first <span class="math notranslate nohighlight">\(n\)</span> iterations. Since the mapping <span class="math notranslate nohighlight">\(GF\)</span> is
monotonous, the sequence <span class="math notranslate nohighlight">\((\vec x^n)_{n\in  \mathbb{N}}\)</span> is
non-increasing. Since it can only take values in the finite set
<span class="math notranslate nohighlight">\(\{-\infty\}\cup \{-(n-1) W+1, -(n-1) W+2,\ldots,nW\}
\cup\{+\infty\}\)</span>, it is stabilising: there exists a step <span class="math notranslate nohighlight">\(N\)</span> such that
<span class="math notranslate nohighlight">\(\vec x^N=\vec x^{N+1}\)</span>. Notice that an a priori bound on <span class="math notranslate nohighlight">\(N\)</span> is
<span class="math notranslate nohighlight">\((2n-1)W n + n\)</span>. A careful analysis allows one to show that
<span class="math notranslate nohighlight">\(\vec x^N= \textrm{val}^ \mathcal{G}\)</span>: the main argument is the fact that the
stabilisation of the sequence at index <span class="math notranslate nohighlight">\(N\)</span> allows one to show by
induction that <span class="math notranslate nohighlight">\(N\)</span> steps suffice for Adam to guarantee that he has
reached a target vertex while getting the optimal value. With all the
details provided in <span id="id3">[<a class="reference internal" href="references.html#id90"><span>BGHM17</span></a>]</span>, we
finally obtain</p>
<div class="proof theorem admonition" id="4-thm:SP-pseudopoly-algo">
<p class="admonition-title"><span class="caption-number">Theorem 135 </span> (Pseudopolynomial computation of values)</p>
<div class="theorem-content section" id="proof-content">
<p>We can compute in pseudopolynomial time the values of a
shortest path game.</p>
</div>
</div></div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./4_Payoffs"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="discounted_payoff.html" title="previous page">Discounted payoff games</a>
    <a class='right-next' id="next-link" href="total_payoff.html" title="next page">Total payoff games</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>