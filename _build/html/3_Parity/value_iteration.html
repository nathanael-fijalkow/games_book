
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A quasipolynomial time value iteration algorithm &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Comparing the three families of algorithms" href="relationships.html" />
    <link rel="prev" title="A quasipolynomial time separating automata algorithm" href="separation.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../1_Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../2_Regular/index.html">
   Regular Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/attractors.html">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/buchi.html">
     Büchi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Parity Games
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Games with Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../5_MDP/index.html">
   Markov Decision Processes
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reachability.html">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../6_Stochastic/index.html">
   Stochastic Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/determinacy.html">
     Positional determinacy of stochastic reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/relations.html">
     Relations between all games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/algos.html">
     Algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Information
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../7_Concurrent/index.html">
   Concurrent Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/matrix_games.html">
     Matrix games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/reachability.html">
     Concurrent reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/mean_payoff.html">
     Concurrent mean-payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/references.html">
     Bibilographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../8_Imperfect/index.html">
   Games with Signals
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/finite_duration.html">
     Finite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/infinite_duration.html">
     Infinite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Infinite
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../9_Timed/index.html">
   Timed Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/state_space_representation.html">
     State-Space Representation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/controllable_predecessor_operator.html">
     Controllable-Predecessor Operator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/backward_algorithm.html">
     Backward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/forward_algorithm.html">
     Forward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../10_Pushdown/index.html">
   Pushdown Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/profiles.html">
     Profiles and regularity of the winning regions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/parity.html">
     Parity pushdown games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../11_Counters/index.html">
   Games with Counters
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/counters.html">
     Vector games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/dim1.html">
     Games in dimension one
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/avag.html">
     Asymmetric games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/resource.html">
     Resource-conscious games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/complexity.html">
     The complexity of asymmetric monotone games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Multi
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../12_Multiobjectives/index.html">
   Games with multiple objectives
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/mean_payoff_energy.html">
     Mean-payoff and energy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/total_payoff_shortest_path.html">
     Total-payoff and shortest path
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/beyond_worst_case.html">
     Beyond worst-case synthesis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/percentile.html">
     Percentile queries
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../13_Multiplayer/index.html">
   Multiplayer Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/nash_equilibria_normal_form.html">
     Nash Equilibria for games in normal form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/admissible_strategies.html">
     Admissible strategies
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#universal-trees">
   Universal trees
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-quasipolynomial-universal-tree">
   A quasipolynomial universal tree
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#ordering-the-branches">
   Ordering the branches
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#progress-measures">
   Progress measures
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-algorithm">
   The algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#complexity-analysis">
   Complexity analysis
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#data-structure">
   Data structure
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#encoding-branches">
   Encoding branches
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="a-quasipolynomial-time-value-iteration-algorithm">
<span id="sec-value-iteration"></span><h1>A quasipolynomial time value iteration algorithm<a class="headerlink" href="#a-quasipolynomial-time-value-iteration-algorithm" title="Permalink to this headline">¶</a></h1>
<div class="math notranslate nohighlight">
\[\renewcommand{\H}{\mathcal{H}} 
\newcommand{\Lift}{\textrm{Lift}} 
\newcommand{\F}{\mathcal{F}} 
\newcommand{\sinit}{\sigma_{\textnormal{init}}}
\newcommand{\siblank}{\mathtt{-}}
\newcommand{\Eve}{\textrm{Eve}}
\newcommand{\Adam}{\textrm{Adam}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zinfty}{\Z \cup \set{\pm \infty}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rinfty}{\R \cup \set{\pm \infty}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Qinfty}{\Q \cup \set{\pm \infty}}
\newcommand{\argmax}{\textrm{argmax}}
\newcommand{\argmin}{\textrm{argmin}}
\newcommand{\Op}{\mathbb{O}}
\newcommand{\Prob}{\mathbb{P}} \newcommand{\dist}{\mathcal{D}} \newcommand{\Dist}{\dist} \newcommand{\supp}{\textrm{supp}} 
\newcommand{\game}{\mathcal{G}} \renewcommand{\Game}{\game} \newcommand{\arena}{\mathcal{A}} \newcommand{\Arena}{\arena} 
\newcommand{\col}{\textsf{col}} \newcommand{\Col}{\col} 
\newcommand{\mEve}{\mathrm{Eve}}
\newcommand{\mAdam}{\mathrm{Adam}}
\newcommand{\mRandom}{\mathrm{Random}}
\newcommand{\vertices}{V} \newcommand{\VE}{V_\mEve} \newcommand{\VA}{V_\mAdam} \newcommand{\VR}{V_\mRandom} 
\newcommand{\ing}{\textrm{In}}
\newcommand{\Ing}{\ing}
\newcommand{\out}{\textrm{Out}}
\newcommand{\Out}{\out}
\newcommand{\dest}{\Delta} 
\newcommand{\WE}{W_\mEve} \newcommand{\WA}{W_\mAdam} 
\newcommand{\Paths}{\textrm{Paths}} \newcommand{\play}{\pi} \newcommand{\first}{\textrm{first}} \newcommand{\last}{\textrm{last}} 
\newcommand{\mem}{\mathcal{M}} \newcommand{\Mem}{\mem} 
\newcommand{\Pre}{\textrm{Pre}} \newcommand{\PreE}{\textrm{Pre}_\mEve} \newcommand{\PreA}{\textrm{Pre}_\mAdam} \newcommand{\Attr}{\textrm{Attr}} \newcommand{\AttrE}{\textrm{Attr}_\mEve} \newcommand{\AttrA}{\textrm{Attr}_\mAdam} \newcommand{\rank}{\textrm{rank}}
\newcommand{\Win}{\textrm{Win}} 
\newcommand{\Lose}{\textrm{Lose}} 
\newcommand{\Value}{\textrm{val}} 
\newcommand{\ValueE}{\textrm{val}_\mEve} 
\newcommand{\ValueA}{\textrm{val}_\mAdam}
\newcommand{\val}{\Value} 
\newcommand{\Automaton}{\mathbf{A}} 
\newcommand{\Safe}{\mathtt{Safe}}
\newcommand{\Reach}{\mathtt{Reach}} 
\newcommand{\Buchi}{\mathtt{Buchi}} 
\newcommand{\CoBuchi}{\mathtt{CoBuchi}} 
\newcommand{\Parity}{\mathtt{Parity}} 
\newcommand{\Muller}{\mathtt{Muller}} 
\newcommand{\Rabin}{\mathtt{Rabin}} 
\newcommand{\Streett}{\mathtt{Streett}} 
\newcommand{\MeanPayoff}{\mathtt{MeanPayoff}} 
\newcommand{\DiscountedPayoff}{\mathtt{DiscountedPayoff}}
\newcommand{\Energy}{\mathtt{Energy}}
\newcommand{\TotalPayoff}{\mathtt{TotalPayoff}}
\newcommand{\ShortestPath}{\mathtt{ShortestPath}}
\newcommand{\Sup}{\mathtt{Sup}}
\newcommand{\Inf}{\mathtt{Inf}}
\newcommand{\LimSup}{\mathtt{LimSup}}
\newcommand{\LimInf}{\mathtt{LimInf}}
\newcommand{\NL}{\textrm{NL}}
\newcommand{\PTIME}{\textrm{PTIME}}
\newcommand{\NP}{\textrm{NP}}
\newcommand{\UP}{\textrm{UP}}
\newcommand{\coNP}{\textrm{coNP}}
\newcommand{\coUP}{\textrm{coUP}}
\newcommand{\PSPACE}{\textrm{PSPACE}}
\newcommand{\EXPSPACE}{\textrm{EXPSPACE}}
\newcommand{\EXP}{\textrm{EXP}}
\newcommand{\kEXP}{\textrm{kEXP}}\]</div>
<div class="proof theorem admonition" id="3-thm:value_iteration_quasipoly">
<p class="admonition-title"><span class="caption-number">Theorem 80 </span> (NEEDS TITLE 3-thm:value_iteration_quasipoly)</p>
<div class="theorem-content section" id="proof-content">
<p>There exists a value iteration algorithm for solving parity games in time</p>
<div class="math notranslate nohighlight">
\[
O\left(nm \log(n) \log(d) \cdot  \binom{\lceil \log(n) \rceil + d/2 - 1}{\lceil \log(n) \rceil} \right),
\]</div>
<p>which is quasipolynomial in general and polynomial if <span class="math notranslate nohighlight">\(d = O(\log(n))\)</span>.
The space complexity of the algorithm is <span class="math notranslate nohighlight">\(O(m + n \log(d))\)</span>.</p>
</div>
</div><p>We rely on the high-level presentation of value iteration algorithms given in Section <a class="reference internal" href="../1_Introduction/value_iteration.html#sec-value-iteration"><span class="std std-ref">Value iteration algorithms</span></a>.
Let <span class="math notranslate nohighlight">\(\game = (\arena,\Parity[\col])\)</span> a parity game with <span class="math notranslate nohighlight">\(n\)</span> vertices and priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>,
and without loss of generality <span class="math notranslate nohighlight">\(d\)</span> is even.</p>
<p>The first step is to define a notion of value function <span class="math notranslate nohighlight">\(\val^\game : V \to Y\)</span> with <span class="math notranslate nohighlight">\((Y,\le)\)</span> a lattice satisfying the characterisation principle:
for all vertices <span class="math notranslate nohighlight">\(v\)</span> we have that Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if <span class="math notranslate nohighlight">\(\val^\game(v) \neq \bot\)</span>, where <span class="math notranslate nohighlight">\(\bot\)</span> is the least element in <span class="math notranslate nohighlight">\(Y\)</span>.
The goal of the algorithm is to compute <span class="math notranslate nohighlight">\(\val^\game\)</span>, from which we then easily obtain the winning region thanks to the characterisation principle.</p>
<p>To set the machinery of value iteration algorithms in motion we can either construct <span class="math notranslate nohighlight">\(\val^\game\)</span> as the unique fixed point of a contracting operator using Banach’s fixed point theorem or the greatest fixed point of a monotonic operator using Kleene’s fixed point theorem.</p>
<p>Let us here follow the second approach.
We let <span class="math notranslate nohighlight">\(F_V\)</span> be the lattice of functions <span class="math notranslate nohighlight">\(V \to Y\)</span> equipped with the componentwise order induced by <span class="math notranslate nohighlight">\(Y\)</span>.
We are looking for a monotonic function <span class="math notranslate nohighlight">\(\delta : Y \times [1,d] \to Y\)</span> inducing the operator <span class="math notranslate nohighlight">\(\Op : F_V \to F_V\)</span> defined by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Op(\mu)(v) = 
\begin{cases}
\max \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } v \in \VE, \\
\min \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } v \in \VA,
\end{cases}
\end{split}\]</div>
<p>such that <span class="math notranslate nohighlight">\(\val^\game\)</span> is the greatest fixed point of <span class="math notranslate nohighlight">\(\Op\)</span>.
The algorithm would then simply use  <a class="reference internal" href="../1_Introduction/fixed_points.html#1-thm:kleene">Theorem 24</a> to compute <span class="math notranslate nohighlight">\(\val^\game\)</span> by iterating the operator <span class="math notranslate nohighlight">\(\Op\)</span>.</p>
<p>Let us look at this question using the notion of progress measures, which are post-fixed points of <span class="math notranslate nohighlight">\(\Op\)</span>,
meaning <span class="math notranslate nohighlight">\(\mu\)</span> such that <span class="math notranslate nohighlight">\(\mu \le \Op(\mu)\)</span>.
Since the greatest fixed point of <span class="math notranslate nohighlight">\(\Op\)</span> is also its greatest post-fixed point, an equivalent formulation of the characterisation principle above reads: for all vertices <span class="math notranslate nohighlight">\(v\)</span> we have that Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if there exists a progress measure <span class="math notranslate nohighlight">\(\mu\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.</p>
<p>To summarise this discussion, we are looking for a lattice <span class="math notranslate nohighlight">\((Y,\le)\)</span> and a monotonic function <span class="math notranslate nohighlight">\(\delta : Y \times [1,d] \to Y\)</span>
such that for all parity games <span class="math notranslate nohighlight">\(\Game\)</span> with <span class="math notranslate nohighlight">\(n\)</span> vertices and priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>,
for all vertices <span class="math notranslate nohighlight">\(v\)</span> we have that Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if there exists a progress measure <span class="math notranslate nohighlight">\(\mu\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.
Our next step is to show how the notion of universal trees provides a class of solutions to this problem.</p>
<div class="section" id="universal-trees">
<h2>Universal trees<a class="headerlink" href="#universal-trees" title="Permalink to this headline">¶</a></h2>
<p>The trees we consider have three properties:
they are rooted, every leaf has the same depth, and the children of a node are totally ordered.
Formally, a tree of height <span class="math notranslate nohighlight">\(0\)</span> is a leaf,
and a tree <span class="math notranslate nohighlight">\(t\)</span> of height <span class="math notranslate nohighlight">\(h + 1\)</span> is an ordered list <span class="math notranslate nohighlight">\([t_1,\dots,t_k]\)</span> of subtrees each of height <span class="math notranslate nohighlight">\(h\)</span>.</p>
<p>We consider two parameters for trees: the height, and the size which is defined to be the number of branches (equivalently, the number of leaves).
All trees we consider have height <span class="math notranslate nohighlight">\(h = d/2\)</span>.</p>
<div class="figure align-center" id="fig-example-universal">
<img alt="../_images/3-fig:example_universal.png" src="../_images/3-fig:example_universal.png" />
<p class="caption"><span class="caption-number">Fig. 28 </span><span class="caption-text">On the left, a tree for <span class="math notranslate nohighlight">\(d = 4\)</span>, which is the smallest <span class="math notranslate nohighlight">\((5,2)\)</span>-universal tree:
it has size <span class="math notranslate nohighlight">\(11\)</span> (meaning it has <span class="math notranslate nohighlight">\(11\)</span> branches).
On the right, a tree of size <span class="math notranslate nohighlight">\(5\)</span> and one possible embedding into the universal tree.</span><a class="headerlink" href="#fig-example-universal" title="Permalink to this image">¶</a></p>
</div>
<p>We say that a tree <span class="math notranslate nohighlight">\(t\)</span> embeds into another tree <span class="math notranslate nohighlight">\(T\)</span> if:</p>
<ul class="simple">
<li><p>either both are leaves,</p></li>
<li><p>or let <span class="math notranslate nohighlight">\(t = [t_1,\dots,t_k]\)</span> and <span class="math notranslate nohighlight">\(T = [T_1,\dots,T_{k'}]\)</span>,
there exist <span class="math notranslate nohighlight">\(i_1 &lt; \dots &lt; i_k\)</span> such that for all <span class="math notranslate nohighlight">\(j \in [1,k]\)</span> we have that <span class="math notranslate nohighlight">\(t_j\)</span> embeds into <span class="math notranslate nohighlight">\(T_{i_j}\)</span>.</p></li>
</ul>
<div class="proof definition admonition" id="definition-1">
<p class="admonition-title"><span class="caption-number">Definition 81 </span> (NEEDS TITLE AND LABEL)</p>
<div class="definition-content section" id="proof-content">
<p>A tree is <span class="math notranslate nohighlight">\((n,h)\)</span>-<strong>universal</strong> if it embeds all trees of size <span class="math notranslate nohighlight">\(n\)</span> and height <span class="math notranslate nohighlight">\(h\)</span>.</p>
<p>A tree is <span class="math notranslate nohighlight">\((n,h)\)</span>-<strong>universal</strong> if it embeds all trees of size <span class="math notranslate nohighlight">\(n\)</span> and height <span class="math notranslate nohighlight">\(h\)</span>.</p>
</div>
</div><p>We refer to <a class="reference internal" href="#fig-example-universal"><span class="std std-numref">Fig. 28</span></a> for an example of a <span class="math notranslate nohighlight">\((5,2)\)</span>-universal tree.
A first example of an <span class="math notranslate nohighlight">\((n,h)\)</span>-universal tree is the tree where each node has degree <span class="math notranslate nohighlight">\(n\)</span>:
formally we define it recursively by <span class="math notranslate nohighlight">\(T_{n,0}\)</span> is a leaf, and <span class="math notranslate nohighlight">\(T_{n,h+1} = [\underbrace{T_{n,h},\dots,T_{n,h}}_{n \text{ copies}}]\)</span>.
It has size <span class="math notranslate nohighlight">\(n^h\)</span>.</p>
</div>
<div class="section" id="a-quasipolynomial-universal-tree">
<h2>A quasipolynomial universal tree<a class="headerlink" href="#a-quasipolynomial-universal-tree" title="Permalink to this headline">¶</a></h2>
<p>We present an inductive construction of a quasipolynomial universal tree.</p>
<div class="proof theorem admonition" id="3-thm:universal_tree">
<p class="admonition-title"><span class="caption-number">Theorem 82 </span> (NEEDS TITLE 3-thm:universal_tree)</p>
<div class="theorem-content section" id="proof-content">
<p>There exists an <span class="math notranslate nohighlight">\((n,h)\)</span>-universal tree with size <span class="math notranslate nohighlight">\(f(n,h)\)</span>, where <span class="math notranslate nohighlight">\(\mu\)</span> satisfies the following:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{lll}
f(n,h) &amp; = &amp; f(n,h-1) + f(\lfloor n/2 \rfloor,h) + f(\lceil n/2 \rceil - 1,h), \\
f(n,1) &amp; = &amp; n, \\
f(1,h) &amp; = &amp; 1.
\end{array}
\end{split}\]</div>
</div>
</div><p>An upper bound is given by</p>
<div class="math notranslate nohighlight">
\[
f(n,h) \le 2n \binom{\lceil \log(n) \rceil + h - 1}{\lceil \log(n) \rceil}.
\]</div>
<p>A generous upper bound on the expression above is <span class="math notranslate nohighlight">\(n^{O(\log(h))}\)</span>.
A refined analysis reveals that the expression is polynomial in <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(h\)</span> if <span class="math notranslate nohighlight">\(h = O(\log(n))\)</span>.</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>To construct the <span class="math notranslate nohighlight">\((n,h)\)</span>-universal tree <span class="math notranslate nohighlight">\(T\)</span>, let:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T_\text{left}\)</span> be a <span class="math notranslate nohighlight">\((\lfloor n/2 \rfloor,h)\)</span>-universal tree,</p></li>
<li><p><span class="math notranslate nohighlight">\(T_\text{middle}\)</span> be a <span class="math notranslate nohighlight">\((n,h-1)\)</span>-universal tree,</p></li>
<li><p><span class="math notranslate nohighlight">\(T_\text{right}\)</span> be a <span class="math notranslate nohighlight">\((\lceil n/2 \rceil - 1,h)\)</span>-universal tree.</p></li>
</ul>
<p>The intuitive construction of <span class="math notranslate nohighlight">\(T\)</span> is as follows:
we merge the roots of <span class="math notranslate nohighlight">\(T_\text{left}\)</span> and <span class="math notranslate nohighlight">\(T_\text{right}\)</span> and insert inbetween them
a child of the root to which is attached <span class="math notranslate nohighlight">\(T_\text{middle}\)</span>.
Formally, let <span class="math notranslate nohighlight">\(T_\text{left} = [T^1_{\text{left}},\dots,T^k_{\text{left}}]\)</span> and
<span class="math notranslate nohighlight">\(T_\text{right} = [T^1_{\text{right}},\dots,T^{k'}_{\text{right}}]\)</span>,
we define <span class="math notranslate nohighlight">\(T\)</span> as</p>
<div class="math notranslate nohighlight">
\[
[T^1_{\text{left}},\dots,T^k_{\text{left}},\ T_\text{middle},\ T^1_{\text{right}},\dots,T^{k'}_{\text{right}}].
\]</div>
<p>The construction is illustrated in <a class="reference internal" href="#fig-smallest-tree-construction"><span class="std std-numref">Fig. 29</span></a>.</p>
<div class="figure align-center" id="fig-smallest-tree-construction">
<img alt="../_images/3-fig:smallest_tree_construction.png" src="../_images/3-fig:smallest_tree_construction.png" />
<p class="caption"><span class="caption-number">Fig. 29 </span><span class="caption-text">The inductive construction.</span><a class="headerlink" href="#fig-smallest-tree-construction" title="Permalink to this image">¶</a></p>
</div>
<p>We argue that <span class="math notranslate nohighlight">\(T\)</span> is <span class="math notranslate nohighlight">\((n,h)\)</span>-universal.
Consider a tree <span class="math notranslate nohighlight">\(t = [t_1,\dots,t_k]\)</span> with <span class="math notranslate nohighlight">\(n\)</span> branches.
The question is where to cut, <strong>i.e.</strong> which subtree of <span class="math notranslate nohighlight">\(t\)</span> gets mapped to <span class="math notranslate nohighlight">\(T_\text{middle}\)</span>.
Let <span class="math notranslate nohighlight">\(n(t_i)\)</span> be the number of branches in <span class="math notranslate nohighlight">\(t_i\)</span>.
Since <span class="math notranslate nohighlight">\(t\)</span> has <span class="math notranslate nohighlight">\(n\)</span> branches, we have <span class="math notranslate nohighlight">\(n(t_1) + \cdots + n(t_k) = n\)</span>.
There exists a unique <span class="math notranslate nohighlight">\(p \in [1,k]\)</span> such that
<span class="math notranslate nohighlight">\(n(t_1) + \cdots + n(t_{p-1}) \le \lfloor n/2 \rfloor
\text{ and } 
n(t_1) + \cdots + n(t_p) &gt; \lfloor n/2 \rfloor\)</span>.
The choice of <span class="math notranslate nohighlight">\(p\)</span> implies that <span class="math notranslate nohighlight">\(n(t_{p+1}) + \cdots + n(t_k) \le \lceil n/2 \rceil - 1\)</span>.
To embed <span class="math notranslate nohighlight">\(t\)</span> into <span class="math notranslate nohighlight">\(T\)</span>, we proceed as follows:</p>
<ul class="simple">
<li><p>the tree <span class="math notranslate nohighlight">\([t_1,\dots,t_{p-1}]\)</span> has at most <span class="math notranslate nohighlight">\(\lfloor n/2 \rfloor\)</span> branches,
so it embeds into <span class="math notranslate nohighlight">\(T_\text{left}\)</span> by induction hypothesis;</p></li>
<li><p>the tree <span class="math notranslate nohighlight">\(t_p\)</span> has height <span class="math notranslate nohighlight">\(h-1\)</span> and at most <span class="math notranslate nohighlight">\(n\)</span> branches, so in embeds into <span class="math notranslate nohighlight">\(T_\text{middle}\)</span> by induction hypothesis;</p></li>
<li><p>the tree <span class="math notranslate nohighlight">\([t_{p+1},\dots,t_k]\)</span> has at most <span class="math notranslate nohighlight">\(\lceil n/2 \rceil - 1\)</span> branches,
so it embeds into <span class="math notranslate nohighlight">\(T_\text{right}\)</span> by induction hypothesis.</p></li>
</ul>
</div>
<p>The construction given in the proof yields the smallest <span class="math notranslate nohighlight">\((5,2)\)</span>-universal tree illustrated in <a class="reference internal" href="#fig-example-universal"><span class="std std-numref">Fig. 28</span></a>.</p>
</div>
<div class="section" id="ordering-the-branches">
<h2>Ordering the branches<a class="headerlink" href="#ordering-the-branches" title="Permalink to this headline">¶</a></h2>
<p>Let us consider a tree <span class="math notranslate nohighlight">\(t\)</span>.
A branch is given by a list of directions that we define now.
For technical convenience that will manifest itself later, the list of directions is indexed by odd numbers <span class="math notranslate nohighlight">\(p \in [1,d]\)</span> downwards:
for example for <span class="math notranslate nohighlight">\(d = 10\)</span> a branch is <span class="math notranslate nohighlight">\((D_9,D_7,D_5,D_3,D_1)\)</span>.
We often naturally identify a leaf, its branch, and the list of directions that represents it.</p>
<p>We write <span class="math notranslate nohighlight">\(B_t\)</span> for the set of branches of <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(\le\)</span> for the lexicographic order on <span class="math notranslate nohighlight">\(B_t\)</span>.
Note that its interpretation on the tree is: for two branches <span class="math notranslate nohighlight">\(b,b'\)</span>, we have <span class="math notranslate nohighlight">\(b \le b'\)</span> if and only if <span class="math notranslate nohighlight">\(b\)</span> is to the left of <span class="math notranslate nohighlight">\(b'\)</span>.
The strict version of <span class="math notranslate nohighlight">\(\le\)</span> is <span class="math notranslate nohighlight">\(&lt;\)</span>.</p>
<p>We introduce a set of relations <span class="math notranslate nohighlight">\(\vartriangleleft_p\)</span> over <span class="math notranslate nohighlight">\(B_t\)</span> for each <span class="math notranslate nohighlight">\(p \in [1,d]\)</span>.
For a branch <span class="math notranslate nohighlight">\(b = (D_{d-1},\dots,D_3,D_1)\)</span> we write <span class="math notranslate nohighlight">\(b_{\ge p}\)</span> for the tuple <span class="math notranslate nohighlight">\((D_{d-1},\dots,D_{p+2},D_p)\)</span>,
which we call the <span class="math notranslate nohighlight">\(p\)</span>-truncated branch of <span class="math notranslate nohighlight">\(b\)</span>.</p>
<ul class="simple">
<li><p>For <span class="math notranslate nohighlight">\(p\)</span> odd, we say that <span class="math notranslate nohighlight">\(b \vartriangleleft_p b'\)</span>
if <span class="math notranslate nohighlight">\(b_{\ge p}\ &lt;\ b'_{\ge p}\)</span>.</p></li>
<li><p>For <span class="math notranslate nohighlight">\(p\)</span> even, we say that <span class="math notranslate nohighlight">\(b \vartriangleleft_p b'\)</span>
if <span class="math notranslate nohighlight">\(b_{\ge p}\ \le\ b'_{\ge p}\)</span>.</p></li>
</ul>
<p>To interpret <span class="math notranslate nohighlight">\(\vartriangleleft_p\)</span> on the tree, we label the levels by priorities from bottom to top as in <a class="reference internal" href="#fig-example-universal"><span class="std std-numref">Fig. 28</span></a>.
Then <span class="math notranslate nohighlight">\(b \vartriangleleft_p b'\)</span> if and only if the <span class="math notranslate nohighlight">\(p\)</span>-truncated branch of <span class="math notranslate nohighlight">\(b\)</span> is to the left of the <span class="math notranslate nohighlight">\(p\)</span>-truncated branch of <span class="math notranslate nohighlight">\(b'\)</span>,
strictly if <span class="math notranslate nohighlight">\(p\)</span> is odd, and non-strictly if <span class="math notranslate nohighlight">\(p\)</span> is even.</p>
<div class="figure align-center" id="fig-example-relations">
<img alt="../_images/3-fig:example_relations.png" src="../_images/3-fig:example_relations.png" />
<p class="caption"><span class="caption-number">Fig. 30 </span><span class="caption-text">Illustration of the relations <span class="math notranslate nohighlight">\(\vartriangleleft_p\)</span>.</span><a class="headerlink" href="#fig-example-relations" title="Permalink to this image">¶</a></p>
</div>
<p>We refer to <a class="reference internal" href="#fig-example-relations"><span class="std std-numref">Fig. 30</span></a> for some examples:</p>
<div class="math notranslate nohighlight">
\[
v \vartriangleleft_1 u \quad ; \quad  
v \vartriangleleft_2 u \quad ; \quad 
u \vartriangleleft_2 v \quad ; \quad 
w \vartriangleleft_3 u \quad ; \quad 
w \vartriangleleft_2 v.
\]</div>
<div class="proof lemma admonition" id="3-lem:properties_tree">
<p class="admonition-title"><span class="caption-number">Lemma 83 </span> (NEEDS TITLE 3-lem:properties_tree)</p>
<div class="lemma-content section" id="proof-content">
<p>The relations <span class="math notranslate nohighlight">\(\vartriangleleft_p\)</span> for <span class="math notranslate nohighlight">\(p \in [1,d]\)</span> induced by a tree <span class="math notranslate nohighlight">\(t\)</span> satisfy the following properties:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\vartriangleleft_d\)</span> is the full relation: for all <span class="math notranslate nohighlight">\(b,b'\)</span> we have <span class="math notranslate nohighlight">\(b \vartriangleleft_d b'\)</span>;</p></li>
<li><p>if <span class="math notranslate nohighlight">\(b \vartriangleleft_p b'\)</span> and <span class="math notranslate nohighlight">\(b' \vartriangleleft_q b''\)</span> then <span class="math notranslate nohighlight">\(b \vartriangleleft_{\max(p,q)} b''\)</span>;</p></li>
<li><p>the relation <span class="math notranslate nohighlight">\(\vartriangleleft_p\)</span> is non-reflexive if <span class="math notranslate nohighlight">\(p\)</span> is odd;</p></li>
<li><p>the relation <span class="math notranslate nohighlight">\(\vartriangleleft_1\)</span> is total;</p></li>
<li><p>for <span class="math notranslate nohighlight">\(p &lt; d\)</span> even we have <span class="math notranslate nohighlight">\(b \vartriangleleft_p b'\)</span> if and only if <span class="math notranslate nohighlight">\(\neg (b' \vartriangleleft_{p+1} b)\)</span>.</p></li>
</ul>
</div>
</div><p>The following observation rephrases the notion of embeddings between trees using the ordering on branches.</p>
<div class="proof observation admonition" id="3-fact:embedding">
<p class="admonition-title"><span class="caption-number">Observation 84 </span> (NEEDS TITLE 3-fact:embedding)</p>
<div class="observation-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(t,T\)</span> be two trees.
Then <span class="math notranslate nohighlight">\(t\)</span> embeds into <span class="math notranslate nohighlight">\(T\)</span> if and only if there exists a function <span class="math notranslate nohighlight">\(\mu : B_t \to B_T\)</span>
such that for all branches <span class="math notranslate nohighlight">\(b,b'\)</span>:</p>
<div class="math notranslate nohighlight">
\[
b \vartriangleleft_p^t b' \implies \mu(b) \vartriangleleft_p^T \mu(b').
\]</div>
</div>
</div></div>
<div class="section" id="progress-measures">
<h2>Progress measures<a class="headerlink" href="#progress-measures" title="Permalink to this headline">¶</a></h2>
<p>We explain how a tree <span class="math notranslate nohighlight">\(t\)</span> induces both a lattice <span class="math notranslate nohighlight">\((Y_t,\le)\)</span> and a monotonic function <span class="math notranslate nohighlight">\(\delta_t : Y_t \times [1,d] \to Y_t\)</span>.
The set <span class="math notranslate nohighlight">\(Y_t\)</span> is the set of branches of <span class="math notranslate nohighlight">\(t\)</span> augmented with a new element <span class="math notranslate nohighlight">\(\bot\)</span>,
and <span class="math notranslate nohighlight">\(\le\)</span> is the lexicographic order on branches with <span class="math notranslate nohighlight">\(\bot\)</span> as least element.
For each <span class="math notranslate nohighlight">\(p \in [1,d]\)</span> and <span class="math notranslate nohighlight">\(b \in Y_t\)</span> we extend <span class="math notranslate nohighlight">\(\vartriangleleft_p\)</span> with <span class="math notranslate nohighlight">\(\bot \vartriangleleft_p b\)</span>.
We then define <span class="math notranslate nohighlight">\(\delta : Y_t \times [1,d] \to Y_t\)</span> by</p>
<div class="math notranslate nohighlight">
\[
\delta(b,p) = \max \set{b' : b' \vartriangleleft_p b}.
\]</div>
<p>This in turn induces a monotonic operator <span class="math notranslate nohighlight">\(\Op_t : F_V \to F_V\)</span> defined by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Op(\mu)(v) = 
\begin{cases}
\max \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } v \in \VE, \\
\min \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } v \in \VA.
\end{cases}
\end{split}\]</div>
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a parity game, a progress measure is a function <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> which is a post-fixed point: <span class="math notranslate nohighlight">\(\mu \le \Op_t(\mu)\)</span>.
Expanding the definitions, this means that for all vertices <span class="math notranslate nohighlight">\(v\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{llll}
\exists (v,v') \in E,\ &amp; \mu(v) \le \delta_t( \mu(v'), \col(v)) &amp; \text{ if } v \in \VE, \\
\forall (v,v') \in E,\ &amp; \mu(v) \le \delta_t( \mu(v'), \col(v)) &amp; \text{ if } v \in \VA.
\end{array}
\end{split}\]</div>
<p>The definition of <span class="math notranslate nohighlight">\(\delta_t\)</span> further simplifies it to: for all vertices <span class="math notranslate nohighlight">\(v\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{llll}
\exists (v,v') \in E,\ &amp; \mu(v) \vartriangleleft_{\col(v)} \mu(v') &amp; \text{ if } v \in \VE, \\
\forall (v,v') \in E,\ &amp; \mu(v) \vartriangleleft_{\col(v)} \mu(v') &amp; \text{ if } v \in \VA.
\end{array}
\end{split}\]</div>
<p>The following theorem is our first and main step towards proving the characterisation principle.</p>
<div class="proof theorem admonition" id="3-thm:progress_measure">
<p class="admonition-title"><span class="caption-number">Theorem 85 </span> (NEEDS TITLE 3-thm:progress_measure)</p>
<div class="theorem-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a parity game and <span class="math notranslate nohighlight">\(v\)</span> a vertex.
Then Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.</p>
</div>
</div><p>In order to prove  <a class="reference internal" href="#3-thm:progress_measure">Theorem 85</a>, we first consider the case of parity graphs.
A progress measure in a parity graph is a function <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that
for all edges <span class="math notranslate nohighlight">\((v,v') \in E\)</span> we have <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.</p>
<p>Recall that a graph satisfies parity from <span class="math notranslate nohighlight">\(v\)</span> if all infinite paths from <span class="math notranslate nohighlight">\(v\)</span> satisfy parity.
This is equivalent to asking whether all cycles reachable from <span class="math notranslate nohighlight">\(v\)</span> are even, meaning the maximal priority appearing in the cycle is even.</p>
<div class="proof lemma admonition" id="3-lem:progress_measure">
<p class="admonition-title"><span class="caption-number">Lemma 86 </span> (NEEDS TITLE 3-lem:progress_measure)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(G\)</span> be a parity graph and <span class="math notranslate nohighlight">\(v\)</span> a vertex.
Then <span class="math notranslate nohighlight">\(G\)</span> satisfies parity from <span class="math notranslate nohighlight">\(v\)</span> if and only if
there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Let us assume that there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>
and for all edges <span class="math notranslate nohighlight">\((v,v') \in E\)</span> we have <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.
To show that <span class="math notranslate nohighlight">\(G\)</span> satisfies parity from <span class="math notranslate nohighlight">\(v\)</span> we show that any cycle reachable from <span class="math notranslate nohighlight">\(v\)</span> is even.
Let us consider such a cycle:</p>
<div class="math notranslate nohighlight">
\[
(v_1,v_2) (v_2,v_3) \cdots (v_k,v_1).
\]</div>
<p>Since the cycle is reachable from <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>, this implies that <span class="math notranslate nohighlight">\(\mu(v_i) \neq \bot\)</span> for <span class="math notranslate nohighlight">\(i \in [1,k]\)</span>.
Let us assume towards contradiction that its maximal priority is odd, and without loss of generality it is <span class="math notranslate nohighlight">\(\col(v_1)\)</span>.
Applying our hypothesis to each edge of the cycle we have</p>
<div class="math notranslate nohighlight">
\[
\mu(v_1) \vartriangleleft_{\col(v_1)} \mu(v_2) \vartriangleleft_{\col(v_2)} \cdots 
\vartriangleleft_{\col(v_{k-1})} \mu(v_k) \vartriangleleft_{\col(v_k)} \mu(v_1).
\]</div>
<p>The second item of  <a class="reference internal" href="#3-lem:properties_tree">Lemma 83</a> implies that <span class="math notranslate nohighlight">\(\mu(v_1) \vartriangleleft_{\col(v_1)} \mu(v_1)\)</span>,
which contradicts the third item since <span class="math notranslate nohighlight">\(\vartriangleleft_{\col(v_1)}\)</span> is non-reflexive given that <span class="math notranslate nohighlight">\(\col(v_1)\)</span> is odd.</p>
<p>Let us now prove the converse implication.
We prove the following property by induction on the number of vertices:
for all graphs satisfying parity (without the usual assumption that every vertex has an outgoing edge),
there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>
for all vertices <span class="math notranslate nohighlight">\(v \in V\)</span>.</p>
<p>There are two cases: either the largest priority <span class="math notranslate nohighlight">\(d\)</span> in the graph is even or it is odd.
We write <span class="math notranslate nohighlight">\(V_d\)</span> for the set of vertices of priority <span class="math notranslate nohighlight">\(d\)</span>.</p>
<p><strong>Case <span class="math notranslate nohighlight">\(d\)</span> even.</strong>
Let us consider the graph induced by the set of vertices <span class="math notranslate nohighlight">\(V \setminus V_d\)</span>.
It satisfies parity, so by induction hypothesis there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu_d : V \setminus V_d \to Y_t\)</span>
such that <span class="math notranslate nohighlight">\(\mu_d(v) \neq \bot\)</span> for all vertices <span class="math notranslate nohighlight">\(v \in V \setminus V_d\)</span>.
We extend <span class="math notranslate nohighlight">\(\mu_d\)</span> to <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span>: for <span class="math notranslate nohighlight">\(v \in V_d\)</span> we let <span class="math notranslate nohighlight">\(\mu(v) = \ell_{\max}\)</span> where <span class="math notranslate nohighlight">\(\ell_{\max}\)</span> is the maximal element in <span class="math notranslate nohighlight">\(Y_t\)</span>.
Then <span class="math notranslate nohighlight">\(\mu\)</span> is a progress measure such that <span class="math notranslate nohighlight">\(\mu_d(v) \neq \bot\)</span> for all vertices <span class="math notranslate nohighlight">\(v \in V\)</span>.
Indeed the additional edges are of the form <span class="math notranslate nohighlight">\((v,v')\)</span> for either <span class="math notranslate nohighlight">\(v \in V_d\)</span> or <span class="math notranslate nohighlight">\(v' \in V_d\)</span>:
in the first case <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span> holds because <span class="math notranslate nohighlight">\(\vartriangleleft_d\)</span> is the full relation,
and in the second case because <span class="math notranslate nohighlight">\(\mu(v') = \ell_{\max}\)</span>.</p>
<p><strong>Case <span class="math notranslate nohighlight">\(d\)</span> odd.</strong>
We claim that there exists a non-trivial partition <span class="math notranslate nohighlight">\(V = W_1 \uplus W_2\)</span> such that there is no edge from <span class="math notranslate nohighlight">\(W_1\)</span> to <span class="math notranslate nohighlight">\(W_2\)</span>.
Let <span class="math notranslate nohighlight">\(u \in V_d\)</span>, define <span class="math notranslate nohighlight">\(U\)</span> the set of vertices reachable from <span class="math notranslate nohighlight">\(u\)</span> by a non-trivial path.
If <span class="math notranslate nohighlight">\(U\)</span> is empty, then <span class="math notranslate nohighlight">\(V = \set{u} \uplus (V \setminus \set{u})\)</span> is a non-trivial partition as desired.
Otherwise <span class="math notranslate nohighlight">\(U\)</span> is non empty, then <span class="math notranslate nohighlight">\(V = U \uplus (V \setminus U)\)</span> is a non-trivial partition as desired:
to see that <span class="math notranslate nohighlight">\(V \setminus U\)</span> is non empty we note that <span class="math notranslate nohighlight">\(u \in V \setminus U\)</span>, otherwise there would be an odd cycle
(containing the maximal and odd priority <span class="math notranslate nohighlight">\(d\)</span>).</p>
<p>We consider the graphs induced by <span class="math notranslate nohighlight">\(W_1\)</span> and <span class="math notranslate nohighlight">\(W_2\)</span>.
They both satisfy parity, so by induction hypothesis for <span class="math notranslate nohighlight">\(i \in \set{1,2}\)</span>
there exists a tree <span class="math notranslate nohighlight">\(t_i\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu_i : W_i \to Y_{t_i}\)</span>
such that <span class="math notranslate nohighlight">\(\mu_i(v) \neq \bot\)</span> for all vertices <span class="math notranslate nohighlight">\(v \in W_i\)</span>.
We let <span class="math notranslate nohighlight">\(t\)</span> denote the tree obtained by putting the two trees <span class="math notranslate nohighlight">\(t_1\)</span> and <span class="math notranslate nohighlight">\(t_2\)</span> side by side with <span class="math notranslate nohighlight">\(t_2\)</span> on the left of <span class="math notranslate nohighlight">\(t_1\)</span>.
Formally, <span class="math notranslate nohighlight">\(t_1 = [t^1_1,\dots,t^k_1]\)</span> and <span class="math notranslate nohighlight">\(t_2 = [t^1_2,\dots,t^{k'}_2]\)</span>, let
<span class="math notranslate nohighlight">\(t = [t^1_2,\dots,t^{k'}_2,\ t^1_1,\dots,t^k_1]\)</span>.
We define <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> by <span class="math notranslate nohighlight">\(\mu(v) = \mu_i(v)\)</span> if <span class="math notranslate nohighlight">\(v \in W_i\)</span>.
Then <span class="math notranslate nohighlight">\(\mu\)</span> is a progress measure: for edges in the graphs induced by <span class="math notranslate nohighlight">\(W_1\)</span> and <span class="math notranslate nohighlight">\(W_2\)</span> this is because <span class="math notranslate nohighlight">\(\mu_1\)</span> and <span class="math notranslate nohighlight">\(\mu_2\)</span> are,
and the additional edges are from <span class="math notranslate nohighlight">\(v \in W_2\)</span> to <span class="math notranslate nohighlight">\(v' \in W_1\)</span>, so indeed <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span> holds.
This finishes the inductive proof of the property.</p>
<p>We show that the property extends to graphs not satisfying parity.
Let <span class="math notranslate nohighlight">\(G\)</span> a parity graph and <span class="math notranslate nohighlight">\(W\)</span> the set of vertices <span class="math notranslate nohighlight">\(v\)</span> such that <span class="math notranslate nohighlight">\(G\)</span> satisfies parity from <span class="math notranslate nohighlight">\(v\)</span>.
Let <span class="math notranslate nohighlight">\(G'\)</span> the graph induced by <span class="math notranslate nohighlight">\(W\)</span>, it satisfies parity so
by the property above there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu_W : W \to Y_t\)</span> such that
<span class="math notranslate nohighlight">\(\mu_W(v) \neq \bot\)</span> for all vertices <span class="math notranslate nohighlight">\(v \in W\)</span>.
We extend <span class="math notranslate nohighlight">\(\mu_W\)</span> to <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span>: for <span class="math notranslate nohighlight">\(v \notin W\)</span> we let <span class="math notranslate nohighlight">\(\mu(v) = \bot\)</span>.
To see that <span class="math notranslate nohighlight">\(\mu\)</span> is a progress measure we make two remarks.
First, if <span class="math notranslate nohighlight">\(v \in W\)</span> then all successors of <span class="math notranslate nohighlight">\(v\)</span> are also in <span class="math notranslate nohighlight">\(W\)</span> (by prefix independence of parity),
so the edges in <span class="math notranslate nohighlight">\(G\)</span> are either in <span class="math notranslate nohighlight">\(G'\)</span> or from <span class="math notranslate nohighlight">\(v \in V \setminus W\)</span> to <span class="math notranslate nohighlight">\(v' \in W\)</span>.
In the first case <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span> holds because <span class="math notranslate nohighlight">\(\mu_W\)</span> is a progress measure,
and in the second case because <span class="math notranslate nohighlight">\(\mu(v) = \bot\)</span>.</p>
</div>
<p>We can now prove  <a class="reference internal" href="#3-thm:progress_measure">Theorem 85</a>.</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Assume that Eve wins from <span class="math notranslate nohighlight">\(v\)</span> and let <span class="math notranslate nohighlight">\(\sigma\)</span> be a positional strategy.
The parity graph <span class="math notranslate nohighlight">\(\Game[\sigma]\)</span> satisfies parity from <span class="math notranslate nohighlight">\(v\)</span>, so thanks to  <a class="reference internal" href="#3-lem:progress_measure">Lemma 86</a>
there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a function <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>
and for all edges <span class="math notranslate nohighlight">\((v,v') \in E\)</span> we have <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.
We remark that <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span> is actually a progress measure: the condition for <span class="math notranslate nohighlight">\(v \in \VE\)</span> is ensured by the edge <span class="math notranslate nohighlight">\(\sigma(v)\)</span>,
and the condition for <span class="math notranslate nohighlight">\(v \in \VA\)</span> by assumption on <span class="math notranslate nohighlight">\(\mu\)</span>.</p>
<p>Conversely, assume that there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span>.
It induces a positional strategy defined by <span class="math notranslate nohighlight">\(\sigma(v) = (v,v')\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.
We argue that <span class="math notranslate nohighlight">\(\sigma\)</span> is a winning strategy from any vertex <span class="math notranslate nohighlight">\(v\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.
This is a consequence of  <a class="reference internal" href="#3-lem:progress_measure">Lemma 86</a> for the parity graph <span class="math notranslate nohighlight">\(\Game[\sigma]\)</span>.</p>
</div>
<p><a class="reference internal" href="#3-thm:progress_measure">Theorem 85</a> is very close to the characterisation principle we are after,
the only difference being that the lattice <span class="math notranslate nohighlight">\((Y_t,\le)\)</span> depends on an existentially quantified tree <span class="math notranslate nohighlight">\(t\)</span>.
This is where we use universal trees:</p>
<div class="proof corollary admonition" id="3-cor:progress_measure">
<p class="admonition-title"><span class="caption-number">Corollary 87 </span> (NEEDS TITLE 3-cor:progress_measure)</p>
<div class="corollary-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a parity game with <span class="math notranslate nohighlight">\(n\)</span> vertices and priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>, and <span class="math notranslate nohighlight">\(v\)</span> a vertex.
Let <span class="math notranslate nohighlight">\(T\)</span> be a <span class="math notranslate nohighlight">\((n,d/2)\)</span>-universal tree.
Then Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if there exists a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_T\)</span> such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Assume that Eve wins from <span class="math notranslate nohighlight">\(v\)</span>, thanks to  <a class="reference internal" href="#3-thm:progress_measure">Theorem 85</a> there exists a tree <span class="math notranslate nohighlight">\(t\)</span> and a progress measure <span class="math notranslate nohighlight">\(\mu : V \to Y_t\)</span>
such that <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.
Since <span class="math notranslate nohighlight">\(T\)</span> is <span class="math notranslate nohighlight">\((n,d/2)\)</span>-universal and <span class="math notranslate nohighlight">\(t\)</span> has at most <span class="math notranslate nohighlight">\(n\)</span> branches, <span class="math notranslate nohighlight">\(t\)</span> embeds into <span class="math notranslate nohighlight">\(T\)</span>,
which thanks to \cref{3-fact:embedding} implies that there exists <span class="math notranslate nohighlight">\(\mu' : B_t \to B_T\)</span> respecting the relations <span class="math notranslate nohighlight">\(\vartriangleleft\)</span>.
We extend it to <span class="math notranslate nohighlight">\(\mu' : Y_t \to Y_T\)</span> by <span class="math notranslate nohighlight">\(\mu'(\bot) = \bot\)</span>.
Then the composition <span class="math notranslate nohighlight">\(\mu' \circ \mu : V \to Y_T\)</span> is a progress measure such that <span class="math notranslate nohighlight">\((\mu' \circ \mu)(v) \neq \bot\)</span>.</p>
<p>The converse implication is a direct consequence of  <a class="reference internal" href="#3-thm:progress_measure">Theorem 85</a>.</p>
</div>
<p>We have proved that the characterisation principle holds for any <span class="math notranslate nohighlight">\((n,d/2)\)</span>-universal tree.</p>
</div>
<div class="section" id="the-algorithm">
<h2>The algorithm<a class="headerlink" href="#the-algorithm" title="Permalink to this headline">¶</a></h2>
<p>Let us fix <span class="math notranslate nohighlight">\(T\)</span> an <span class="math notranslate nohighlight">\((n,d/2)\)</span>-universal tree.
It induces both a lattice <span class="math notranslate nohighlight">\((Y_T,\le)\)</span> and a monotonic function <span class="math notranslate nohighlight">\(\delta_T : Y_T \times [1,d] \to Y_T\)</span>,
which in turn induces a monotonic operator <span class="math notranslate nohighlight">\(\Op_T : F_V \to F_V\)</span>.
Since <span class="math notranslate nohighlight">\(T\)</span> is fixed we do not specify the subscript <span class="math notranslate nohighlight">\(T\)</span> for all these objects.</p>
<p>The last step is to construct an algorithm returning the maximal progress measure relying on Kleene’s fixed point theorem (stated as  <a class="reference internal" href="../1_Introduction/fixed_points.html#1-thm:kleene">Theorem 24</a>).
The generic algorithm is explained in Section <a class="reference internal" href="../1_Introduction/value_iteration.html#sec-value-iteration"><span class="std std-ref">Value iteration algorithms</span></a>, let us instantiate it here.</p>
<p>For the complexity analysis it is useful to decompose <span class="math notranslate nohighlight">\(\Op\)</span> into a set of operators:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Op_v(\mu)(u) = 
\begin{cases}
\mu(v) &amp; \text{ if } u \neq v, \\
\max \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } u = v \in \VE, \\
\min \set{\delta( \mu(v'), \col(v)) : (v,v') \in E} &amp; \text{ if } u = v \in \VA.
\end{cases}
\end{split}\]</div>
<p>We introduce some terminology: we say that an edge <span class="math notranslate nohighlight">\(e = (v,v')\)</span> is <strong>neglected</strong> if <span class="math notranslate nohighlight">\(\neg (\mu(v) \vartriangleleft_{\col(v)} \mu(v'))\)</span>,
and a vertex <span class="math notranslate nohighlight">\(v\)</span> is <strong>neglected</strong> if <span class="math notranslate nohighlight">\(\neg (\mu(v) \le \Op_v(\mu)(v))\)</span>.</p>
<div class="figure align-center" id="fig-lifting">
<img alt="../_images/3-fig:lifting.png" src="../_images/3-fig:lifting.png" />
<p class="caption"><span class="caption-number">Fig. 31 </span><span class="caption-text">The operator <span class="math notranslate nohighlight">\(\Op_v\)</span> in action: <span class="math notranslate nohighlight">\(\Op_v(\mu)(v)\)</span> is the maximal leaf (meaning the rightmost leaf)
which satisfies <span class="math notranslate nohighlight">\(\Op_v(\mu)(v) \vartriangleleft_3 \mu(v')\)</span> and <span class="math notranslate nohighlight">\(\Op_v(\mu)(v) \vartriangleleft_3 \mu(v'')\)</span>.</span><a class="headerlink" href="#fig-lifting" title="Permalink to this image">¶</a></p>
</div>
<p>The pseudocode for the algorithm is given in <a class="reference internal" href="#algo-value-iteration"><span class="std std-numref">Fig. 32</span></a>,
where we let <span class="math notranslate nohighlight">\(\ell_{\max}\)</span> denote the maximal leaf in <span class="math notranslate nohighlight">\(T\)</span>.</p>
<div class="figure align-center" id="algo-value-iteration">
<img alt="../_images/3-algo:value_iteration.png" src="../_images/3-algo:value_iteration.png" />
<p class="caption"><span class="caption-number">Fig. 32 </span><span class="caption-text">The value iteration algorithm.</span><a class="headerlink" href="#algo-value-iteration" title="Permalink to this image">¶</a></p>
</div>
<div class="proof theorem admonition" id="theorem-8">
<p class="admonition-title"><span class="caption-number">Theorem 88 </span> (NEEDS TITLE AND LABEL)</p>
<div class="theorem-content section" id="proof-content">
<p>For all <span class="math notranslate nohighlight">\((n, d/2)\)</span>-universal tree <span class="math notranslate nohighlight">\(T\)</span>, for all parity games <span class="math notranslate nohighlight">\(\game\)</span> with <span class="math notranslate nohighlight">\(n\)</span> vertices and priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>,
the value iteration algorithm over the tree <span class="math notranslate nohighlight">\(T\)</span> returns the maximal progress measure <span class="math notranslate nohighlight">\(\mu\)</span> for <span class="math notranslate nohighlight">\(\game\)</span> over <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p>For all <span class="math notranslate nohighlight">\((n, d/2)\)</span>-universal tree <span class="math notranslate nohighlight">\(T\)</span>, for all parity games <span class="math notranslate nohighlight">\(\game\)</span> with <span class="math notranslate nohighlight">\(n\)</span> vertices and priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>,
the value iteration algorithm over the tree <span class="math notranslate nohighlight">\(T\)</span> returns the maximal progress measure <span class="math notranslate nohighlight">\(\mu\)</span> for <span class="math notranslate nohighlight">\(\game\)</span> over <span class="math notranslate nohighlight">\(T\)</span>.</p>
</div>
</div><p>Thanks to \cref{3-cor:progress_measure}, the maximal progress measure yields a solution for parity games:
Eve wins from <span class="math notranslate nohighlight">\(v\)</span> if and only if <span class="math notranslate nohighlight">\(\mu(v) \neq \bot\)</span>.</p>
</div>
<div class="section" id="complexity-analysis">
<h2>Complexity analysis<a class="headerlink" href="#complexity-analysis" title="Permalink to this headline">¶</a></h2>
<p>The number of times the operator <span class="math notranslate nohighlight">\(\Op_v\)</span> is used is bounded by the number of leaves of <span class="math notranslate nohighlight">\(T\)</span>,
which we write <span class="math notranslate nohighlight">\(|T|\)</span>, implying that the total number of iterations is bounded by <span class="math notranslate nohighlight">\(n \cdot |T|\)</span>.</p>
<p>To determine the overall complexity we need to discuss two aspects of the algorithm:</p>
<ul class="simple">
<li><p>the data structure and in particular the choice of the vertex <span class="math notranslate nohighlight">\(v\)</span> in the loop;</p></li>
<li><p>the computation of <span class="math notranslate nohighlight">\(\Op_v\)</span> and in particular the encoding of branches of <span class="math notranslate nohighlight">\(T\)</span>.</p></li>
</ul>
<p>We note that a vertex <span class="math notranslate nohighlight">\(v \in \VE\)</span> is neglected if and only if all its outgoing edges are neglected,
and a vertex <span class="math notranslate nohighlight">\(v \in \VA\)</span> is neglected if and only if it has a neglected outgoing edge.
Hence checking whether a vertex <span class="math notranslate nohighlight">\(v\)</span> is neglected requires considering all of its outgoing edges <span class="math notranslate nohighlight">\((v,v')\)</span>
and checking whether <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.
Let us write <span class="math notranslate nohighlight">\(\Delta\)</span> for the complexity of checking whether <span class="math notranslate nohighlight">\(\mu(v) \vartriangleleft_{\col(v)} \mu(v')\)</span>.
Hence checking whether <span class="math notranslate nohighlight">\(v\)</span> is neglected costs
<span class="math notranslate nohighlight">\(O(|\Ing^{-1}(v)| \cdot \Delta)\)</span>, where <span class="math notranslate nohighlight">\(|\Ing^{-1}(v)|\)</span> is the number of outgoing edges of <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>A naive implementation of <a class="reference internal" href="#algo-value-iteration"><span class="std std-numref">Fig. 32</span></a> would in each repeat loop go through every vertex <span class="math notranslate nohighlight">\(v\)</span>
to check whether it is neglected.
This would incur a linear cost: <span class="math notranslate nohighlight">\(\sum_{v \in V} O(|\Ing^{-1}(v)| \cdot \Delta) = O(m \cdot \Delta)\)</span>.
Thus the overall complexity would be</p>
<div class="math notranslate nohighlight">
\[
O((m \cdot \Delta) \cdot (n \cdot |T|)) = O(nm \cdot \Delta \cdot |T|).
\]</div>
<p>Typically <span class="math notranslate nohighlight">\(\Delta\)</span> is small (we will see that for a well chosen universal tree <span class="math notranslate nohighlight">\(T\)</span> it is polylogarithmic in <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(d\)</span>),
and <span class="math notranslate nohighlight">\(T\)</span> is the dominating factor (quasipolynomial in <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(d\)</span> thanks to  <a class="reference internal" href="#3-thm:universal_tree">Theorem 82</a>).</p>
<p>We first explain that using a better data structure we can maintain the list of vertices <span class="math notranslate nohighlight">\(v\)</span> such that <span class="math notranslate nohighlight">\(\neg (\mu \le \Op_v(\mu))\)</span>,
saving a linear factor in the complexity.
We then discuss the cost <span class="math notranslate nohighlight">\(\Delta\)</span> by choosing an appropriate encoding of the quasipolynomial universal tree constructed in <a class="reference internal" href="#3-thm:universal_tree">Theorem 82</a>.</p>
</div>
<div class="section" id="data-structure">
<h2>Data structure<a class="headerlink" href="#data-structure" title="Permalink to this headline">¶</a></h2>
<p>We use a data structure similar to the attractor computation presented in Section <a class="reference internal" href="../2_Regular/attractors.html#sec-attractors"><span class="std std-ref">Reachability games</span></a>.
The pseudocode is given in <a class="reference internal" href="#algo-value-iteration-data-structure"><span class="std std-numref">Fig. 33</span></a>.
We did not provide the pseudocode for the functions <span class="math notranslate nohighlight">\(\texttt{Init}\)</span> and <span class="math notranslate nohighlight">\(\texttt{Update}\)</span>.</p>
<p>The data structure consists of the following objects:</p>
<ul class="simple">
<li><p>a leaf of <span class="math notranslate nohighlight">\(T\)</span> for each vertex, representing the current function <span class="math notranslate nohighlight">\(\mu : V \to Y\)</span>;</p></li>
<li><p>a set <span class="math notranslate nohighlight">\(S\)</span> of vertices (each vertex appears at most once in <span class="math notranslate nohighlight">\(S\)</span>, the order in which vertices are stored and retrieved from the set does not matter);</p></li>
<li><p>for each vertex of Eve a number of edges.</p></li>
</ul>
<p>For our complexity analysis we use the unit cost RAM model, see Section <a class="reference internal" href="../1_Introduction/computation.html#sec-computation"><span class="std std-ref">Computational models</span></a> for details.
In the case at hand let us choose for the machine word size <span class="math notranslate nohighlight">\(w = \log(m) + \log(d)\)</span>,
so that an edge together with its priority can be stored in one machine word.
The space complexity of this data structure depends on the encoding of <span class="math notranslate nohighlight">\(T\)</span>, which we will discuss later.</p>
<p>The invariant of the algorithm satisfied before each iteration of the repeat loop is the following:</p>
<ul class="simple">
<li><p>for <span class="math notranslate nohighlight">\(v \in \VA\)</span>, the value of <span class="math notranslate nohighlight">\(\text{number}\)</span>-<span class="math notranslate nohighlight">\(\text{neglected}\)</span>-<span class="math notranslate nohighlight">\(\text{edges}(v)\)</span>
is the number of neglected edges of <span class="math notranslate nohighlight">\(v\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(S\)</span> is the set of neglected vertices.</p></li>
</ul>
<p>The invariant is satisfied initially thanks to the function <span class="math notranslate nohighlight">\(\texttt{Init}\)</span>.
Let us assume that we choose and remove <span class="math notranslate nohighlight">\(v\)</span> from <span class="math notranslate nohighlight">\(S\)</span>.
Since we modify only <span class="math notranslate nohighlight">\(\mu(v)\)</span> the only potentially neglected vertices are in <span class="math notranslate nohighlight">\(S\)</span> (minus <span class="math notranslate nohighlight">\(v\)</span>) and the incoming edges of <span class="math notranslate nohighlight">\(v\)</span>;
for the latter each of them is checked and added to <span class="math notranslate nohighlight">\(S\)</span> when required.
By monotonicity, neglected vertices remain neglected so all vertices in <span class="math notranslate nohighlight">\(S\)</span> (minus <span class="math notranslate nohighlight">\(v\)</span>) are still neglected.
Hence the invariant is satisfied.</p>
<p>The invariant implies that the algorithm indeed implements <a class="reference internal" href="#algo-value-iteration"><span class="std std-numref">Fig. 32</span></a> hence returns the maximal progress measure,
but it also has implications on the complexity.
Indeed one iteration of the repeat loop over some vertex <span class="math notranslate nohighlight">\(v\)</span> involves</p>
<div class="math notranslate nohighlight">
\[
O\left( (|\Ing^{-1}(v)| + |\Out^{-1}(v)|) \cdot \Delta \right)
\]</div>
<p>operations,
the first term corresponds to updating <span class="math notranslate nohighlight">\(\mu(v)\)</span> and <span class="math notranslate nohighlight">\(\text{number}\)</span>-<span class="math notranslate nohighlight">\(\text{neglected}\)</span>-<span class="math notranslate nohighlight">\(\text{edges}(v)\)</span>,
which requires for each outgoing edge of <span class="math notranslate nohighlight">\(v\)</span> to compute <span class="math notranslate nohighlight">\(\delta\)</span>,
and the second term corresponds to considering all incoming edges of <span class="math notranslate nohighlight">\(v\)</span> and treating the neglected ones.
Thus the overall complexity is</p>
<div class="math notranslate nohighlight">
\[
O\left( 
\sum_{v \in V} (|\Ing^{-1}(v)| + |\Out^{-1}(v)|) \cdot \Delta \cdot |T|
\right) 
= O(m \cdot \Delta \cdot |T|).
\]</div>
<div class="figure align-center" id="algo-value-iteration-data-structure">
<img alt="../_images/3-algo:value_iteration_data_structure.png" src="../_images/3-algo:value_iteration_data_structure.png" />
<p class="caption"><span class="caption-number">Fig. 33 </span><span class="caption-text">The value iteration algorithm with explicit data structure.</span><a class="headerlink" href="#algo-value-iteration-data-structure" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="encoding-branches">
<h2>Encoding branches<a class="headerlink" href="#encoding-branches" title="Permalink to this headline">¶</a></h2>
<p>Let us fix <span class="math notranslate nohighlight">\(T\)</span> to be the quasipolynomial universal tree constructed in  <a class="reference internal" href="#3-thm:universal_tree">Theorem 82</a>.</p>
<p>In our definition of trees we say that a tree is an ordered list of subtrees <span class="math notranslate nohighlight">\([t_1,\dots,t_k]\)</span>,
so we use <span class="math notranslate nohighlight">\([1,k]\)</span> with the natural order for ordering the subtrees.
Any other total order can be used to that effect, and a more appropriate order may lead to smaller encoding.
Indeed, using <span class="math notranslate nohighlight">\([1,k]\)</span> for ordering subtrees, if a tree has height <span class="math notranslate nohighlight">\(h\)</span> and <span class="math notranslate nohighlight">\(n\)</span> branches then a branch is a sequence of <span class="math notranslate nohighlight">\(h\)</span> numbers in <span class="math notranslate nohighlight">\([1,n]\)</span>,
so it uses <span class="math notranslate nohighlight">\(O(h \log(n))\)</span> bits.</p>
<p>Let us consider an order well suited for encoding <span class="math notranslate nohighlight">\(T\)</span>.
We use <span class="math notranslate nohighlight">\(\set{0,1}^*\)</span> the set of binary words and order them using the following three rules that apply for any <span class="math notranslate nohighlight">\(u,v \in \set{0,1}^*\)</span>:</p>
<div class="math notranslate nohighlight">
\[
0u &lt; \varepsilon &lt; 1u \quad ; \quad (0u &lt; 0v \Longleftrightarrow u &lt; v) \quad ; \quad (1u &lt; 1v \Longleftrightarrow u &lt; v).
\]</div>
<p>For words of length at most <span class="math notranslate nohighlight">\(2\)</span> the order is <span class="math notranslate nohighlight">\(00 &lt; 0 &lt; 01 &lt; \varepsilon &lt; 10 &lt; 1 &lt; 11\)</span>.</p>
<div class="figure align-center" id="fig-tree-encoded">
<img alt="../_images/3-fig:tree_encoded.png" src="../_images/3-fig:tree_encoded.png" />
<p class="caption"><span class="caption-number">Fig. 34 </span><span class="caption-text">The succinct encoding on the <span class="math notranslate nohighlight">\((5,2)\)</span>-universal tree.</span><a class="headerlink" href="#fig-tree-encoded" title="Permalink to this image">¶</a></p>
</div>
<p>We can now revisit the construction of the universal tree by defining directly the set of branches.
Recall that <span class="math notranslate nohighlight">\(T\)</span> is obtained from <span class="math notranslate nohighlight">\(T_\text{left},T_\text{middle}\)</span>, and <span class="math notranslate nohighlight">\(T_\text{right}\)</span>.
By induction hypothesis branches in <span class="math notranslate nohighlight">\(T_\text{left}\)</span> and <span class="math notranslate nohighlight">\(T_\text{right}\)</span> are tuples of length <span class="math notranslate nohighlight">\(h-1\)</span>
and branches in <span class="math notranslate nohighlight">\(T_\text{middle}\)</span> tuples of length <span class="math notranslate nohighlight">\(h\)</span>.
The branches of <span class="math notranslate nohighlight">\(T\)</span> are:</p>
<ul class="simple">
<li><p>branches of <span class="math notranslate nohighlight">\(T_\text{left}\)</span> where the first component is prefixed with a <span class="math notranslate nohighlight">\(0\)</span>;</p></li>
<li><p>branches of <span class="math notranslate nohighlight">\(T_\text{middle}\)</span> augmented with a new component <span class="math notranslate nohighlight">\(\varepsilon\)</span>;</p></li>
<li><p>branches of <span class="math notranslate nohighlight">\(T_\text{right}\)</span> where the first component is prefixed with a <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
</ul>
<p>We call this encoding the succinct encoding, it is illustrated in <a class="reference internal" href="#fig-tree-encoded"><span class="std std-numref">Fig. 34</span></a> for the <span class="math notranslate nohighlight">\((5,2)\)</span>-universal tree.
The leftmost branch is <span class="math notranslate nohighlight">\((00,\varepsilon)\)</span>, and the middle branch <span class="math notranslate nohighlight">\((\varepsilon,\varepsilon)\)</span>.
In general, the inductive construction implies that every branch is a tuple <span class="math notranslate nohighlight">\((D_{d-1},\dots,D_1)\)</span>
such that the sum of the lengths of the directions <span class="math notranslate nohighlight">\(D_i\)</span> is at most <span class="math notranslate nohighlight">\(\log(n)\)</span>.
Thus a branch is encoded using <span class="math notranslate nohighlight">\(O(\log(h) \log(n))\)</span> bits: for each of the <span class="math notranslate nohighlight">\(\log(n)\)</span> bits we need <span class="math notranslate nohighlight">\(\log(h)\)</span> bits to specify its component.</p>
<p>In terms of machine words of size <span class="math notranslate nohighlight">\(w = \log(n) + \log(d)\)</span>, this means that a branch can be stored using <span class="math notranslate nohighlight">\(\log(d)\)</span> machine words.
Hence the data structure uses <span class="math notranslate nohighlight">\(O(n \log(d))\)</span> machine words, with together with the input size <span class="math notranslate nohighlight">\(O(m)\)</span>
means that the space complexity of the algorithm is <span class="math notranslate nohighlight">\(O(m + n \log(d))\)</span>.</p>
<p>Using the succinct encoding and a tedious but simple case analysis we can compute <span class="math notranslate nohighlight">\(\delta(b,p)\)</span> in time <span class="math notranslate nohighlight">\(O(\log(n) \log(d))\)</span>.
Putting everything together we obtain the overall complexity</p>
<div class="math notranslate nohighlight">
\[
O\left(nm \log(n) \log(d) \cdot  \binom{\lceil \log(n) \rceil + d/2 - 1}{\lceil \log(n) \rceil} \right),
\]</div>
<p>as stated in  <a class="reference internal" href="#3-thm:value_iteration_quasipoly">Theorem 80</a>.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./3_Parity"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="separation.html" title="previous page">A quasipolynomial time separating automata algorithm</a>
    <a class='right-next' id="next-link" href="relationships.html" title="next page">Comparing the three families of algorithms</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>