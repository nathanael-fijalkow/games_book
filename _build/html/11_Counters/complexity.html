
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The complexity of asymmetric monotone games &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Bibliographic references" href="references.html" />
    <link rel="prev" title="Resource-conscious games" href="resource.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../1_Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../2_Regular/index.html">
   Regular Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/attractors.html">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/buchi.html">
     BÃ¼chi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../3_Parity/index.html">
   Parity Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Games with Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../5_MDP/index.html">
   Markov Decision Processes
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reachability.html">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../6_Stochastic/index.html">
   Stochastic Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/determinacy.html">
     Positional determinacy of stochastic reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/relations.html">
     Relations between all games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/algos.html">
     Algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Information
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../7_Concurrent/index.html">
   Concurrent Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/matrix_games.html">
     Matrix games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/reachability.html">
     Concurrent reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/mean_payoff.html">
     Concurrent mean-payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/references.html">
     Bibilographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../8_Imperfect/index.html">
   Games with Signals
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/finite_duration.html">
     Finite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/infinite_duration.html">
     Infinite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Infinite
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../9_Timed/index.html">
   Timed Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/state_space_representation.html">
     State-Space Representation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/controllable_predecessor_operator.html">
     Controllable-Predecessor Operator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/backward_algorithm.html">
     Backward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/forward_algorithm.html">
     Forward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../9_Timed/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../10_Pushdown/index.html">
   Pushdown Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/profiles.html">
     Profiles and regularity of the winning regions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/parity.html">
     Parity pushdown games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Games with Counters
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="counters.html">
     Vector games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="dim1.html">
     Games in dimension one
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="avag.html">
     Asymmetric games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="resource.html">
     Resource-conscious games
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     The complexity of asymmetric monotone games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Multi
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../12_Multiobjectives/index.html">
   Games with multiple objectives
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/mean_payoff_energy.html">
     Mean-payoff and energy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/total_payoff_shortest_path.html">
     Total-payoff and shortest path
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/beyond_worst_case.html">
     Beyond worst-case synthesis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/percentile.html">
     Percentile queries
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../13_Multiplayer/index.html">
   Multiplayer Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/nash_equilibria_normal_form.html">
     Nash Equilibria for games in normal form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/admissible_strategies.html">
     Admissible strategies
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#upper-bounds">
   Upper Bounds
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#existential-initial-credit">
     Existential Initial Credit
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#given-initial-credit">
     Given Initial Credit
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lower-bounds">
   Lower Bounds
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id2">
     Existential Initial Credit
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id3">
     Given Initial Credit
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dimension-one">
   Dimension One
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="the-complexity-of-asymmetric-monotone-games">
<span id="sec-complexity"></span><h1>The complexity of asymmetric monotone games<a class="headerlink" href="#the-complexity-of-asymmetric-monotone-games" title="Permalink to this headline">Â¶</a></h1>
<p>Unlike general vector games and configuration reachability
asymmetric ones, coverability, non-termination, and
parity asymmetric vector games are decidable.
We survey in this section the best known complexity bounds for every
case; see <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">11-tbl:cmplx</span></code> at the end of the chapter for a summary.</p>
<div class="section" id="upper-bounds">
<span id="sec-up"></span><h2>Upper Bounds<a class="headerlink" href="#upper-bounds" title="Permalink to this headline">Â¶</a></h2>
<p>We begin with complexity upper bounds.  The main results are that
parity games with existential initial credit
can be solved in  \textrm{coNP}, but are in  \textrm{kEXP}[2] with given initial
credit.  In both cases however, the complexity is pseudo-polynomial
if both the dimension <span class="math notranslate nohighlight">\(k\)</span> and the number of priorities <span class="math notranslate nohighlight">\(d\)</span> are
fixed, which is rather good news: one can hope that, in practice, both
the number of different resources (encoded by the counters) and the
complexity of the functional specification (encoded by the parity
condition) are tiny compared to the size of the system.</p>
<div class="section" id="existential-initial-credit">
<span id="sec-up-exist"></span><h3>Existential Initial Credit<a class="headerlink" href="#existential-initial-credit" title="Permalink to this headline">Â¶</a></h3>
<blockquote>
<div><p><strong>Counterless Strategies</strong></p>
</div></blockquote>
<p>Consider a strategy <span class="math notranslate nohighlight">\(\tau\)</span> of Adam in a vector game.  In all the
games we consider, uniform positional strategies suffice over the
infinite arena <span class="math notranslate nohighlight">\(\mathcal{A}_\mathbb{N}(\mathcal{V})=(V,E, V_\mathrm{Eve}, V_\mathrm{Adam})\)</span>: <span class="math notranslate nohighlight">\(\tau\)</span> maps vertices
in <span class="math notranslate nohighlight">\(V\)</span> to edges in <span class="math notranslate nohighlight">\(E\)</span>.  We call <span class="math notranslate nohighlight">\(\tau\)</span> counterless if, for all
locations <span class="math notranslate nohighlight">\(\ell\in \mathcal{L}_\mathrm{Adam}\)</span> and all vectors
<span class="math notranslate nohighlight">\(\vec v,\vec v'\in\mathbb{N}^ k\)</span>, <span class="math notranslate nohighlight">\(\tau( \ell(\vec v))=\tau( \ell(\vec v'))\)</span>.
A counterless strategy thus only considers the current location of
the play.</p>
<div class="proof lemma admonition" id="11-lem:counterless">
<p class="admonition-title"><span class="caption-number">Lemma 341 </span> (Counterless strategies)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\mathcal{V}=( \mathcal{L}, A, \mathcal{L}_\mathrm{Eve}, \mathcal{L}_\mathrm{Adam}, k)\)</span> be an asymmetric
vector system, <span class="math notranslate nohighlight">\(\ell_0\in \mathcal{L}\)</span> be a location, and
<span class="math notranslate nohighlight">\(\mathrm{lcol}{:}\, \mathcal{L}\to\{1,\dots,d\}\)</span> be a location colouring.  If Adam
wins from <span class="math notranslate nohighlight">\(\ell_0(\vec v)\)</span> for every initial credit <span class="math notranslate nohighlight">\(\vec v\)</span> in the
parity game played over <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> with <span class="math notranslate nohighlight">\(\mathrm{lcol}\)</span>, then
he has a single counterless strategy such that he wins from
<span class="math notranslate nohighlight">\(\ell_0(\vec v)\)</span> for every initial credit <span class="math notranslate nohighlight">\(\vec v\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Let <span class="math notranslate nohighlight">\(A_\mathrm{Adam}  \stackrel{\!\,\!\,\textrm{def}}{=}\{( \ell \xrightarrow{\,\vec
    u\,} \ell')\in A\mid \ell\in \mathcal{L}_\mathrm{Adam}\}\)</span> be the set of actions
controlled by Adam.  We assume without loss of generality that
every location <span class="math notranslate nohighlight">\(\ell\in \mathcal{L}_\mathrm{Adam}\)</span> has either one or two outgoing
actions, thus <span class="math notranslate nohighlight">\(| \mathcal{L}_\mathrm{Adam}|\leq| A_\mathrm{Adam}|\leq
  2| \mathcal{L}_\mathrm{Adam}|\)</span>.  We proceed by induction over <span class="math notranslate nohighlight">\(| A_\mathrm{Adam}|\)</span>.  For
the base case, if <span class="math notranslate nohighlight">\(| A_\mathrm{Adam}|=| \mathcal{L}_\mathrm{Adam}|\)</span> then every location
controlled by Adam has a single outgoing action, thus any
strategy for Adam is trivially counterless.</p>
<p>For the induction step, consider some location
<span class="math notranslate nohighlight">\(\hat \ell\in \mathcal{L}_\mathrm{Adam}\)</span> with two outgoing actions
<span class="math notranslate nohighlight">\(a_l  \stackrel{\!\,\!\,\textrm{def}}{=}\hat \ell \xrightarrow{\,\vec 0\,} \ell_l\)</span> and
<span class="math notranslate nohighlight">\(a_r  \stackrel{\!\,\!\,\textrm{def}}{=}\hat \ell \xrightarrow{\,\vec 0\,} \ell_r\)</span>.  Let <span class="math notranslate nohighlight">\(\mathcal{V}_l\)</span> and <span class="math notranslate nohighlight">\(\mathcal{V}_r\)</span> be
the vector systems obtained from <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> by removing
respectively <span class="math notranslate nohighlight">\(a_r\)</span> and <span class="math notranslate nohighlight">\(a_l\)</span> from <span class="math notranslate nohighlight">\(A\)</span>, i.e., by using
<span class="math notranslate nohighlight">\(A_l  \stackrel{\!\,\!\,\textrm{def}}{=} A\setminus\{a_r\}\)</span> and
<span class="math notranslate nohighlight">\(A_r  \stackrel{\!\,\!\,\textrm{def}}{=} A\setminus\{a_l\}\)</span>.  If <span class="math notranslate nohighlight">\(\textrm{Adam}\)</span> wins the
parity game from <span class="math notranslate nohighlight">\(\ell(\vec v)\)</span> for every
initial credit <span class="math notranslate nohighlight">\(\vec v\)</span> in either <span class="math notranslate nohighlight">\(\mathcal{V}_l\)</span> or <span class="math notranslate nohighlight">\(\mathcal{V}_r\)</span>, then by
induction hypothesis he has a counterless winning strategy winning
from <span class="math notranslate nohighlight">\(\ell(\vec v)\)</span> for every initial credit <span class="math notranslate nohighlight">\(\vec v\)</span>, and the same
strategy is winning in <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> from <span class="math notranslate nohighlight">\(\ell(\vec v)\)</span> for every initial
credit <span class="math notranslate nohighlight">\(\vec v\)</span>.</p>
<p>In order to conclude the proof, we show that, if Adam loses in
<span class="math notranslate nohighlight">\(\mathcal{V}_l\)</span> from <span class="math notranslate nohighlight">\(\ell_0(\vec v_l)\)</span> for some <span class="math notranslate nohighlight">\(\vec v_l\in\mathbb{N}^ k\)</span> and in
<span class="math notranslate nohighlight">\(\mathcal{V}_r\)</span> from <span class="math notranslate nohighlight">\(\ell_0(\vec v_r)\)</span> for some <span class="math notranslate nohighlight">\(\vec v_r\in\mathbb{N}^ k\)</span>, then
there exists <span class="math notranslate nohighlight">\(\vec v_0\in\mathbb{N}^ k\)</span> such that Eve wins from
<span class="math notranslate nohighlight">\(\ell_0(\vec v_0)\)</span> in <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.  Let <span class="math notranslate nohighlight">\(\sigma_l\)</span> and <span class="math notranslate nohighlight">\(\sigma_r\)</span> denote
Eveâs winning strategies in the two games.  By a slight abuse of
notations (justified by the fact that we are only interested in a
few initial vertices), we see plays as sequences of actions and
strategies as maps <span class="math notranslate nohighlight">\(A^\ast\to A\)</span>.\todoquestion{I hope this is not too messy}  Consider the set of
plays consistent with <span class="math notranslate nohighlight">\(\sigma_r\)</span> starting from <span class="math notranslate nohighlight">\(\ell_0(\vec v_r)\)</span>.
If none of those plays visits <span class="math notranslate nohighlight">\(\hat \ell\)</span>, then <span class="math notranslate nohighlight">\(\textrm{Eve}\)</span> wins in <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>
from <span class="math notranslate nohighlight">\(\ell_0(\vec v_r)\)</span> and we conclude.  Otherwise, there is some
finite prefix <span class="math notranslate nohighlight">\(\hat\pi\)</span> of a play that
visits <span class="math notranslate nohighlight">\(\hat \ell(\hat{\vec v})\)</span> for some vector
<span class="math notranslate nohighlight">\(\hat{\vec v}=\vec v_r+ w(\hat\pi)\)</span>.  We let
<span class="math notranslate nohighlight">\(\vec v_0  \stackrel{\!\,\!\,\textrm{def}}{=}\vec v_l+\hat{\vec v}\)</span> and show that Eve wins from
<span class="math notranslate nohighlight">\(\ell_0(\vec v_0)\)</span>.</p>
<p>\begin{scope}    We define now a strategy <span class="math notranslate nohighlight">\(\sigma\)</span> for <span class="math notranslate nohighlight">\(\textrm{Eve}\)</span> over <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> that
switches between applying <span class="math notranslate nohighlight">\(\sigma_l\)</span> and <span class="math notranslate nohighlight">\(\sigma_r\)</span> each time
<span class="math notranslate nohighlight">\(a_r\)</span> is used and switches back each time <span class="math notranslate nohighlight">\(a_l\)</span> is used.  More
precisely, given a finite or infinite sequence <span class="math notranslate nohighlight">\(\pi\)</span> of actions,
we decompose <span class="math notranslate nohighlight">\(\pi\)</span> as <span class="math notranslate nohighlight">\(\pi_1 a_1 \pi_2 a_2 \pi_3\cdots\)</span> where each
segment <span class="math notranslate nohighlight">\(\pi_j\in( A\setminus\{a_l,a_r\})^\ast\)</span> does not use
either <span class="math notranslate nohighlight">\(a_l\)</span> nor <span class="math notranslate nohighlight">\(a_r\)</span> and each <span class="math notranslate nohighlight">\(a_j\in\{a_l,a_r\}\)</span>.  The
associated mode <span class="math notranslate nohighlight">\(m(j)\in\{l,r\}\)</span> of a segment <span class="math notranslate nohighlight">\(\pi_j\)</span>
is <span class="math notranslate nohighlight">\(m(1)  \stackrel{\!\,\!\,\textrm{def}}{=} l\)</span> for the initial segment and otherwise
<span class="math notranslate nohighlight">\(m(j)  \stackrel{\!\,\!\,\textrm{def}}{=} l\)</span> if <span class="math notranslate nohighlight">\(e_{j-1}=a_l\)</span> and <span class="math notranslate nohighlight">\(m(j)  \stackrel{\!\,\!\,\textrm{def}}{=} r\)</span> otherwise.  The
<span class="math notranslate nohighlight">\(l\)</span>-subsequence associated with <span class="math notranslate nohighlight">\(\pi\)</span> is the sequence of segments
<span class="math notranslate nohighlight">\(\pi(l)  \stackrel{\!\,\!\,\textrm{def}}{=}\pi_{l_1}a_{l_2-1}\pi_{l_2}a_{l_3-1}\pi_{l_3}\cdots\)</span>
with mode <span class="math notranslate nohighlight">\(m(l_i)=l\)</span>, while the <span class="math notranslate nohighlight">\(r\)</span>-subsequence is the sequence
<span class="math notranslate nohighlight">\(\pi(r)  \stackrel{\!\,\!\,\textrm{def}}{=}\hat\pi a_{r_1-1}\pi_{r_1}a_{r_2-1}\pi_{r_2}\cdots\)</span>
with mode <span class="math notranslate nohighlight">\(m(r_i)=r\)</span> prefixed by <span class="math notranslate nohighlight">\(\hat\pi\)</span>.  Then we let
<span class="math notranslate nohighlight">\(\sigma(\pi)  \stackrel{\!\,\!\,\textrm{def}}{=}\sigma_{m}(\pi(m))\)</span> where <span class="math notranslate nohighlight">\(m\in\{l,r\}\)</span> is the
mode of the last segment of <span class="math notranslate nohighlight">\(\pi\)</span>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Consider an infinite play $\pi$ consistent with $\sigma$ starting
from $\ell_0(\vec v_0)$.  Since $\vec v_0\geq\vec v_l$ and
$\vec v_0\geq \vec v_r+ w(\hat\pi)$, $\pi(l)$ and $\pi(r)$
starting from $\ell_0(\vec v_0)$ are consistent with
simulating---in the sense of {prf:ref}`11-lem:mono`---$\sigma_l$
from $\ell_0(\vec v_l)$ and $\sigma_r$ from $\ell_0(\vec v_r)$.
Let $\pi&#39;$ be a finite prefix of $\pi$.  Then
$w(\pi&#39;)= w(\pi&#39;(l))+ w(\pi&#39;(r))$ where $\pi&#39;(l)$
is a prefix of $\pi(l)$ and $\pi&#39;(r)$ of $\pi(r)$, thus
$w(\pi&#39;(l))\leq\vec v_l$ and
$w(\pi&#39;(r))\leq\vec v_r+ w(\hat\pi)$, thus
$w(\pi&#39;)\leq\vec v_0$: the play $\pi$ avoids the sink.
Furthermore, the maximal priority seen infinitely often along
$\pi(l)$ and $\pi(r)$ is even (note that one of $\pi(l)$
and $\pi(r)$ might not be infinite), thus the maximal priority
seen infinitely often along $\pi$ is also even.  This shows
that $\sigma$ is winning for Eve from $\ell_0(\vec v_0)$.\todoquestion{Is
that clear?}
</pre></div>
</div>
<p>\end{scope}</p>
</div>
<p>We are going to exploit <a class="reference internal" href="#11-lem:counterless">Lemma 341</a>
in <a class="reference internal" href="#11-th:exist-easy">Theorem 346</a> in order to prove a  \textrm{coNP}\ upper bound for
asymmetric games with existential initial credit: it suffices in
order to decide those games to guess a counterless winning
strategy <span class="math notranslate nohighlight">\(\tau\)</span> for Adam and check that it is indeed winning by
checking that Eve loses the one-player game arising from <span class="math notranslate nohighlight">\(\tau\)</span>.
This last step requires an algorithmic result of independent interest.</p>
<blockquote>
<div><p><strong>One-player Case</strong></p>
</div></blockquote>
<p>Let <span class="math notranslate nohighlight">\(\mathcal{V}=( \mathcal{L}, A, k)\)</span> be a vector addition system with states,
<span class="math notranslate nohighlight">\(\mathrm{lcol}{:}\, \mathcal{L}\to\{1,\dots,d\}\)</span> a location colouring, and
<span class="math notranslate nohighlight">\(\ell_0\in \mathcal{L}\)</span> an initial location.  Then Eve wins the
parity one-player game from <span class="math notranslate nohighlight">\(\ell_0(\vec v_0)\)</span>
for some initial credit <span class="math notranslate nohighlight">\(\vec v_0\)</span> if and only if there exists some
location such that</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\ell\)</span> is reachable from <span class="math notranslate nohighlight">\(\ell_0\)</span> in the directed graph
underlying <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> and</p></li>
<li><p>there is a cycle <span class="math notranslate nohighlight">\(\pi\in A^\ast\)</span> from <span class="math notranslate nohighlight">\(\ell\)</span> to itself such
that <span class="math notranslate nohighlight">\(w(\pi)\geq 0\)</span> and the maximal priority occurring
along <span class="math notranslate nohighlight">\(\pi\)</span> is even.</p></li>
</ul>
<p>Indeed, assume we can find such a location <span class="math notranslate nohighlight">\(\ell\)</span>.  Let
<span class="math notranslate nohighlight">\(\hat\pi\in A^\ast\)</span> be a path from <span class="math notranslate nohighlight">\(\ell_0\)</span> to <span class="math notranslate nohighlight">\(\ell\)</span> and <span class="math notranslate nohighlight">\(\vec
v_0(i)  \stackrel{\!\,\!\,\textrm{def}}{=}\max\{\| w(\pi')\|\mid\pi'\text{ is a prefix of
}\hat\pi\pi\}\)</span> for all <span class="math notranslate nohighlight">\(1\leq i\leq k\)</span>.  Then <span class="math notranslate nohighlight">\(\ell_0(\vec v_0)\)</span> can
reach <span class="math notranslate nohighlight">\(\ell(\vec v_0+ w(\hat\pi))\)</span> in the natural semantics
of <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> by following <span class="math notranslate nohighlight">\(\hat\pi\)</span>, and then <span class="math notranslate nohighlight">\(\ell(\vec v_0+\vec
W(\hat\pi)+n w(\pi))\geq  \ell(\vec v_0+ w(\hat\pi))\)</span> after
<span class="math notranslate nohighlight">\(n\)</span> repetitions of the cycle <span class="math notranslate nohighlight">\(\pi\)</span>.  The infinite play arising from
this strategy has an even maximal priority.</p>
<p>Conversely, if Eve wins, then there is a winning play
<span class="math notranslate nohighlight">\(\pi\in A^\omega\)</span> from <span class="math notranslate nohighlight">\(\ell_0(\vec v_0)\)</span> for some <span class="math notranslate nohighlight">\(\vec v_0\)</span>.
Recall that <span class="math notranslate nohighlight">\((V,{\leq})\)</span> is a wqo, and we argue as in
<a class="reference internal" href="avag.html#11-lem:finmem">Lemma 333</a> that there is indeed such a location <span class="math notranslate nohighlight">\(\ell\)</span>.</p>
<p>Therefore, solving one-player parity vector games boils down to
determining the existence of a cycle with non-negative effect and even
maximal priority.  We shall use linear programming techniques in order
to check the existence of such a cycle in polynomial
time <span id="id1">[<span>Kosaraju&amp;Sullivan:1988</span>]</span>.</p>
<p>\begin{scope}
Let us start with a relaxed problem: we call a
multi-cycle a non-empty finite set of cycles <span class="math notranslate nohighlight">\(\Pi\)</span> and let
<span class="math notranslate nohighlight">\(w(\Pi)  \stackrel{\!\,\!\,\textrm{def}}{=}\sum_{\pi\in\Pi} w(\pi)\)</span> be its weight; we write
<span class="math notranslate nohighlight">\(t\in\Pi\)</span> if <span class="math notranslate nohighlight">\(t\in\pi\)</span> for some <span class="math notranslate nohighlight">\(\pi\in\Pi\)</span>.
Let <span class="math notranslate nohighlight">\(M\in 2^{ A}\)</span> be a set of mandatory subsets of actions and
<span class="math notranslate nohighlight">\(F\subseteq A\)</span> a set of forbidden actions.  Then we say that
<span class="math notranslate nohighlight">\(\Pi\)</span> is non-negative if <span class="math notranslate nohighlight">\(w(\Pi)\geq\vec 0\)</span>, and that it is
suitable for <span class="math notranslate nohighlight">\((M,F)\)</span> if for all <span class="math notranslate nohighlight">\(A'\in M\)</span> there exists
<span class="math notranslate nohighlight">\(t\in A'\)</span> such that <span class="math notranslate nohighlight">\(t\in\Pi\)</span>, and if for all <span class="math notranslate nohighlight">\(t\in F\)</span>,
<span class="math notranslate nohighlight">\(t\not\in\Pi\)</span>.  We use the same terminology for a single cycle <span class="math notranslate nohighlight">\(\pi\)</span>.</p>
<div class="proof lemma admonition" id="11-lem:zmulticycle">
<p class="admonition-title"><span class="caption-number">Lemma 342 </span> (Linear programs for suitable non-negative multi-cycles)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> be a vector addition system with states,
<span class="math notranslate nohighlight">\(M\in 2^{ A}\)</span>, and <span class="math notranslate nohighlight">\(F\subseteq A\)</span>.  We can check in polynomial
time whether <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> contains a non-negative multi-cycle <span class="math notranslate nohighlight">\(\Pi\)</span>
suitable for <span class="math notranslate nohighlight">\((M,F)\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We reduce the problem to solving a linear program.  For a
location <span class="math notranslate nohighlight">\(\ell\)</span>, let
<span class="math notranslate nohighlight">\(\mathrm{in}( \ell)  \stackrel{\!\,\!\,\textrm{def}}{=}\{( \ell' \xrightarrow{\,\vec u\,} \ell)\in A\mid
   \ell'\in \mathcal{L}\}\)</span>
and
<span class="math notranslate nohighlight">\(\mathrm{out}( \ell)  \stackrel{\!\,\!\,\textrm{def}}{=}\{( \ell \xrightarrow{\,\vec u\,} \ell')\in A\mid
   \ell'\in \mathcal{L}\}\)</span> be its sets of incoming and outgoing actions.  The
linear program has a variable <span class="math notranslate nohighlight">\(x_a\)</span> for each action <span class="math notranslate nohighlight">\(a\in A\)</span>,
which represents the number of times the action <span class="math notranslate nohighlight">\(a\)</span> occurs in
the multi-cycle.  It consists of the following contraints:</p>
<div class="math notranslate nohighlight">
\[\begin{split}    \forall \ell&amp;\in \mathcal{L},&amp;\sum_{a\in\mathrm{in}( \ell)}x_a&amp;=\sum_{a\in\mathrm{out}( \ell)}x_a\;,\tag{multi-cycle}\\
    \forall a&amp;\in A,&amp;x_a&amp;\geq 0\;,\tag{non-negative uses}\\
    \forall i&amp;\in\{1,\dots, k\},&amp;\sum_{a\in A} x_a\cdot w(t)(i)&amp;\geq
                                            0\;,\tag{non-negative weight}\\
    &amp;&amp;\sum_{a\in A}x_a&amp;\geq 0\tag{non empty}\\
    \forall  A'&amp;\in M,&amp;\sum_{a\in A'}x_a&amp;\geq 0\;,\tag{every subset
                                               in $M$ is used}\\
    \forall a&amp;\in F,&amp;x_a&amp;= 0\;.\tag{no forbidden actions}
  
\end{split}\]</div>
<p>As solving a linear program is in polynomial time {cite}``\todoquestion{agree
on a ref with Chapter <a class="reference internal" href="../8_Imperfect/index.html#chap-signal"><span class="std std-ref">Games with Signals</span></a>?}, the result follows.</p>
</div>
<p>Of course, what we are aiming for is finding a non-negative
<strong>cycle</strong> suitable for <span class="math notranslate nohighlight">\((M,F)\)</span> rather than a multi-cycle.
Let us define for this the relation <span class="math notranslate nohighlight">\(\ell\sim \ell'\)</span> over <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> if
<span class="math notranslate nohighlight">\(\ell= \ell'\)</span> or if there exists a non-negative multi-cycle <span class="math notranslate nohighlight">\(\Pi\)</span>
suitable for <span class="math notranslate nohighlight">\((M,F)\)</span> such that <span class="math notranslate nohighlight">\(\ell\)</span> and <span class="math notranslate nohighlight">\(\ell'\)</span> belong to some
cycle <span class="math notranslate nohighlight">\(\pi\in\Pi\)</span>.
\begin{claim}\label{11-cl:sim} The relation <span class="math notranslate nohighlight">\(\sim\)</span> is an equivalence
relation.\end{claim}</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Symmetry and reflexivity are trivial, and if <span class="math notranslate nohighlight">\(\ell\sim \ell'\)</span> and
<span class="math notranslate nohighlight">\(\ell'\sim \ell''\)</span> because <span class="math notranslate nohighlight">\(\ell\)</span> and <span class="math notranslate nohighlight">\(\ell'\)</span> appear in some cycle
<span class="math notranslate nohighlight">\(\pi\in\Pi\)</span> and <span class="math notranslate nohighlight">\(\ell'\)</span> and <span class="math notranslate nohighlight">\(\ell''\)</span> in some cycle <span class="math notranslate nohighlight">\(\pi'\in\Pi'\)</span> for
two non-negative multi-cycles <span class="math notranslate nohighlight">\(\Pi\)</span> and <span class="math notranslate nohighlight">\(\Pi'\)</span> suitable
for <span class="math notranslate nohighlight">\((M,F)\)</span>, then up to a circular shift <span class="math notranslate nohighlight">\(\pi\)</span> and <span class="math notranslate nohighlight">\(\pi'\)</span> can be
assumed to start and end with <span class="math notranslate nohighlight">\(\ell'\)</span>, and then
<span class="math notranslate nohighlight">\((\Pi\setminus\{\pi\})\cup(\Pi'\setminus\{\pi'\})\cup\{\pi\pi'\}\)</span> is
also a non-negative multi-cycle suitable for <span class="math notranslate nohighlight">\((M,F)\)</span>.</p>
</div>
<p>Thus <span class="math notranslate nohighlight">\(\sim\)</span> defines a partition <span class="math notranslate nohighlight">\(\mathcal{L}/{\sim}\)</span> of <span class="math notranslate nohighlight">\(\mathcal{L}\)</span>.
In order to find a non-negative cycle <span class="math notranslate nohighlight">\(\pi\)</span> suitable for <span class="math notranslate nohighlight">\((M,F)\)</span>,
we are going to compute the partition <span class="math notranslate nohighlight">\(\mathcal{L}/{\sim}\)</span> of <span class="math notranslate nohighlight">\(\mathcal{L}\)</span>
according to <span class="math notranslate nohighlight">\(\sim\)</span>.  If we obtain a partition with a single
equivalence class, we are done: there exists such a cycle.  Otherwise,
such a cycle if it exists must be included in one of the subsystems
<span class="math notranslate nohighlight">\((P, A\cap(P\times\mathbb{Z}^ k\times P), k)\)</span> induced by the equivalence
classes <span class="math notranslate nohighlight">\(P\in \mathcal{L}/{\sim}\)</span>.  This yields <a class="reference internal" href="#algo-zcycle"><span class="std std-numref">Fig. 90</span></a>, which
assumes that we know how to compute the partition <span class="math notranslate nohighlight">\(\mathcal{L}/{\sim}\)</span>.  Note
that the depth of the recursion in <a class="reference internal" href="#algo-zcycle"><span class="std std-numref">Fig. 90</span></a> is bounded
by <span class="math notranslate nohighlight">\(| \mathcal{L}|\)</span> and that recursive calls operate over disjoint subsets
of <span class="math notranslate nohighlight">\(\mathcal{L}\)</span>, thus assuming that we can compute the partition in
polynomial time, then <a class="reference internal" href="#algo-zcycle"><span class="std std-numref">Fig. 90</span></a> also works in polynomial
time.</p>
<div class="figure align-center" id="algo-zcycle">
<img alt="../_images/11-algo:zcycle.png" src="../_images/11-algo:zcycle.png" />
<p class="caption"><span class="caption-number">Fig. 90 </span><span class="caption-text"><span class="math notranslate nohighlight">\(\text{cycle}(\mathcal{V},M,F)\)</span></span><a class="headerlink" href="#algo-zcycle" title="Permalink to this image">Â¶</a></p>
</div>
<p>It remains to see how to compute the partition <span class="math notranslate nohighlight">\(\mathcal{L}/{\sim}\)</span>. Consider
for this the set of actions
<span class="math notranslate nohighlight">\(A'  \stackrel{\!\,\!\,\textrm{def}}{=}\{a\mid\exists\Pi\text{ a non-negative multi-cycle
  suitable for \)</span>(M,F)<span class="math notranslate nohighlight">\( with \)</span>a\in\Pi<span class="math notranslate nohighlight">\(}\}\)</span> and
<span class="math notranslate nohighlight">\(\mathcal{V}'=( \mathcal{L}', A', k)\)</span> the subsystem induced by <span class="math notranslate nohighlight">\(A'\)</span>.
\begin{claim}
\label{11-cl:part}
There exists a path from <span class="math notranslate nohighlight">\(\ell\)</span> to <span class="math notranslate nohighlight">\(\ell'\)</span> in <span class="math notranslate nohighlight">\(\mathcal{V}'\)</span>
if and only if <span class="math notranslate nohighlight">\(\ell\sim \ell'\)</span>.
\end{claim}</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>If <span class="math notranslate nohighlight">\(\ell\sim \ell'\)</span>, then either <span class="math notranslate nohighlight">\(\ell= \ell'\)</span> and there is an empty
path, or there exist <span class="math notranslate nohighlight">\(\Pi\)</span> and <span class="math notranslate nohighlight">\(\pi\in\Pi\)</span> such that <span class="math notranslate nohighlight">\(\ell\)</span>
and <span class="math notranslate nohighlight">\(\ell'\)</span> belong to <span class="math notranslate nohighlight">\(\pi\)</span> and <span class="math notranslate nohighlight">\(\Pi\)</span> is a non-negative
multi-cycle suitable for <span class="math notranslate nohighlight">\((M,F)\)</span>, thus every action of <span class="math notranslate nohighlight">\(\pi\)</span> is
in <span class="math notranslate nohighlight">\(A'\)</span> and there is a path in <span class="math notranslate nohighlight">\(\mathcal{V}'\)</span>.</p>
<p>Conversely, if there is a path <span class="math notranslate nohighlight">\(\pi\in{ A'}^\ast\)</span> from <span class="math notranslate nohighlight">\(\ell\)</span>
to <span class="math notranslate nohighlight">\(\ell'\)</span>, then <span class="math notranslate nohighlight">\(\ell\sim \ell'\)</span> by induction on <span class="math notranslate nohighlight">\(\pi\)</span>.  Indeed, if
<span class="math notranslate nohighlight">\(|\pi|=0\)</span> then <span class="math notranslate nohighlight">\(\ell= \ell'\)</span>.  For the induction step, <span class="math notranslate nohighlight">\(\pi=\pi' a\)</span>
with <span class="math notranslate nohighlight">\(\pi'\in{ A'}^\ast\)</span> a path from <span class="math notranslate nohighlight">\(\ell\)</span> to <span class="math notranslate nohighlight">\(\ell''\)</span> and
<span class="math notranslate nohighlight">\(a=( \ell'' \xrightarrow{\,\vec u\,} \ell')\in A'\)</span> for some <span class="math notranslate nohighlight">\(\vec u\)</span>.  By
induction hypothesis, <span class="math notranslate nohighlight">\(\ell\sim \ell''\)</span> and since <span class="math notranslate nohighlight">\(a\in A'\)</span>,
<span class="math notranslate nohighlight">\(\ell''\sim \ell'\)</span>, thus <span class="math notranslate nohighlight">\(\ell\sim \ell'\)</span> by transitivity shown
in <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">11-cl:sim</span></code>.</p>
</div>
<p>By <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">11-cl:part</span></code>, the equivalence classes of <span class="math notranslate nohighlight">\(\sim\)</span> are the
strongly connected components of <span class="math notranslate nohighlight">\(\mathcal{V}'\)</span>.  This yields the following
polynomial time algorithm for computing <span class="math notranslate nohighlight">\(\mathcal{L}/{\sim}\)</span>.</p>
<div class="figure align-center" id="algo-part">
<img alt="../_images/11-algo:part.png" src="../_images/11-algo:part.png" />
<p class="caption"><span class="caption-number">Fig. 91 </span><span class="caption-text"><span class="math notranslate nohighlight">\(\text{partition}(\mathcal{V},M,F)\)</span></span><a class="headerlink" href="#algo-part" title="Permalink to this image">Â¶</a></p>
</div>
<p>Together, <a class="reference internal" href="#11-lem:zmulticycle">Lemma 342</a>
and <code class="xref std std-numref docutils literal notranslate"><span class="pre">11-algo:part,11-algo:zcycle</span></code> yield the following.</p>
<div class="proof lemma admonition" id="11-lem:zcycle">
<p class="admonition-title"><span class="caption-number">Lemma 343 </span> (Polynomial-time detection of suitable non-negative cycles)</p>
<div class="lemma-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> be a vector addition system with states,
<span class="math notranslate nohighlight">\(M\in 2^{ A}\)</span>, and <span class="math notranslate nohighlight">\(F\subseteq A\)</span>.  We can check in polynomial
time whether <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> contains a non-negative cycle <span class="math notranslate nohighlight">\(\pi\)</span>
suitable for <span class="math notranslate nohighlight">\((M,F)\)</span>.</p>
</div>
</div><p>Finally, we obtain the desired polynomial time upper bound for
parity in vector addition systems with states.</p>
<div class="proof theorem admonition" id="11-thm:zcycle">
<p class="admonition-title"><span class="caption-number">Theorem 344 </span> (Existential one-player parity vector games are in \P)</p>
<div class="theorem-content section" id="proof-content">
<p>Whether Eve wins a one-player parity vector game with
existential initial credit is in \P.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Let <span class="math notranslate nohighlight">\(\mathcal{V}=( \mathcal{L}, A, k)\)</span> be a vector addition system with states,
<span class="math notranslate nohighlight">\(\mathrm{lcol}{:}\, \mathcal{L}\to\{1,\dots,\)</span> <span class="math notranslate nohighlight">\(d\}\)</span> a location colouring, and
<span class="math notranslate nohighlight">\(\ell_0\in \mathcal{L}\)</span> an initial location.  We start by trimming <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> to
only keep the locations reachable from <span class="math notranslate nohighlight">\(\ell_0\)</span> in the underlying
directed graph.  Then, for every even priority <span class="math notranslate nohighlight">\(p\in\{1,\dots,d\}\)</span>,
we use <a class="reference internal" href="#11-lem:zcycle">Lemma 343</a> to check for the existence of a
non-negative cycle with maximal priority <span class="math notranslate nohighlight">\(p\)</span>: it suffices for this
to set <span class="math notranslate nohighlight">\(M  \stackrel{\!\,\!\,\textrm{def}}{=}\{ \mathrm{lcol}^{-1}(p)\}\)</span> and
<span class="math notranslate nohighlight">\(F  \stackrel{\!\,\!\,\textrm{def}}{=} \mathrm{lcol}^{-1}(\{p+1,\dots,d\})\)</span>.</p>
</div>
<p>\end{scope}</p>
<blockquote>
<div><p><strong>Upper Bounds</strong></p>
</div></blockquote>
<p>We are now equipped to prove our upper bounds.  We begin with a nearly
trivial case.  In a coverability asymmetric vector game with
existential initial credit, the counters play no role at all: Eve
has a winning strategy for some initial credit in the vector game if
and only if she has one to reach the target location <span class="math notranslate nohighlight">\(\ell_f\)</span> in the
finite game played over <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> and edges <span class="math notranslate nohighlight">\(( \ell, \ell')\)</span> whenever
<span class="math notranslate nohighlight">\(\ell \xrightarrow{\,\vec u\,} \ell'\in A\)</span> for some <span class="math notranslate nohighlight">\(\vec u\)</span>.  This entails that
coverability asymmetric vector games are quite easy to solve.</p>
<div class="proof theorem admonition" id="11-th:cov-exist-P">
<p class="admonition-title"><span class="caption-number">Theorem 345 </span> (Existential coverability asymmetric vector games are in \P)</p>
<div class="theorem-content section" id="proof-content">
<p>Coverability asymmetric vector games with existential initial
credit are \P-complete.</p>
</div>
</div><p>Regarding non-termination and parity, we
exploit <a class="reference internal" href="#11-lem:counterless">Lemma 341</a> and <a class="reference internal" href="#11-thm:zcycle">Theorem 344</a>.</p>
<div class="proof theorem admonition" id="11-th:exist-easy">
<p class="admonition-title"><span class="caption-number">Theorem 346 </span> (Existential parity asymmetric vector games are in  \textrm{coNP})</p>
<div class="theorem-content section" id="proof-content">
<p>Non-termination and parity asymmetric
vector games with existential initial credit are in  \textrm{coNP}.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>By <a class="reference internal" href="counters.html#11-rk:nonterm2parity">Remark 319</a>, it suffices to prove the statement for
parity games.  By <a class="reference internal" href="#11-lem:counterless">Lemma 341</a>,
if Adam wins the game, we can guess a counterless winning
strategy <span class="math notranslate nohighlight">\(\tau\)</span> telling which action to choose for every location.
This strategy yields a one-player game, and by <a class="reference internal" href="#11-thm:zcycle">Theorem 344</a>
we can check in polynomial time that <span class="math notranslate nohighlight">\(\tau\)</span> was indeed winning
for Adam.</p>
</div>
<p>Finally, in fixed dimension and with a fixed number of priorities, we
can simply apply the results of Section <a class="reference internal" href="resource.html#sec-bounding"><span class="std std-ref">Bounded Semantics</span></a>.</p>
<div class="proof corollary admonition" id="11-cor:exist-pseudop">
<p class="admonition-title"><span class="caption-number">Corollary 347 </span> (Existential fixed-dimensional parity asymmetric vector games are pseudo-polynomial)</p>
<div class="corollary-content section" id="proof-content">
<p>Parity asymmetric vector games with
existential initial credit are in pseudo-polynomial time if the
dimension and the number of priorities are fixed.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Consider an asymmetric vector system
<span class="math notranslate nohighlight">\(\mathcal{V}=( \mathcal{L}, A, \mathcal{L}_\mathrm{Eve}, \mathcal{L}_\mathrm{Adam}, k)\)</span> and a location
colouring <span class="math notranslate nohighlight">\(\mathrm{lcol}{:}\, \mathcal{L}\to\{1,\dots,2d\}\)</span>.
By <a class="reference internal" href="resource.html#11-lem:parity2bounding">Lemma 339</a>, the parity vector game with
existential initial credit over <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> problem reduces to a
bounding game with existential initial credit over a vector
system <span class="math notranslate nohighlight">\(\mathcal{V}'=( \mathcal{L}', A', \mathcal{L}'_\mathrm{Eve}, \mathcal{L}'_\mathrm{Adam}, k+d)\)</span> where
<span class="math notranslate nohighlight">\(\mathcal{L}'\in O(| \mathcal{L}|)\)</span> and <span class="math notranslate nohighlight">\(\| A'\|=\| A\|\)</span>.
By <a class="reference internal" href="resource.html#11-th:bounding">Theorem 340</a>, it suffices to consider the case of a
non-termination game with existential initial credit played over
the bounded semantics <span class="math notranslate nohighlight">\(\mathcal{A}_B(\mathcal{V}')\)</span> where <span class="math notranslate nohighlight">\(B\)</span> is in
<span class="math notranslate nohighlight">\((| \mathcal{L}'|\cdot\| A'\|)^{O( k+d)^3}\)</span>.  Such a game can be solved in
linear time in the size of the bounded arena using attractor
techniques, thus in <span class="math notranslate nohighlight">\(O(| \mathcal{L}|\cdot B)^{ k+d}\)</span>, which is in
<span class="math notranslate nohighlight">\((| \mathcal{L}|\cdot\| A\|)^{O( k+d)^4}\)</span> in terms of the original instance.</p>
</div>
</div>
<div class="section" id="given-initial-credit">
<span id="sec-up-given"></span><h3>Given Initial Credit<a class="headerlink" href="#given-initial-credit" title="Permalink to this headline">Â¶</a></h3>
<p>\TODO{Section <a class="reference internal" href="#sec-up-given"><span class="std std-ref">Given Initial Credit</span></a>}</p>
<div class="proof theorem admonition" id="11-th:avag-easy">
<p class="admonition-title"><span class="caption-number">Theorem 348 </span> (Upper bounds for asymmetric vector games)</p>
<div class="theorem-content section" id="proof-content">
<p>Coverability, non-termination, and parity
asymmetric vector games with given initial credit are in
\textrm{kEXP}[2].  If the dimension is fixed, they are in  \textrm{EXP}, and if the
number of priorities is also fixed, they are in pseudo-polynomial
time.</p>
</div>
</div></div>
</div>
<div class="section" id="lower-bounds">
<span id="sec-low"></span><h2>Lower Bounds<a class="headerlink" href="#lower-bounds" title="Permalink to this headline">Â¶</a></h2>
<p>Let us turn our attention to complexity lower bounds for monotonic
asymmetric vector games.  It turns out that most of the upper bounds
shown in Section <a class="reference internal" href="#sec-up"><span class="std std-ref">Upper Bounds</span></a> are tight.</p>
<div class="section" id="id2">
<h3>Existential Initial Credit<a class="headerlink" href="#id2" title="Permalink to this headline">Â¶</a></h3>
<p>In the existential initial credit variant of our games, we have the
following lower bound matching <a class="reference internal" href="#11-th:exist-easy">Theorem 346</a>, already with a
unary encoding.</p>
<div class="proof theorem admonition" id="11-th:exist-hard">
<p class="admonition-title"><span class="caption-number">Theorem 349 </span> (Existential non-termination asymmetric vector games are  \textrm{coNP}-hard)</p>
<div class="theorem-content section" id="proof-content">
<p>Non-termination, and parity
asymmetric vector games with existential initial credit are
\textrm{coNP}-hard.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>By <a class="reference internal" href="counters.html#11-rk:nonterm2parity">Remark 319</a>, it suffices to show hardness for
non-termination games.  We reduce from the \lang{3SAT} problem:
given a formula <span class="math notranslate nohighlight">\(\varphi=\bigwedge_{1\leq i\leq m}C_i\)</span> where each
clause <span class="math notranslate nohighlight">\(C_i\)</span> is a disjonction of the form
<span class="math notranslate nohighlight">\(\ell_{i,1}\vee  \ell_{i,2}\vee  \ell_{i,3}\)</span> of literals taken from
<span class="math notranslate nohighlight">\(X=\{x_1,\neg x_1,x_2,\)</span> <span class="math notranslate nohighlight">\(\neg x_2,\dots,x_k,\neg x_k\}\)</span>, we construct
an asymmetric vector system <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> where Eve wins the
non-termination game with existential initial credit if and only
if <span class="math notranslate nohighlight">\(\varphi\)</span> is not satisfiable; since the game is determined, we
actually show that Adam wins the game if and only if <span class="math notranslate nohighlight">\(\varphi\)</span> is
satisfiable.</p>
<p>Our vector system has dimension <span class="math notranslate nohighlight">\(2k\)</span>, and for a literal
<span class="math notranslate nohighlight">\(\ell\in X\)</span>, we define the vector</p>
<div class="math notranslate nohighlight">
\[\begin{split}    \vec u_\ell  \stackrel{\!\,\!\,\textrm{def}}{=}\begin{cases}
      \vec e_{2n-1}-\vec e_{2n}&amp;\text{if }  \ell=x_n\;,\\
      \vec e_{2n}-\vec e_{2n-1}&amp;\text{if }  \ell=\neg x_n\;.
    \end{cases}
  
\end{split}\]</div>
<p>We define <span class="math notranslate nohighlight">\(\mathcal{V}  \stackrel{\!\,\!\,\textrm{def}}{=}( \mathcal{L}, A, \mathcal{L}_\mathrm{Eve}, \mathcal{L}_\mathrm{Adam},2k)\)</span> where</p>
<div class="math notranslate nohighlight">
\[\begin{split}     \mathcal{L}_\mathrm{Eve}&amp;  \stackrel{\!\,\!\,\textrm{def}}{=}\{\varphi\}\cup\{  \ell_{i,j}\mid 1\leq i\leq m,1\leq j\leq
                3\}\;,\\
     \mathcal{L}_\mathrm{Adam}&amp;  \stackrel{\!\,\!\,\textrm{def}}{=}\{C_i\mid 1\leq i\leq m\}\;,\\
     A&amp;  \stackrel{\!\,\!\,\textrm{def}}{=}\{\varphi \xrightarrow{\,\vec 0\,}C_i\mid 1\leq i\leq m\}\cup\{C_i \xrightarrow{\,\vec 0\,}  \ell_{i,j},\;\;  \ell_{i,j}\xrightarrow{\vec u_{  \ell_{i,j}}}\varphi\mid 1\leq i\leq m,1\leq j\leq 3\}\;.
  
\end{split}\]</div>
<p>\begin{scope}
We use <span class="math notranslate nohighlight">\(\varphi\)</span> as our initial location.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Let us call a map $v{:}\,X\to\{0,1\}$ a literal assignment; we
call it conflicting if there exists $1\leq n\leq k$ such that
$v(x_n)=v(\neg x_n)$.

Assume that $\varphi$ is satisfiable.  Then there exists a
non-conflicting literal assignment $v$ that satisfies all the
clauses: for each $1\leq i\leq m$, there exists $1\leq j\leq 3$
such that $v(  \ell_{i,j})=1$; this yields a counterless strategy
for Adam, which selects $(C_i,  \ell_{i,j})$ for each
$1\leq i\leq m$.  Consider any infinite play consistent with
this strategy.  This play only visits literals $\ell$ where
$v(  \ell)=1$.  There exists a literal $\ell\in X$ that is visited
infinitely often along the play, say $\ell=x_n$.  Because $v$ is
non-conflicting, $v(\neg x_n)=0$, thus the location $\neg x_n$
is never visited.  Thus the play uses the action
$\ell \xrightarrow{\,\vec e_{2n-1\,}-\vec e_{2n}}\varphi$ infinitely often,
and never uses any action with a positive effect on
component $2n$.  Hence the play is losing from any initial credit.

Conversely, assume that $\varphi$ is not satisfiable.  By
contradiction, assume that Adam wins the game for all initial
credits.  By {prf:ref}`11-lem:counterless`, he has a counterless winning
strategy $\tau$ that selects a literal in every clause.  Consider
a literal assignment that maps each one of the selected literals
to $1$ and the remaining ones in a non-conflicting manner.  By
definition, this literal assignment satisfies all the clauses,
but because $\varphi$ is not satisfiable, it is conflicting:
necessarily, there exist $1\leq n\leq k$ and $1\leq i,i&#39;\leq m$,
such that $\tau$ selects $x_n$ in $C_i$ and $\neg x_n$ in
$C_{i&#39;}$.  But this yields a winning strategy for Eve, which
alternates in the initial location $\varphi$ between $C_{i}$
and $C_{i&#39;}$, and for which an initial credit
$\vec e_{2n-1}+\vec e_{2n}$ suffices: a contradiction.
</pre></div>
</div>
<p>\end{scope}</p>
</div>
<p>Note that <a class="reference internal" href="#11-th:exist-hard">Theorem 349</a> does not apply to fixed dimensions
<span class="math notranslate nohighlight">\(k\geq 2\)</span>.  We know by <a class="reference internal" href="#11-cor:exist-pseudop">Corollary 347</a> that those games can
be solved in pseudo-polynomial time if the number of priorities is
fixed, and by <a class="reference internal" href="#11-th:exist-easy">Theorem 346</a> that they are in  \textrm{coNP}.</p>
</div>
<div class="section" id="id3">
<h3>Given Initial Credit<a class="headerlink" href="#id3" title="Permalink to this headline">Â¶</a></h3>
<p>With given initial credit, we have a lower bound matching the
\textrm{kEXP}[2] upper bound of <a class="reference internal" href="#11-th:avag-easy">Theorem 348</a>, already with a unary
encoding.  The proof itself is an adaptation of the proof by
(Lipton in <span id="id4">[<a class="reference internal" href="references.html#id221"><span>Lip76</span></a>]</span>) of <span class="math notranslate nohighlight">\(\textrm{EXPSPACE}\)</span>-hardness of coverability in
the one-player case.</p>
<div class="proof theorem admonition" id="11-th:avag-hard">
<p class="admonition-title"><span class="caption-number">Theorem 350 </span> (Coverability and non-termination asymmetric vector games are { \textrm{kEXP}[2]-hard})</p>
<div class="theorem-content section" id="proof-content">
<p>Coverability, non-termination, and parity
asymmetric vector games with given initial credit are
\textrm{kEXP}[2]-hard.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We reduce from the halting problem of an alternating Minsky
machine <span class="math notranslate nohighlight">\(\mathcal{M}=( \mathcal{L}, A, \mathcal{L}_\mathrm{Eve}, \mathcal{L}_\mathrm{Adam}, k)\)</span> with counters
bounded by <span class="math notranslate nohighlight">\(B  \stackrel{\!\,\!\,\textrm{def}}{=} 2^{2^n}\)</span> for <span class="math notranslate nohighlight">\(n  \stackrel{\!\,\!\,\textrm{def}}{=}|\mathcal{M}|\)</span>.  Such a machine is
similar to an asymmetric vector system with increments
<span class="math notranslate nohighlight">\(\ell \xrightarrow{\,\vec e_i\,} \ell'\)</span>, decrements <span class="math notranslate nohighlight">\(\ell \xrightarrow{\,-\vec e_i\,} \ell'\)</span>,
and zero test actions <span class="math notranslate nohighlight">\(\ell \xrightarrow{\,i \stackrel{\!\,\!\,\textrm{?0\,}}{=}} \ell'\)</span>, all
restricted to locations <span class="math notranslate nohighlight">\(\ell\in \mathcal{L}_\mathrm{Eve}\)</span>; the only actions
available to Adam are actions <span class="math notranslate nohighlight">\(\ell \xrightarrow{\,\vec 0\,} \ell'\)</span>.  The
set of locations contains a distinguished halt location
<span class="math notranslate nohighlight">\(\ell_\mathtt{halt}\in \mathcal{L}\)</span> with no outgoing action.  The
machine comes with the promise that, along any play, the norm of
all the visited configurations <span class="math notranslate nohighlight">\(\ell(\vec v)\)</span> satisfies
<span class="math notranslate nohighlight">\(\|\vec v\|&lt;B\)</span>.  The halting problem asks, given an initial
location <span class="math notranslate nohighlight">\(\ell_0\in \mathcal{L}\)</span>, whether Eve has a winning strategy to
visit <span class="math notranslate nohighlight">\(\ell_\mathtt{halt}(\vec v)\)</span> for some <span class="math notranslate nohighlight">\(\vec v\in\mathbb{N}^ k\)</span> from
the initial configuration <span class="math notranslate nohighlight">\(\ell_0(\vec 0)\)</span>.  This problem is
\textrm{kEXP}[2]-complete if <span class="math notranslate nohighlight">\(k\geq 3\)</span> by standard
arguments <span id="id5">[<span>Fischer&amp;Meyer&amp;Rosenberg:1968</span>]</span>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>        by a quick refresher on Lipton&#39;s construction {cite}`Lipton:1976`;
see also {cite}`Esparza:1996` for a nice exposition.  At the heart
of the construction lies a collection of one-player gadgets
implementing **level $j$** meta-increments
$\ell \xrightarrow{\,2^{2^j\,}\cdot\vec c} \ell&#39;$ and **level $j$**
meta-decrements $\ell \xrightarrow{\,-2^{2^j\,}\cdot\vec c} \ell&#39;$ for
some unit vector $\vec c$ using $O(j)$ auxiliary counters and
$\poly(j)$ actions, with precondition that the auxiliary counters
are initially empty in $\ell$ and postrelation that they are empty
again in $\ell&#39;$.  The construction is by induction over $j$; let
us first see a naive implementation for meta-increments.  For
the base case $j=0$, this is just a standard action
$\ell \xrightarrow{\,2\vec c\,} \ell&#39;$.  For the induction step $j+1$, we use
the gadget of {numref}`11-fig:meta-incr` below, where
$\vec x_{j},\bar{\vec x}_{j},\vec z_{j},\bar{\vec z}_{j}$ are
distinct fresh unit vectors: the gadget performs two nested
loops, each of $2^{2^j}$ iterations, thus iterates the unit
increment of $\vec c$ a total of $\big(2^{2^j}\big)^2=2^{2^{j+1}}$
times.  A meta-decrement is obtained similarly.
</pre></div>
</div>
<div class="figure align-center" id="fig-meta-incr">
<img alt="../_images/11-fig:meta-incr.png" src="../_images/11-fig:meta-incr.png" />
<p class="caption"><span class="caption-number">Fig. 92 </span><span class="caption-text">A naive implementation of the
meta-increment <span class="math notranslate nohighlight">\(\ell \xrightarrow{\,2^{2^{j+1\,}}\cdot\vec c} \ell'\)</span>.</span><a class="headerlink" href="#fig-meta-incr" title="Permalink to this image">Â¶</a></p>
</div>
<p>Note that this level <span class="math notranslate nohighlight">\((j+1)\)</span> gadget contains two copies of the
level <span class="math notranslate nohighlight">\(j\)</span> meta-increment and two of the level <span class="math notranslate nohighlight">\(j\)</span>
meta-decrement, hence this naive implementation has
size <span class="math notranslate nohighlight">\(\mathsf{exp}(j)\)</span>.  In order to obtain a polynomial size, we would like
to use a single <strong>shared</strong> level <span class="math notranslate nohighlight">\(j\)</span> gadget for each <span class="math notranslate nohighlight">\(j\)</span>, instead
of hard-wiring multiple copies.  The idea is to use a <code class="docutils literal notranslate"><span class="pre">dispatch</span>&#160;&#160; <span class="pre">mechanism,'</span> <span class="pre">using</span> <span class="pre">extra</span> <span class="pre">counters,</span> <span class="pre">to</span> <span class="pre">encode</span> <span class="pre">the</span> <span class="pre">choice</span> <span class="pre">of</span> <span class="pre">unit</span>&#160;&#160; <span class="pre">vector</span> <span class="pre">$\vec</span> <span class="pre">c$</span> <span class="pre">and</span> <span class="pre">of</span> <span class="pre">return</span> <span class="pre">location</span> <span class="pre">$\ell'$.</span>&#160; <span class="pre">Let</span> <span class="pre">us</span> <span class="pre">see</span> <span class="pre">how</span> <span class="pre">to</span>&#160;&#160; <span class="pre">do</span> <span class="pre">this</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">case</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">return</span> <span class="pre">location</span> <span class="pre">$\ell'$;</span> <span class="pre">the</span> <span class="pre">mechanism</span>&#160;&#160; <span class="pre">for</span> <span class="pre">the</span> <span class="pre">vector</span> <span class="pre">$\vec</span> <span class="pre">c$</span> <span class="pre">is</span> <span class="pre">similar.</span>&#160; <span class="pre">We</span> <span class="pre">enumerate</span> <span class="pre">the</span> <span class="pre">(finitely</span> <span class="pre">many)</span>&#160;&#160; <span class="pre">possible</span> <span class="pre">return</span> <span class="pre">locations</span> <span class="pre">$\ell_0,\dots,</span> <span class="pre">\ell_{m-1}$</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">gadget</span>&#160;&#160; <span class="pre">implementing</span> <span class="pre">$\ell</span> <span class="pre">\xrightarrow{\,2^{2^{j+1\,}}\cdot\vec</span> <span class="pre">c}</span> <span class="pre">\ell'$.</span>&#160; <span class="pre">We</span> <span class="pre">use</span> <span class="pre">two</span>&#160;&#160; <span class="pre">auxiliary</span> <span class="pre">counters</span> <span class="pre">with</span> <span class="pre">unit</span> <span class="pre">vectors</span> <span class="pre">$\vec</span> <span class="pre">r_j$</span>&#160;&#160; <span class="pre">and</span> <span class="pre">$\bar{\vec</span> <span class="pre">r}_j$</span> <span class="pre">to</span> <span class="pre">encode</span> <span class="pre">the</span> <span class="pre">return</span> <span class="pre">location.</span>&#160; <span class="pre">Assume</span> <span class="pre">$\ell'$</span>&#160;&#160; <span class="pre">is</span> <span class="pre">the</span> <span class="pre">$i$th</span> <span class="pre">possible</span> <span class="pre">return</span> <span class="pre">location,</span> <span class="pre">i.e.,</span> <span class="pre">$\ell'=</span> <span class="pre">\ell_i$</span> <span class="pre">in</span> <span class="pre">our</span>&#160;&#160; <span class="pre">enumeration:</span> <span class="pre">before</span> <span class="pre">entering</span> <span class="pre">the</span> <span class="pre">shared</span> <span class="pre">gadget</span> <span class="pre">implementation,</span> <span class="pre">we</span>&#160;&#160; <span class="pre">initialise</span> <span class="pre">$\vec</span> <span class="pre">r_j$</span> <span class="pre">and</span> <span class="pre">$\bar{\vec</span> <span class="pre">r}_j$</span> <span class="pre">by</span> <span class="pre">performing</span> <span class="pre">the</span> <span class="pre">action</span>&#160;&#160; <span class="pre">$\ell</span> <span class="pre">\xrightarrow{\,i\cdot\vec</span> <span class="pre">r_j+(m-i)\cdot\bar{\vec</span> <span class="pre">r\,}_j}\cdots$.</span>&#160; <span class="pre">Then,</span>&#160;&#160; <span class="pre">where</span> <span class="pre">we</span> <span class="pre">would</span> <span class="pre">simply</span> <span class="pre">go</span> <span class="pre">to</span> <span class="pre">$\ell'$</span> <span class="pre">in</span> <span class="pre">{numref}</span></code>11-fig:meta-incr` at
the end of the gadget, the shared gadget has a final action
<span class="math notranslate nohighlight">\(\cdots \xrightarrow{\,\vec 0\,} \ell_{\mathrm{return}_j}\)</span> leading to a dispatch
location for returns: for all <span class="math notranslate nohighlight">\(0\leq i&lt;m\)</span>, we have an action
<span class="math notranslate nohighlight">\(\ell_{\mathrm{return}_j} \xrightarrow{\,-i\cdot\vec r_j-(m-i)\cdot\bar{\vec
      r\,}_j} \ell_i\)</span>
that leads to the desired return location.\todoquestion{Is that
clear enough?}</p>
<p>\bigskip Let us return to the proof.  Consider an instance of the
halting problem.  We first exhibit a reduction to coverability;
by <a class="reference internal" href="counters.html#11-rk:cov2parity">Remark 320</a>, this will also entail the  \textrm{kEXP}[2]-hardness
of parity asymmetric vector games.  We
build an asymmetric vector system
<span class="math notranslate nohighlight">\(\mathcal{V}=( \mathcal{L}', A', \mathcal{L}'_\mathrm{Eve}, \mathcal{L}_\mathrm{Adam}, k')\)</span> with
<span class="math notranslate nohighlight">\(k'=2 k+O(n)\)</span>.  Each of the counters <span class="math notranslate nohighlight">\(\mathtt{c}_i\)</span> of <span class="math notranslate nohighlight">\(\mathcal{M}\)</span> is
paired with a <strong>complementary</strong> counter <span class="math notranslate nohighlight">\(\bar{\mathtt{c}_i}\)</span> such
that their sum is <span class="math notranslate nohighlight">\(B\)</span> throughout the simulation of <span class="math notranslate nohighlight">\(\mathcal{M}\)</span>.  We
denote by <span class="math notranslate nohighlight">\(\vec c_i\)</span> and <span class="math notranslate nohighlight">\(\bar{\vec c}_i\)</span> the corresponding unit
vectors for <span class="math notranslate nohighlight">\(1\leq i\leq k\)</span>.  The vector system <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> starts by
initialising the counters <span class="math notranslate nohighlight">\(\bar{\mathtt{c}}_i\)</span> to <span class="math notranslate nohighlight">\(B\)</span> by a sequence
of meta-increments
<span class="math notranslate nohighlight">\(\ell'_{i-1} \xrightarrow{\,2^{2^n\,}\cdot\bar{\vec c}_i} \ell'_i\)</span> for
<span class="math notranslate nohighlight">\(1\leq i\leq k\)</span>, before starting the simulation by an action
<span class="math notranslate nohighlight">\(\ell'_k \xrightarrow{\,\vec 0\,} \ell_0\)</span>.  The simulation of <span class="math notranslate nohighlight">\(\mathcal{M}\)</span> uses the
actions depicted in <a class="reference internal" href="#fig-lipton"><span class="std std-numref">Fig. 93</span></a>.  Those maintain the
invariant on the complement counters.  Regarding zero tests, Eve
yields the control to Adam, who has a choice between performing a
meta-decrement that will fail if <span class="math notranslate nohighlight">\(\bar{\mathtt c}_i&lt; 2^{2^n}\)</span>,
which by the invariant is if and only if <span class="math notranslate nohighlight">\(\mathtt{c}_i&gt;0\)</span>, or going
to <span class="math notranslate nohighlight">\(\ell'\)</span>.</p>
<div class="figure align-center" id="fig-lipton">
<img alt="../_images/11-fig:lipton.png" src="../_images/11-fig:lipton.png" />
<p class="caption"><span class="caption-number">Fig. 93 </span><span class="caption-text">Schema of the reduction to
coverability in the proof of <a class="reference internal" href="#11-th:avag-hard">Theorem 350</a>.</span><a class="headerlink" href="#fig-lipton" title="Permalink to this image">Â¶</a></p>
</div>
<p>It is hopefully clear that Eve wins the coverability game played
on <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> starting from <span class="math notranslate nohighlight">\(\ell'_0(\vec 0)\)</span> and with target
configuration <span class="math notranslate nohighlight">\(\ell_\mathtt{halt}(\vec 0)\)</span> if and only if the
alternating Minsky machine halts.</p>
<p>Regarding non-termination games, we use essentially the
same reduction.  First observe that, if Eve can ensure reaching
<span class="math notranslate nohighlight">\(\ell_\mathtt{halt}\)</span> in the alternating Minsky machine, then she
can do so after at most <span class="math notranslate nohighlight">\(| \mathcal{L}|B^ k\)</span> steps.  We therefore use a
time budget: this is an additional component in <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> with
associated unit vector <span class="math notranslate nohighlight">\(\vec t\)</span>.  This component is initialised to
<span class="math notranslate nohighlight">\(| \mathcal{L}|B^ k=| \mathcal{L}|2^{ k 2^n}\)</span> before the simulation, and decreases
by one at every step; see <a class="reference internal" href="#fig-lipton-nonterm"><span class="std std-numref">Fig. 94</span></a>.  We also add
a self loop <span class="math notranslate nohighlight">\(\ell_\mathtt{halt} \xrightarrow{\,\vec 0\,} \ell_\mathtt{halt}\)</span>.
Then the only way to avoid the sink and thus to win the
non-termination game is to reach <span class="math notranslate nohighlight">\(\ell_\mathtt{halt}\)</span>.</p>
<div class="figure align-center" id="fig-lipton-nonterm">
<img alt="../_images/11-fig:lipton-nonterm.png" src="../_images/11-fig:lipton-nonterm.png" />
<p class="caption"><span class="caption-number">Fig. 94 </span><span class="caption-text">Schema of the reduction to
non-termination in the proof of <a class="reference internal" href="#11-th:avag-hard">Theorem 350</a>.</span><a class="headerlink" href="#fig-lipton-nonterm" title="Permalink to this image">Â¶</a></p>
</div>
<p>We still need to extend our initialisation phase.  It suffices for
this to implement a gadget for <span class="math notranslate nohighlight">\(k\)</span>-meta-increments
<span class="math notranslate nohighlight">\(\ell \xrightarrow{\,2^{ k 2^j\,}\cdot\vec c} \ell'\)</span> and <span class="math notranslate nohighlight">\(k\)</span>-meta-decrements
<span class="math notranslate nohighlight">\(\ell \xrightarrow{\,-2^{ k 2^j\,}\cdot\vec c} \ell'\)</span>; this is the same argument as
in Liptonâs construction, with a base case <span class="math notranslate nohighlight">\(\ell \xrightarrow{\,2^ k\,} \ell'\)</span>
for <span class="math notranslate nohighlight">\(j=0\)</span>.  Then we initialise our time budget through <span class="math notranslate nohighlight">\(| \mathcal{L}|\)</span>
successive <span class="math notranslate nohighlight">\(k\)</span>-meta-increments
<span class="math notranslate nohighlight">\(\ell \xrightarrow{\,2^{ k 2^n\,}\cdot\vec t} \ell'\)</span>.</p>
</div>
<p>The proof of <a class="reference internal" href="#11-th:avag-hard">Theorem 350</a> relies crucially on the fact that the
dimension is not fixed: although <span class="math notranslate nohighlight">\(k\geq 3\)</span> suffices in the
alternating Minsky machine, we need <span class="math notranslate nohighlight">\(O(|\mathcal{M}|)\)</span> additional counters
to carry out the reduction.  A separate argument is thus needed in
order to match the  \textrm{EXP}\ upper bound of <a class="reference internal" href="#11-th:avag-easy">Theorem 348</a> in fixed
dimension.</p>
<div class="proof theorem admonition" id="11-th:avag-two">
<p class="admonition-title"><span class="caption-number">Theorem 351 </span> (Fixed-dimensional coverability and non-termination asymmetric vector games are  \textrm{EXP}-hard)</p>
<div class="theorem-content section" id="proof-content">
<p>Coverability, non-termination, and parity
asymmetric vector games with given initial credit are
\textrm{EXP}-hard in dimension <span class="math notranslate nohighlight">\(k\geq 2\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We exhibit a reduction from countdown games with given initial
credit, which are  \textrm{EXP}-complete by <a class="reference internal" href="dim1.html#11-th:countdown-given">Theorem 323</a>.
Consider an instance of a configuration reachability countdown
game: a countdown system
<span class="math notranslate nohighlight">\(\mathcal{V}=( \mathcal{L}, A, \mathcal{L}_\mathrm{Eve}, \mathcal{L}_\mathrm{Adam},1)\)</span> with initial
configuration <span class="math notranslate nohighlight">\(\ell_0(n_0)\)</span> and target
configuration <span class="math notranslate nohighlight">\(\smiley(0)\)</span>âas seen in the proof
of <a class="reference internal" href="dim1.html#11-th:countdown-given">Theorem 323</a>, we can indeed assume that the target
credit is zero; we will also assume that Eve controls <span class="math notranslate nohighlight">\(\smiley\)</span> and
that the only action available in <span class="math notranslate nohighlight">\(\smiley\)</span> is
<span class="math notranslate nohighlight">\(\smiley \xrightarrow{\,-1\,}\smiley\)</span>.  We construct an asymmetric vector
system <span class="math notranslate nohighlight">\(\mathcal{V}'\)</span> of dimension 2 such that Eve can ensure
reaching <span class="math notranslate nohighlight">\(\smiley(0,n_0)\)</span> from <span class="math notranslate nohighlight">\(\ell_0(n_0,0)\)</span> in <span class="math notranslate nohighlight">\(\mathcal{V}'\)</span> if and only
if she could ensure reaching <span class="math notranslate nohighlight">\(\smiley(0)\)</span> from <span class="math notranslate nohighlight">\(\ell_0(n_0)\)</span>
in <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>.  The translation is depicted in <a class="reference internal" href="#fig-dim2"><span class="std std-numref">Fig. 95</span></a>.</p>
<div class="figure align-center" id="fig-dim2">
<img alt="../_images/11-fig:dim2.png" src="../_images/11-fig:dim2.png" />
<p class="caption"><span class="caption-number">Fig. 95 </span><span class="caption-text">Schema of the reduction in the proof
of <a class="reference internal" href="#11-th:avag-two">Theorem 351</a>.</span><a class="headerlink" href="#fig-dim2" title="Permalink to this image">Â¶</a></p>
</div>
<p>The idea behind this translation is that a configuration <span class="math notranslate nohighlight">\(\ell(c)\)</span>
of <span class="math notranslate nohighlight">\(\mathcal{V}\)</span> is simulated by a configuration <span class="math notranslate nohighlight">\(\ell(c,n_0-c)\)</span> in <span class="math notranslate nohighlight">\(\mathcal{V}'\)</span>.
The crucial point is how to handle Adamâs moves.  In a
configuration <span class="math notranslate nohighlight">\(\ell(c,n_0-c)\)</span> with <span class="math notranslate nohighlight">\(\ell\in \mathcal{L}_\mathrm{Adam}\)</span>, according
to the natural semantics of <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>, Adam should be able to
simulate an action <span class="math notranslate nohighlight">\(\ell \xrightarrow{\,-n\,} \ell'\)</span> if and only if <span class="math notranslate nohighlight">\(c\geq n\)</span>.
Observe that otherwise if <span class="math notranslate nohighlight">\(c&lt;n\)</span> and thus <span class="math notranslate nohighlight">\(n_0-c&gt;n_0-n\)</span>, Eve can
play to reach <span class="math notranslate nohighlight">\(\smiley\)</span> and win immediately.  An exception to the
above is if <span class="math notranslate nohighlight">\(n\)</span> is minimal among the decrements in <span class="math notranslate nohighlight">\(\ell\)</span>, because
according to the natural semantics of <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>, if <span class="math notranslate nohighlight">\(c&lt;n\)</span> there should
be an edge to the sink, and this is handled in the second line
of <a class="reference internal" href="#fig-dim2"><span class="std std-numref">Fig. 95</span></a>.</p>
<p>Then Eve can reach <span class="math notranslate nohighlight">\(\smiley(0,n_0)\)</span> if and only if she can cover
<span class="math notranslate nohighlight">\(\smiley(0,n_0)\)</span>, if and only if she can avoid the sink thanks to
the self loop <span class="math notranslate nohighlight">\(\smiley \xrightarrow{\,0,0\,}\smiley\)</span>.  This
shows the  \textrm{EXP}-hardness of coverability and non-termination
asymmetric vector games in dimension two; the hardness of
parity follows
from <a class="reference internal" href="counters.html#11-rk:cov2parity">Remark 320</a> and <a class="reference internal" href="counters.html#11-rk:nonterm2parity">Remark 319</a>.</p>
</div>
</div>
</div>
<div class="section" id="dimension-one">
<span id="sec-mono-dim1"></span><h2>Dimension One<a class="headerlink" href="#dimension-one" title="Permalink to this headline">Â¶</a></h2>
<p>\TODO{contents of Section <a class="reference internal" href="#sec-mono-dim1"><span class="std std-ref">Dimension One</span></a> depend on what goes into Chapter <a class="reference internal" href="../12_Multiobjectives/index.html#chap-multiobjective"><span class="std std-ref">Games with multiple objectives</span></a>}</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./11_Counters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="resource.html" title="previous page">Resource-conscious games</a>
    <a class='right-next' id="next-link" href="references.html" title="next page">Bibliographic references</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>