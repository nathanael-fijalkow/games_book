
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1.7. Bibliographic references &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"set": ["\\left\\{ #1 \\right\\}", 1], "N": "\\mathbb{N}", "Z": "\\mathbb{Z}", "Q": "\\mathbb{Q}", "Qinfty": "\\Q \\cup \\set{\\infty}", "R": "\\mathbb{R}", "Rinfty": "\\R \\cup \\set{\\infty}", "ing": "\\text{In}", "Ing": "\\ing", "out": "\\text{Out}", "Out": "\\out", "first": "\\text{first}", "last": "\\text{last}", "Paths": "\\text{Paths}", "play": "\\pi", "arena": "\\mathcal{A}", "Arena": "\\arena", "col": "\\textsf{col}", "Col": "\\col", "game": "\\mathcal{G}", "Game": "\\game", "Eve": "\\mathrm{Eve}", "Adam": "\\mathrm{Adam}", "VE": "V_\\Eve", "VA": "V_\\Adam", "VR": "V_\\mathrm{Random}", "WE": "W_\\Eve", "WA": "W_\\Adam", "Value": "val", "val": "\\Value", "ValueE": "\\Value_\\Eve", "ValueA": "\\Value_\\Adam", "Win": "\\text{Win}", "Lose": "\\text{Lose}", "Safe": "\\mathtt{Safe}", "Reach": "\\mathtt{Reach}", "Buchi": "\\mathtt{Buchi}", "CoBuchi": "\\mathtt{CoBuchi}", "Parity": "\\mathtt{Parity}", "MeanPayoff": "\\mathtt{MeanPayoff}", "DiscountedPayoff": "\\mathtt{DiscountedPayoff}", "Automaton": "\\mathbf{A}", "half": "\\frac{1}{2}"}}, "tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="1.6. The Zielonka tree" href="zielonka.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../book.html">
   Games on Graphs
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="../index.html">
   1. Classic
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="index.html">
     1.1. Regular
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="attractors.html">
     1.2. A linear time algorithm for reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="buchi.html">
     1.3. A quadratic time algorithm for Büchi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parity.html">
     1.4. An exponential time algorithm for parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="muller.html">
     1.5. Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zielonka.html">
     1.6. The Zielonka tree
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     1.7. Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/2_Classic/1_Regular/references.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="bibliographic-references">
<span id="sec-references"></span><h1><span class="section-number">1.7. </span>Bibliographic references<a class="headerlink" href="#bibliographic-references" title="Permalink to this headline">¶</a></h1>
<p>The interest in reachability objectives goes beyond automata theory and logic.
The attractor computation presented in <a class="reference internal" href="attractors.html#sec-attractors"><span class="std std-ref">Section</span></a> is inspired by the backward induction principle due to Zermelo <span id="id1">[<a class="reference internal" href="#id53"><span>Zer13</span></a>]</span>,
which was used to show that well founded games (<strong>i.e.</strong> where all plays are finite) are determined.
The word attractor (together with traps and subgames) first appeared in Zielonka’s work
on Muller games <span id="id2">[<span>Zielonka:1998</span>]</span>, but without the algorithmic point of view.
A naive implementation of the attractor would have a quadractic time complexity.
It is difficult to give credit for the linear time algorithm since the problem being very natural it has appeared in several contexts,
for instance in database theory as an inference algorithm by Beeri and Bernstein <span id="id3">[<span>Beeri&amp;Bernstein:1979</span>]</span>
or in the framework of computing least fixed points over transition systems by Arnold and Crubillé <span id="id4">[<span>Arnold&amp;Crubille:1988</span>]</span>.</p>
<p>The other objectives studied in this chapter are called <span class="math notranslate nohighlight">\(\omega\)</span>-regular,
let us discuss their relevance in automata theory and logic.
An important application of automata theory is to make logic effective: by translating, sometimes called compiling,
a logical formula into an equivalent automaton, we can solve problems such as satisfiability or model-checking by reducing them
to analysing automata and in particular their underlying graph structures.
In this context, the reachability objective is used for automata over finite words:
the classical definition is that a run is accepting if the last state is accepting.
Monadic second-order logic over finite words can be effectively translated into finite automata,
marking the beginning of a close connection between logic and automata theory.</p>
<p>Considering logics over infinite structures led to the study of automata over infinite structures such as words and trees.
The first objective to be studied in this context was Büchi objective, introduced by Büchi <span id="id5">[<span>Buchi:1962</span>]</span>:
a run is accepting if it visits infinitely many times an accepting state.
Unfortunately the class of languages of infinite words recognised by deterministic Büchi automata is not closed under projection (corresponding in logic to existential quantification), said differently non-deterministic Büchi automata are strictly more expressive than deterministic ones
hence not equivalent to monadic second-order logic over infinite words.
Muller <span id="id6">[<span>Muller:1963</span>]</span> introduced the Muller objectives and attempted to prove the closure under projection for deterministic Muller automata. Alas, the proof had a flaw.
The first correct proof of the result is due to McNaughton <span id="id7">[<a class="reference internal" href="#id48"><span>McN66</span></a>]</span>.</p>
<p>The correspondence between monadic second-order logic and Muller automata was extended from infinite words to infinite binary trees
by Rabin <span id="id8">[<a class="reference internal" href="#id51"><span>Rab69</span></a>]</span>, yielding the celebrated decidability of monadic second-order logic over infinite trees.
Rabin introduced and worked with Rabin objectives; his proof is arguably very complicated and a lot of subsequent works focussed on finding the right notions and tools for better understanding his approach.
Streett <span id="id9">[<span>Streett:1981</span>]</span> suggested to use the complement of Rabin objectives, now called Streett objectives, for translating temporal logics
to Streett automata.
As discussed in <span class="xref std std-ref">Section</span>, a key step was made by applying determinacy results for games
to complementation results for automata.
The parity objectives appeared in this context as a (and in fact, the) subclass of Muller objectives which is positionally determined for both players.
They have been defined (with some variants) independently by several authors: Wagner <span id="id10">[<span>Wagner:1979</span>]</span>,
Mostowski <span id="id11">[<span>Mostowski:1984</span>]</span> who called them Rabin chain,
Emerson and Jutla <span id="id12">[<span>Emerson&amp;Jutla:1991</span>]</span> who first used the name parity,
and McNaughton <span id="id13">[<span>McNaughton:1993</span>]</span>.
The idea can be traced back to the difference hierarchy by Hausdorff <span id="id14">[<span>Hausdorff:1914</span>]</span>.
The proof of the positionality was obtained independently by Mostowski <span id="id15">[<span>Mostowski:1991</span>]</span>,
Emerson and Jutla <span id="id16">[<span>Emerson&amp;Jutla:1991</span>]</span>, and McNaughton <span id="id17">[<span>McNaughton:1993</span>]</span> (the latter proof is for finite games).
Later Walukiewicz <span id="id18">[<span>Walukiewicz:2002</span>]</span> gave another very elegant proof.</p>
<p>McNaughton <span id="id19">[<span>McNaughton:1993</span>]</span> introduced the idea of solving Muller games by induction on the colours,
leading to McNaughton algorithm as presented in <a class="reference internal" href="muller.html#sec-muller"><span class="std std-ref">Section</span></a>.
To some extent, the algorithms for solving Büchi, CoBüchi, and parity games are all special cases of McNaughton algorithm.</p>
<p>Taking a step back in time, McNaughton already proposed the <strong>Latest Appearance Record</strong> (LAR) discussed in <a class="reference internal" href="zielonka.html#sec-zielonka"><span class="std std-ref">Section</span></a>
for solving Muller games in his flawed attempt to solve the synthesis problem <span id="id20">[<a class="reference internal" href="#id47"><span>McN65</span></a>]</span> (see <span class="xref std std-ref">Section</span>).
The LAR was later used by Gurevich and Harrington <span id="id21">[<a class="reference internal" href="#id43"><span>GH82</span></a>]</span> as memory for winning strategies in Muller games.
Thomas <span id="id22">[<span>Thomas:1995</span>]</span> showed that the LAR can be used to reduce Muller games to parity games.</p>
<p>Zielonka <span id="id23">[<span>Zielonka:1998</span>]</span> greatly contributed to the study of Muller objectives and their subclasses
through his illuminating analysis of Zielonka trees.
One of the many contributions of Zielonka’s landmark paper <span id="id24">[<span>Zielonka:1998</span>]</span> was to follow McNaughton’s approach for
constructing a recursive algorithm for solving parity games, and show that it implies their positionality.
We follow in <a class="reference internal" href="parity.html#sec-parity"><span class="std std-ref">Section</span></a> Zielonka’s presentation of the algorithm, which is sometimes called Zielonka algorithm but more accurately
McNaughton Zielonka algorithm.</p>
<p>The characterisation result showing how Zielonka tree captures the exact memory requirements of Muller objectives is due to
Dziembowski, Jurdzi{‘n}ski, and Walukiewicz <span id="id25">[<span>Dziembowski&amp;Jurdzinski&amp;Walukiewicz:1997</span>]</span>.</p>
<p>The <span class="math notranslate nohighlight">\(\NP\)</span>-completeness stated in <span class="xref std std-ref">Theorem</span> for solving Rabin games is due to Emerson and Jutla <span id="id26">[<span>Emerson&amp;Jutla:1988</span>]</span>.
The study of the complexity of solving Muller games is due to Dawar and Hunter <span id="id27">[<span>Hunter&amp;Dawar:2005</span>]</span>.
The <span class="math notranslate nohighlight">\(\PSPACE\)</span>-completeness results stated in <span class="xref std std-ref">Theorem</span> only concern two representations for Muller objectives. There are several others, which are not equally succinct.
For all representations but one the <span class="math notranslate nohighlight">\(\PSPACE\)</span>-completeness result holds; the only exception is the explicit representation
where the condition is specified by listing all sets of vertices in <span class="math notranslate nohighlight">\(\F\)</span>.
Surprisingly, solving Muller games with the explicit representation is in <span class="math notranslate nohighlight">\(\P\)</span> as shown by Horn <span id="id28">[<span>Horn:2008</span>]</span>.</p>
<p>Our proof of positionality for Rabin objectives for <span class="xref std std-ref">Theorem</span>
and its extension to submixing objectives <span class="xref std std-ref">Theorem</span>
is inspired by the fairly mixing property of Gimbert and Zielonka <span id="id29">[<span>Gimbert&amp;Zielonka:2004</span>]</span>
and the concave property of Kopczy{‘n}ski <span id="id30">[<span>Kopczynski:2006</span><span>Kopczynski:2008</span>]</span>.
Gimbert and Zielonka <span id="id31">[<span>Gimbert&amp;Zielonka:2005</span>]</span> further refined the submixing property to give a characterisation of objectives which are positionally determined for both players over finite games (they work in the more general framework of preference relations, which includes both qualitative and quantitative objectives).</p>
<p id="id32"><dl class="citation">
<dt class="label" id="id53"><span class="brackets"><a class="fn-backref" href="#id1">Zer13</a></span></dt>
<dd><p>Ernst Zermelo. Uber eine anwendung der mengenlehre auf die theorie des schachspiels. In <em>Proceedings of the International Congress of Mathematicians, ICM'13</em>, volume 2, 501–504. Cambridge University Press, 1913.</p>
</dd>
<dt class="label" id="id48"><span class="brackets"><a class="fn-backref" href="#id7">McN66</a></span></dt>
<dd><p>Robert McNaughton. Testing and generating infinite sequences by a finite automaton. <em>Information and Computation</em>, 9(5):521–530, 1966.</p>
</dd>
<dt class="label" id="id51"><span class="brackets"><a class="fn-backref" href="#id8">Rab69</a></span></dt>
<dd><p>Michael O. Rabin. Decidability of second-order theories and automata on infinite trees. <em>Transactions of the American Mathematical Society</em>, 141:1–35, 1969.</p>
</dd>
<dt class="label" id="id47"><span class="brackets"><a class="fn-backref" href="#id20">McN65</a></span></dt>
<dd><p>Robert McNaughton. Finite-state infinite games. Technical Report, Massachusetts Institute of Technology, 1965.</p>
</dd>
<dt class="label" id="id43"><span class="brackets"><a class="fn-backref" href="#id21">GH82</a></span></dt>
<dd><p>Yuri Gurevich and Leo Harrington. Trees, automata, and games. In <em>Proceedings of the Annual ACM Symposium on Theory of Computing, STOC'82</em>, 60–65. ACM Press, 1982.</p>
</dd>
</dl>
</p>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./2_Classic/1_Regular"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="zielonka.html" title="previous page"><span class="section-number">1.6. </span>The Zielonka tree</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>