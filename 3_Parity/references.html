
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bibliographic references &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Games with Payoffs" href="../4_Payoffs/index.html" />
    <link rel="prev" title="Comparing the three families of algorithms" href="relationships.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../1_Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../2_Regular/index.html">
   Regular Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/attractors.html">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/buchi.html">
     Büchi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Parity Games
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Games with Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../5_MDP/index.html">
   Markov Decision Processes
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reachability.html">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="bibliographic-references">
<span id="sec-references"></span><h1>Bibliographic references<a class="headerlink" href="#bibliographic-references" title="Permalink to this headline">¶</a></h1>
<div class="math notranslate nohighlight">
\[\renewcommand{\H}{\mathcal{H}} 
\newcommand{\Lift}{\textrm{Lift}} 
\newcommand{\F}{\mathcal{F}} 
\newcommand{\sinit}{\sigma_{\textnormal{init}}}
\newcommand{\siblank}{\mathtt{-}}
\newcommand{\Eve}{\textrm{Eve}}
\newcommand{\Adam}{\textrm{Adam}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zinfty}{\Z \cup \set{\pm \infty}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rinfty}{\R \cup \set{\pm \infty}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Qinfty}{\Q \cup \set{\pm \infty}}
\newcommand{\argmax}{\textrm{argmax}}
\newcommand{\argmin}{\textrm{argmin}}
\newcommand{\Op}{\mathbb{O}}
\newcommand{\Prob}{\mathbb{P}} \newcommand{\dist}{\mathcal{D}} \newcommand{\Dist}{\dist} \newcommand{\supp}{\textrm{supp}} 
\newcommand{\game}{\mathcal{G}} \renewcommand{\Game}{\game} \newcommand{\arena}{\mathcal{A}} \newcommand{\Arena}{\arena} 
\newcommand{\col}{\textsf{col}} \newcommand{\Col}{\col} 
\newcommand{\mEve}{\mathrm{Eve}}
\newcommand{\mAdam}{\mathrm{Adam}}
\newcommand{\mRandom}{\mathrm{Random}}
\newcommand{\vertices}{V} \newcommand{\VE}{V_\mEve} \newcommand{\VA}{V_\mAdam} \newcommand{\VR}{V_\mRandom} 
\newcommand{\ing}{\textrm{In}}
\newcommand{\Ing}{\ing}
\newcommand{\out}{\textrm{Out}}
\newcommand{\Out}{\out}
\newcommand{\dest}{\Delta} 
\newcommand{\WE}{W_\mEve} \newcommand{\WA}{W_\mAdam} 
\newcommand{\Paths}{\textrm{Paths}} \newcommand{\play}{\pi} \newcommand{\first}{\textrm{first}} \newcommand{\last}{\textrm{last}} 
\newcommand{\mem}{\mathcal{M}} \newcommand{\Mem}{\mem} 
\newcommand{\Pre}{\textrm{Pre}} \newcommand{\PreE}{\textrm{Pre}_\mEve} \newcommand{\PreA}{\textrm{Pre}_\mAdam} \newcommand{\Attr}{\textrm{Attr}} \newcommand{\AttrE}{\textrm{Attr}_\mEve} \newcommand{\AttrA}{\textrm{Attr}_\mAdam} \newcommand{\rank}{\textrm{rank}}
\newcommand{\Win}{\textrm{Win}} 
\newcommand{\Lose}{\textrm{Lose}} 
\newcommand{\Value}{\textrm{val}} 
\newcommand{\ValueE}{\textrm{val}_\mEve} 
\newcommand{\ValueA}{\textrm{val}_\mAdam}
\newcommand{\val}{\Value} 
\newcommand{\Automaton}{\mathbf{A}} 
\newcommand{\Safe}{\mathtt{Safe}}
\newcommand{\Reach}{\mathtt{Reach}} 
\newcommand{\Buchi}{\mathtt{Buchi}} 
\newcommand{\CoBuchi}{\mathtt{CoBuchi}} 
\newcommand{\Parity}{\mathtt{Parity}} 
\newcommand{\Muller}{\mathtt{Muller}} 
\newcommand{\Rabin}{\mathtt{Rabin}} 
\newcommand{\Streett}{\mathtt{Streett}} 
\newcommand{\MeanPayoff}{\mathtt{MeanPayoff}} 
\newcommand{\DiscountedPayoff}{\mathtt{DiscountedPayoff}}
\newcommand{\Energy}{\mathtt{Energy}}
\newcommand{\TotalPayoff}{\mathtt{TotalPayoff}}
\newcommand{\ShortestPath}{\mathtt{ShortestPath}}
\newcommand{\Sup}{\mathtt{Sup}}
\newcommand{\Inf}{\mathtt{Inf}}
\newcommand{\LimSup}{\mathtt{LimSup}}
\newcommand{\LimInf}{\mathtt{LimInf}}
\newcommand{\NL}{\textrm{NL}}
\newcommand{\PTIME}{\textrm{PTIME}}
\newcommand{\NP}{\textrm{NP}}
\newcommand{\coNP}{\textrm{coNP}}
\newcommand{\PSPACE}{\textrm{PSPACE}}\]</div>
<p>We refer to Section <a class="reference internal" href="../2_Regular/references.html#sec-references"><span class="std std-ref">Bibliographic references</span></a> for the role of parity objectives and how they emerged in automata theory as a subclass of Muller objectives.
Another related motivation comes from the works of Emerson, Jutla, and Sistla <span id="id1">[<a class="reference internal" href="#id77"><span>EJS93</span></a>]</span>,
who showed that solving parity games is linear-time equivalent to the model-checking problem for modal <span class="math notranslate nohighlight">\(\mu\)</span>-calculus.
This logical formalism is an established tool in program verification, and a common denominator to a wide range of modal, temporal and fixpoint logics used in various fields.</p>
<p>Let us discuss the progress obtained over the years for each of the three families of algorithms.</p>
<p><strong>Value iteration algorithms and separating automata</strong>.
The heart of value iteration algorithms is the value function, which in the context of parity games and related developments for automata
have been studied under the name progress measures or signatures.
They appear naturally in the context of fixed point computations so it is hard to determine who first introduced them.
Streett and Emerson <span id="id2">[<a class="reference internal" href="#id93"><span>SE84</span></a>,<a class="reference internal" href="#id92"><span>SE89</span></a>]</span> defined signatures for the study of the modal <span class="math notranslate nohighlight">\(\mu\)</span>-calculus,
and Stirling and Walker <span id="id3">[<a class="reference internal" href="#id75"><span>SW89</span></a>]</span> later developped the notion.
Both the proofs of Emerson and Jutla <span id="id4">[<a class="reference internal" href="../2_Regular/references.html#id59"><span>EJ91</span></a>]</span> and of Walukiewicz <span id="id5">[<a class="reference internal" href="#id94"><span>Wal96</span></a>]</span> use signatures to show the positionality of parity games over infinite games.</p>
<p>Jurdziński <span id="id6">[<a class="reference internal" href="#id82"><span>Jurdzinski00</span></a>]</span> used this notion to give the first value iteration algorithm for parity games,
with running time <span class="math notranslate nohighlight">\(O(m n^{d/2})\)</span>.
The algorithm is called small progress measures and is an instance of the class of value iteration algorithms we construct
in Section <a class="reference internal" href="value_iteration.html#sec-value-iteration"><span class="std std-ref">A quasipolynomial time value iteration algorithm</span></a> by considering the universal tree of size <span class="math notranslate nohighlight">\(n^h\)</span>.
Bernet, Janin, and Walukiewicz <span id="id7">[<a class="reference internal" href="#id70"><span>BJW02</span></a>]</span> investigated reductions from parity games to safety games
through the notion of permissive strategies, and constructed a separating automaton<code class="docutils literal notranslate"><span class="pre">{margin}</span> <span class="pre">We</span> <span class="pre">note</span> <span class="pre">that</span> <span class="pre">the</span> <span class="pre">general</span> <span class="pre">framework</span> <span class="pre">of</span> <span class="pre">separating</span> <span class="pre">automata</span> <span class="pre">came</span> <span class="pre">later,</span> <span class="pre">introduced</span> <span class="pre">by</span> <span class="pre">Boja{\'</span></code>czyk and Czerwiński <span id="id8">[<a class="reference internal" href="#id71"><span>BojanczykCzerwinski18</span></a>]</span>.} corresponding to the universal tree of size <span class="math notranslate nohighlight">\(n^h\)</span>.</p>
<p>The new era for parity games started in 2017 when Calude, Jain, Khoussainov, Li, and Stephan <span id="id9">[<a class="reference internal" href="#id73"><span>CJK+17</span></a>]</span> constructed a quasipolynomial time algorithm.
Our presentation follows the technical developments of the subsequent paper by Fearnley, Jain, Schewe, Stephan, and Wojtczak <span id="id10">[<a class="reference internal" href="#id80"><span>FJS+17</span></a>]</span> which recasts the algorithm as a value iteration algorithm.
Bojańczyk and Czerwiński <span id="id11">[<a class="reference internal" href="#id71"><span>BojanczykCzerwinski18</span></a>]</span> introduce the separation framework to better understand the original algorithm.</p>
<p>Soon after two other quasipolynomial time algorithms emerged.
Jurdziński and Lazi{‘c} <span id="id12">[<a class="reference internal" href="#id84"><span>JurdzinskiLazic17</span></a>]</span> showed that the small progress measure algorithm can be adapted to a succinct progress measure algorithm, matching (and slightly improving) the quasipolynomial time complexity.
The presentation using universal tree that we follow in Section <a class="reference internal" href="value_iteration.html#sec-value-iteration"><span class="std std-ref">A quasipolynomial time value iteration algorithm</span></a> and an almost matching lower bound on their sizes is due to Fijalkow <span id="id13">[<a class="reference internal" href="#id78"><span>Fij18</span></a>]</span>.
The connection between separating automata and universal trees was shown by Czerwiński, Daviaud, Fijalkow, Jurdziński, Lazi{‘c}, and Parys <span id="id14">[<a class="reference internal" href="#id76"><span>CzerwinskiDF+19</span></a>]</span>.</p>
<p>The third quasipolynomial time algorithm is due to Lehtinen <span id="id15">[<a class="reference internal" href="#id87"><span>Leh18</span></a>]</span>.
The original algorithm has a slightly worse complexity (<span class="math notranslate nohighlight">\(n^{O(\log(n))}\)</span> instead of <span class="math notranslate nohighlight">\(n^{O(\log(d))}\)</span>),
but Parys <span id="id16">[<a class="reference internal" href="#id90"><span>Par20</span></a>]</span> later improved the construction to (essentially) match the complexity of the previous two algorithms.
Although not explicitly, the algorithm constructs an automaton with similar properties as a separating automaton,
but the automaton is non-deterministic.
Colcombet and Fijalkow <span id="id17">[<a class="reference internal" href="#id74"><span>CF19</span></a>]</span> revisited the link between separating automata and universal trees
and proposed the notion of good for small games automata, capturing the automaton defined by Lehtinen’s algorithm.
The equivalence result between separating automata, good for small games automata, and universal graphs, holds for any positionally determined objective, giving a strong theoretical foundation for the family of value iteration algorithms.</p>
<p><strong>Attractor decomposition algorithms</strong>.
The McNaughton Zielonka’s algorithm has complexity <span class="math notranslate nohighlight">\(O(m n^d)\)</span>.
Parys <span id="id18">[<a class="reference internal" href="#id89"><span>Par19</span></a>]</span> constructed the fourth quasipolynomial time algorithm as an improved take over McNaughton Zielonka’s algorithm.
As for Lehtinen’s algorithm, the original algorithm has a slightly worse complexity (<span class="math notranslate nohighlight">\(n^{O(\log(n))}\)</span> instead of <span class="math notranslate nohighlight">\(n^{O(\log(d))}\)</span>).
Lehtinen, Schewe, and Wojtczak <span id="id19">[<a class="reference internal" href="#id88"><span>LSW19</span></a>]</span> later improved the construction.
As discussed in Section <a class="reference internal" href="relationships.html#sec-relationships"><span class="std std-ref">Comparing the three families of algorithms</span></a> the complexity of this algorithm is quasipolynomial and of the form <span class="math notranslate nohighlight">\(n^{O(\log(d))}\)</span>,
but a bit worse than the three previous algorithms since the algorithm is symmetric and has a recursion depth of <span class="math notranslate nohighlight">\(d\)</span>,
while the value iteration algorithms only consider odd priorities hence replace <span class="math notranslate nohighlight">\(d\)</span> by <span class="math notranslate nohighlight">\(d/2\)</span>.</p>
<p>Jurdziński and Morvan <span id="id20">[<a class="reference internal" href="#id85"><span>JurdzinskiM20</span></a>]</span> constructed a generic McNaughton Zielonka’s algorithm parameterised by the choice of two universal trees, one for each player.
\mynote{CONTINUE}</p>
<p><strong>Strategy improvement algorithms</strong>.
As we will see in Chapter <span class="xref std std-ref">4-chap:payoff</span>, parity games can be reduced to mean payoff games,
so any algorithm for solving mean payoff games can be used for solving parity games.
In particular, the existing strategy improvement algorithm for mean payoff games can be run on parity games.
V{“o}ge and Jurdzinński <span id="id21">[<a class="reference internal" href="#id91"><span>VogeJurdzinski00</span></a>]</span> introduced the first discrete strategy improvement for parity games,
running in exponential time.
For some time there was some hope that the strategy improvement algorithm, for some well chosen policy on switching edges,
solves parity games in polynomial time.
Friedmann <span id="id22">[<a class="reference internal" href="#id81"><span>Fri11</span></a>]</span> cast some serious doubts by constructing numerous exponential lower bounds applying to different variants of the algorithm.
Fearnley <span id="id23">[<a class="reference internal" href="#id79"><span>Fea17</span></a>]</span> investigated efficient implementations of the algorithm, focussing on the cost of computing and updating the value function for a given strategy.
Our proof of correctness is original. \mynote{SAY MORE?}</p>
<p>The complexity was reduced to subexponential with randomised algorithms
by Jurdzinński, Paterson, and Zwick <span id="id24">[<a class="reference internal" href="#id83"><span>JurdzinskiPZ08</span></a>]</span>.
A natural question is whether there exists a quasipolynomial strategy improvement algorithm;
as discussed in Section <a class="reference internal" href="relationships.html#sec-relationships"><span class="std std-ref">Comparing the three families of algorithms</span></a> the notion of universal trees cannot be used to achieve this,
and the question remains to this day open.</p>
<p id="id25"><dl class="citation">
<dt class="label" id="id77"><span class="brackets"><a class="fn-backref" href="#id1">EJS93</a></span></dt>
<dd><p>E. Allen Emerson, Charanjit S. Jutla, and A. Prasad Sistla. On model-checking for fragments of µ-calculus. In <em>Proceedings of the International Conference on Computer Aided Verification, CAV'93</em>, volume 697 of LNCS, 385–396. Springer-Verlag, 1993.</p>
</dd>
<dt class="label" id="id93"><span class="brackets"><a class="fn-backref" href="#id2">SE84</a></span></dt>
<dd><p>Robert S. Streett and E. Allen Emerson. The propositional mu-calculus is elementary. In <em>Proceedings of the International Colloquium on Automata, Languages and Programming, ICALP'84</em>. 1984.</p>
</dd>
<dt class="label" id="id92"><span class="brackets"><a class="fn-backref" href="#id2">SE89</a></span></dt>
<dd><p>Robert S. Streett and E. Allen Emerson. An automata theoretic decision procedure for the propositional mu-calculus. <em>Information and Computation</em>, 81(3):249–264, 1989.</p>
</dd>
<dt class="label" id="id75"><span class="brackets"><a class="fn-backref" href="#id3">SW89</a></span></dt>
<dd><p>Colin Stirling and David Walker. Local model checking in the modal mu-calculus. In <em>Proceedings of the International Joint Conference on Theory and Practice of Software Development, TAPSOFT'89</em>, 369–383. 1989.</p>
</dd>
<dt class="label" id="id94"><span class="brackets"><a class="fn-backref" href="#id5">Wal96</a></span></dt>
<dd><p>Igor Walukiewicz. Pushdown processes: games and model checking. In <em>Proceedings of the International Conference on Computer Aided Verification, CAV'96</em>, volume 1102 of LNCS, 62–74. Springer-Verlag, 1996.</p>
</dd>
<dt class="label" id="id82"><span class="brackets"><a class="fn-backref" href="#id6">Jurdzinski00</a></span></dt>
<dd><p>Marcin Jurdziński. Small progress measures for solving parity games. In <em>Proceedings of the International Symposium on Theoretical Aspects of Computer Science, STACS'00</em>, 290–301. 2000.</p>
</dd>
<dt class="label" id="id70"><span class="brackets"><a class="fn-backref" href="#id7">BJW02</a></span></dt>
<dd><p>Julien Bernet, David Janin, and Igor Walukiewicz. Permissive strategies: from parity games to safety games. <em>Theoretical Informatics and Applications</em>, 36(3):261–275, 2002.</p>
</dd>
<dt class="label" id="id71"><span class="brackets">BojanczykCzerwinski18</span><span class="fn-backref">(<a href="#id8">1</a>,<a href="#id11">2</a>)</span></dt>
<dd><p>Mikołaj Bojańczyk and Wojciech Czerwiński. An automata toolbox. February 2018.</p>
</dd>
<dt class="label" id="id73"><span class="brackets"><a class="fn-backref" href="#id9">CJK+17</a></span></dt>
<dd><p>Cristian S. Calude, Sanjay Jain, Bakhadyr Khoussainov, Wei Li, and Frank Stephan. Deciding parity games in quasipolynomial time. In <em>Proceedings of the Annual ACM Symposium on Theory of Computing, STOC'17</em>, 252–263. 2017.</p>
</dd>
<dt class="label" id="id80"><span class="brackets"><a class="fn-backref" href="#id10">FJS+17</a></span></dt>
<dd><p>John Fearnley, Sanjay Jain, Sven Schewe, Frank Stephan, and Dominik Wojtczak. An ordered approach to solving parity games in quasi polynomial time and quasi linear space. In <em>Proceedings of the International SPIN Workshop on Model Checking of Software, SPIN'17</em>, 112–121. 2017.</p>
</dd>
<dt class="label" id="id84"><span class="brackets"><a class="fn-backref" href="#id12">JurdzinskiLazic17</a></span></dt>
<dd><p>Marcin Jurdziński and Ranko Lazić. Succinct progress measures for solving parity games. In <em>Proceedings of the Annual IEEE Symposium on Logic in Computer Science, LICS'17</em>. 2017.</p>
</dd>
<dt class="label" id="id78"><span class="brackets"><a class="fn-backref" href="#id13">Fij18</a></span></dt>
<dd><p>Nathanaël Fijalkow. An optimal value iteration algorithm for parity games. <em>CoRR</em>, 2018.</p>
</dd>
<dt class="label" id="id76"><span class="brackets"><a class="fn-backref" href="#id14">CzerwinskiDF+19</a></span></dt>
<dd><p>Wojciech Czerwiński, Laure Daviaud, Nathanaël Fijalkow, Marcin Jurdziński, Ranko Lazić, and Paweł Parys. Universal trees grow inside separating automata: quasi-polynomial lower bounds for parity games. In <em>Proceedings of the Symposium on Discrete Algorithms, SODA'19</em>. 2019.</p>
</dd>
<dt class="label" id="id87"><span class="brackets"><a class="fn-backref" href="#id15">Leh18</a></span></dt>
<dd><p>Kaorliina Lehtinen. A modal-µ perspective on solving parity games in quasi-polynomial time. In <em>Proceedings of the Annual IEEE Symposium on Logic in Computer Science, LICS'18</em>, 639–648. 2018.</p>
</dd>
<dt class="label" id="id90"><span class="brackets"><a class="fn-backref" href="#id16">Par20</a></span></dt>
<dd><p>Paweł Parys. Parity games: another view on lehtinen's algorithm. In <em>Proceedings of the EACSL Annual Conference on Computer Science and Logic, CSL'20</em>, 32:1–32:15. 2020.</p>
</dd>
<dt class="label" id="id74"><span class="brackets"><a class="fn-backref" href="#id17">CF19</a></span></dt>
<dd><p>Thomas Colcombet and Nathanaël Fijalkow. Universal graphs and good for games automata: new tools for infinite duration games. In <em>Proceedings of the International Conference on the Foundations of Software Science and Computational Structures, FoSSaCS'19</em>, 1–26. 2019.</p>
</dd>
<dt class="label" id="id89"><span class="brackets"><a class="fn-backref" href="#id18">Par19</a></span></dt>
<dd><p>Paweł Parys. Parity games: zielonka's algorithm in quasi-polynomial time. In <em>Proceedings of the International Symposium on Mathematical Foundations of Computer Science, MFCS'19</em>, 10:1–10:13. 2019.</p>
</dd>
<dt class="label" id="id88"><span class="brackets"><a class="fn-backref" href="#id19">LSW19</a></span></dt>
<dd><p>Kaorliina Lehtinen, Sven Schewe, and Dominik Wojtczak. Improving the complexity of parys' recursive algorithm. <em>CoRR</em>, 2019.</p>
</dd>
<dt class="label" id="id85"><span class="brackets"><a class="fn-backref" href="#id20">JurdzinskiM20</a></span></dt>
<dd><p>Marcin Jurdziński and Rémi Morvan. A universal attractor decomposition algorithm for parity games. <em>CoRR</em>, 2020.</p>
</dd>
<dt class="label" id="id91"><span class="brackets"><a class="fn-backref" href="#id21">VogeJurdzinski00</a></span></dt>
<dd><p>Jens Vöge and Marcin Jurdziński. A discrete strategy improvement algorithm for solving parity games. In <em>Proceedings of the International Conference on Computer Aided Verification, CAV'00</em>, 202–215. 2000.</p>
</dd>
<dt class="label" id="id81"><span class="brackets"><a class="fn-backref" href="#id22">Fri11</a></span></dt>
<dd><p>Oliver Friedmann. An exponential lower bound for the latest deterministic strategy iteration algorithms. <em>Logical Methods in Computer Science</em>, 2011.</p>
</dd>
<dt class="label" id="id79"><span class="brackets"><a class="fn-backref" href="#id23">Fea17</a></span></dt>
<dd><p>John Fearnley. Efficient parallel strategy improvement for parity games. In <em>Proceedings of the International Conference on Computer Aided Verification, CAV'17</em>, 137–154. 2017.</p>
</dd>
<dt class="label" id="id83"><span class="brackets"><a class="fn-backref" href="#id24">JurdzinskiPZ08</a></span></dt>
<dd><p>Marcin Jurdziński, Mike Paterson, and Uri Zwick. A deterministic subexponential algorithm for solving parity games. <em>SIAM Journal on Computing</em>, 38(4):1519–1532, 2008.</p>
</dd>
</dl>
</p>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./3_Parity"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="relationships.html" title="previous page">Comparing the three families of algorithms</a>
    <a class='right-next' id="next-link" href="../4_Payoffs/index.html" title="next page">Games with Payoffs</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>