
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Positive and almost-sure reachability and safety in MDPs &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Discounted payoff in MDPs" href="discounted.html" />
    <link rel="prev" title="Notations" href="notations.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../1_Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../2_Regular/index.html">
   Regular Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/attractors.html">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/buchi.html">
     BÃ¼chi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../3_Parity/index.html">
   Parity Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Games with Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Markov Decision Processes
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="positive-and-almost-sure-reachability-and-safety-in-mdps">
<span id="sec-reachability"></span><h1>Positive and almost-sure reachability and safety in MDPs<a class="headerlink" href="#positive-and-almost-sure-reachability-and-safety-in-mdps" title="Permalink to this headline">Â¶</a></h1>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\newcommand{\expv}{\mathbb{E}} \newcommand{\discProbDist}{f} \newcommand{\sampleSpace}{S} \newcommand{\sigmaAlg}{\mathcal{F}} \newcommand{\probm}{\mathbb{P}} \newcommand{\rvar}{X} \\\newcommand{\actions}{A} \newcommand{\colouring}{c} \newcommand{\probTranFunc}{\Delta} \newcommand{\edges}{E} \newcommand{\colours}{C} \newcommand{\mdp}{\mathcal{M}} \newcommand{\vinit}{v_0} \newcommand{\cylProb}{p} \newcommand{\emptyPlay}{\epsilon} \newcommand{\objective}{\Omega} \newcommand{\genColour}{\textsc{c}} \newcommand{\quantObj}{f} \newcommand{\quantObjExt}{\bar{\quantObj}} \newcommand{\indicator}[1]{\mathbf{1}_{#1}} \newcommand{\eps}{\varepsilon} \newcommand{\maxc}{\max_{\colouring}} 
\newcommand{\winPos}{W_{&gt;0}}
\newcommand{\winAS}{W_{=1}}
\newcommand{\cylinder}{\mathit{Cyl}}
\newcommand{\PrePos}{\text{Pre}_{&gt;0}}
\newcommand{\PreAS}{\text{Pre}_{=1}}
\newcommand{\PreOPPos}{\mathcal{P}_{&gt;0}}
\newcommand{\OPAS}{\mathcal{P}_{=1}}
\newcommand{\safeOP}{\mathit{Safe_{=1}}}
\newcommand{\closed}{\mathit{Cl}}\\\newcommand{\reachOP}{\mathcal{V}}
\newcommand{\discOP}{\mathcal{D}}
\newcommand{\valsigma}{\vec{x}^{\sigma}}
\newcommand{\lp}{\mathcal{L}}
\newcommand{\lpdisc}{\lp_{\mathit{disc}}}
\newcommand{\lpreach}{\lp_{\mathit{reach}}}
\newcommand{\lpmp}{\lp_{\mathit{mp}}}
\newcommand{\lpsol}[1]{\bar{\vec{#1}}}
\newcommand{\lpsolg}[1]{\bar{#1}}
\newcommand{\lpmpdual}{\lpmp^{\mathit{dual}}}
\newcommand{\actevent}[3]{\actions^{#1}_{#2,#3}} 
\newcommand{\MeanPayoffSup}{\MeanPayoff^{\;+}}
\newcommand{\MeanPayoffInf}{\MeanPayoff^{\;-}}
\newcommand{\mcprob}{P}
\newcommand{\invdist}{\vec{z}}
\newcommand{\hittime}{T}
\newcommand{\playPay}{\textsf{p-Payoff}}
\newcommand{\stepPay}{\textsf{s-Payoff}}
\newcommand{\Pay}{\textsf{Payoff}}
\newcommand{\mec}{M}
\newcommand{\OPS}{\mathcal{S}_{=1}}
\newcommand{\smallmp}{\mathit{mp}}
\newcommand{\vgood}{v_{\mathit{good}}}
\newcommand{\vbad}{v_{\mathit{bad}}}
\newcommand{\finact}{fin}
\newcommand{\mecs}{\mathit{MEC}}
\newcommand{\slice}[2]{#1_{#2-}}
\newcommand{\ReachOp}{\mathcal{R}}
\newcommand{\dPayoffStep}[1]{\DiscountedPayoff^{\;(#1)}}
\newcommand{\solvset}{S}
\newcommand{\Eve}{\textrm{Eve}}
\newcommand{\Adam}{\textrm{Adam}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zinfty}{\Z \cup \set{\pm \infty}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rinfty}{\R \cup \set{\pm \infty}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Qinfty}{\Q \cup \set{\pm \infty}}
\newcommand{\argmax}{\textrm{argmax}}
\newcommand{\argmin}{\textrm{argmin}}
\newcommand{\Op}{\mathbb{O}}
\newcommand{\Prob}{\mathbb{P}} \newcommand{\dist}{\mathcal{D}} \newcommand{\Dist}{\dist} \newcommand{\supp}{\textrm{supp}} 
\newcommand{\game}{\mathcal{G}} \renewcommand{\Game}{\game} \newcommand{\arena}{\mathcal{A}} \newcommand{\Arena}{\arena} 
\newcommand{\col}{\textsf{col}} \newcommand{\Col}{\col} 
\newcommand{\mEve}{\mathrm{Eve}}
\newcommand{\mAdam}{\mathrm{Adam}}
\newcommand{\mRandom}{\mathrm{Random}}
\newcommand{\vertices}{V} \newcommand{\VE}{V_\mEve} \newcommand{\VA}{V_\mAdam} \newcommand{\VR}{V_\mRandom} 
\newcommand{\ing}{\textrm{In}}
\newcommand{\Ing}{\ing}
\newcommand{\out}{\textrm{Out}}
\newcommand{\Out}{\out}
\newcommand{\dest}{\Delta} 
\newcommand{\WE}{W_\mEve} \newcommand{\WA}{W_\mAdam} 
\newcommand{\Paths}{\textrm{Paths}} \newcommand{\play}{\pi} \newcommand{\first}{\textrm{first}} \newcommand{\last}{\textrm{last}} 
\newcommand{\mem}{\mathcal{M}} \newcommand{\Mem}{\mem} 
\newcommand{\Pre}{\textrm{Pre}} \newcommand{\PreE}{\textrm{Pre}_\mEve} \newcommand{\PreA}{\textrm{Pre}_\mAdam} \newcommand{\Attr}{\textrm{Attr}} \newcommand{\AttrE}{\textrm{Attr}_\mEve} \newcommand{\AttrA}{\textrm{Attr}_\mAdam} \newcommand{\rank}{\textrm{rank}}
\newcommand{\Win}{\textrm{Win}} 
\newcommand{\Lose}{\textrm{Lose}} 
\newcommand{\Value}{\textrm{val}} 
\newcommand{\ValueE}{\textrm{val}_\mEve} 
\newcommand{\ValueA}{\textrm{val}_\mAdam}
\newcommand{\val}{\Value} 
\newcommand{\Automaton}{\mathbf{A}} 
\newcommand{\Safe}{\mathtt{Safe}}
\newcommand{\Reach}{\mathtt{Reach}} 
\newcommand{\Buchi}{\mathtt{Buchi}} 
\newcommand{\CoBuchi}{\mathtt{CoBuchi}} 
\newcommand{\Parity}{\mathtt{Parity}} 
\newcommand{\Muller}{\mathtt{Muller}} 
\newcommand{\Rabin}{\mathtt{Rabin}} 
\newcommand{\Streett}{\mathtt{Streett}} 
\newcommand{\MeanPayoff}{\mathtt{MeanPayoff}} 
\newcommand{\DiscountedPayoff}{\mathtt{DiscountedPayoff}}
\newcommand{\Energy}{\mathtt{Energy}}
\newcommand{\TotalPayoff}{\mathtt{TotalPayoff}}
\newcommand{\ShortestPath}{\mathtt{ShortestPath}}
\newcommand{\Sup}{\mathtt{Sup}}
\newcommand{\Inf}{\mathtt{Inf}}
\newcommand{\LimSup}{\mathtt{LimSup}}
\newcommand{\LimInf}{\mathtt{LimInf}}
\newcommand{\NL}{\textrm{NL}}
\newcommand{\PTIME}{\textrm{PTIME}}
\newcommand{\NP}{\textrm{NP}}
\newcommand{\coNP}{\textrm{coNP}}
\newcommand{\PSPACE}{\textrm{PSPACE}}\end{aligned}\end{align} \]</div>
<blockquote>
<div><p><strong>Positive reachability</strong></p>
</div></blockquote>
<p>Analogously to classical games (cf. Chapter <a class="reference internal" href="../2_Regular/index.html#chap-regular"><span class="std std-ref">Regular Games</span></a>), we define a one-step <strong>positive
probability</strong> predecessor
operator, <span class="math notranslate nohighlight">\(\PrePos\)</span>,
as follows: for <span class="math notranslate nohighlight">\(U\subseteq \vertices\)</span> we put</p>
<p>\begin{align*}
\PrePos(U) &amp;= {v \in \vertices \mid \exists a \in \actions, \exists u \in U:
\probTranFunc(u\mid v,a)&gt;0 }.\
\end{align*}</p>
<p>We also define an operator <span class="math notranslate nohighlight">\(\PreOPPos\)</span> s.t. for each <span class="math notranslate nohighlight">\(X\subseteq\vertices\)</span> we have</p>
<div class="math notranslate nohighlight">
\[
\PreOPPos(X) = X\cup \PrePos(X).
\]</div>
<p>It is easy to see that <span class="math notranslate nohighlight">\(\PreOPPos\)</span> is a classical
reachability operator in the underlying graph of the MDP, i.e. denoting <span class="math notranslate nohighlight">\(X_0 = 
X\)</span> and <span class="math notranslate nohighlight">\(X_i = \PreOPPos(X_{i-1})\)</span>, we get that <span class="math notranslate nohighlight">\(X_i\)</span> is exactly the set of
vertices from which a vertex of <span class="math notranslate nohighlight">\(X\)</span> is reachable via a finite play of length at
most <span class="math notranslate nohighlight">\(i\)</span>. It follows that iterating <span class="math notranslate nohighlight">\(\PreOPPos\)</span> on any initial set reaches a
fixed point in at most <span class="math notranslate nohighlight">\(n-1\)</span> steps, where <span class="math notranslate nohighlight">\(n=|\vertices|\)</span>.</p>
<p>We have the following simple characterization of the positively winning set:</p>
<div class="proof theorem admonition" id="5-thm:positive-char">
<p class="admonition-title"><span>Theorem </span> (Characterisation of the positively winning set)</p>
<div class="theorem-content section" id="proof-content">
<p>For each vertex <span class="math notranslate nohighlight">\(v\)</span>, the following conditions are equivalent:</p>
<ol class="simple">
<li><p>The vertex <span class="math notranslate nohighlight">\(v\)</span> belongs to <span class="math notranslate nohighlight">\(\winPos(\mdp,\Reach(\genColour))\)</span>.</p></li>
<li><p>There
exists a (possibly empty) finite play from <span class="math notranslate nohighlight">\(v\)</span> to a vertex of colour <span class="math notranslate nohighlight">\(\genColour\)</span>.</p></li>
<li><p>The vertex <span class="math notranslate nohighlight">\(v\)</span>
belongs to the fixed point of the iteration <span class="math notranslate nohighlight">\(\vertices_\genColour, 
\PreOPPos(\vertices_\genColour),\PreOPPos^2(\vertices_\genColour),\cdots\)</span>.</p></li>
</ol>
<p>Moreover, there exists a memoryless deterministic strategy that is positively
winning from each vertex in <span class="math notranslate nohighlight">\(\winPos(\mdp,\Reach(\genColour))\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p><span class="math notranslate nohighlight">\((1)\Rightarrow(2)\)</span>: We have that <span class="math notranslate nohighlight">\(\Reach(\genColour) = \cup_{\play \in X} 
\cylinder(\pi)\)</span>, where <span class="math notranslate nohighlight">\(X\)</span> is the set of all finite plays ending in a vertex of
colour <span class="math notranslate nohighlight">\(\genColour\)</span> and <span class="math notranslate nohighlight">\(\cylinder(\pi)\)</span> is the basic cylinder determined by
<span class="math notranslate nohighlight">\(\pi\)</span>. Since <span class="math notranslate nohighlight">\(X\)</span> is a countable set, from the property (3.) of a probability
measure it follows that <span class="math notranslate nohighlight">\(\probm^\sigma_{\mdp,v}(\Reach(\genColour))&gt;0\)</span> if and
only if there exists <span class="math notranslate nohighlight">\(\play\in X\)</span> with
<span class="math notranslate nohighlight">\(\probm^\sigma_{\mdp,v}(\cylinder(\play))&gt;0\)</span>.<code class="docutils literal notranslate"><span class="pre">{margin}</span> <span class="pre">Arguments</span> <span class="pre">of</span> <span class="pre">this</span> <span class="pre">style</span> <span class="pre">are</span> <span class="pre">said</span> <span class="pre">to</span> <span class="pre">invoke</span> <span class="pre">a</span> <span class="pre">union</span> <span class="pre">bound.</span></code> For the latter to hold, it must
be that either <span class="math notranslate nohighlight">\(\play=\emptyPlay\)</span>, in which case <span class="math notranslate nohighlight">\(\colours(v)=\genColour\)</span>, or
<span class="math notranslate nohighlight">\(\play\)</span> is a non-empty play initiated in <span class="math notranslate nohighlight">\(v\)</span> and reaching a colour
<span class="math notranslate nohighlight">\(\genColour\)</span>, as required.</p>
<p><span class="math notranslate nohighlight">\((2)\Rightarrow(3)\)</span>:
This is straightforward.</p>
<p><span class="math notranslate nohighlight">\((3)\Rightarrow (1)\)</span>:
For a vertex <span class="math notranslate nohighlight">\(v\)</span>, let <span class="math notranslate nohighlight">\(\rank(v)\)</span> be the smallest <span class="math notranslate nohighlight">\(i\)</span> such that <span class="math notranslate nohighlight">\(v \in 
\PreOPPos^i(\vertices_\genColour)\)</span> (if no such <span class="math notranslate nohighlight">\(i\)</span> exists, then
<span class="math notranslate nohighlight">\(\rank(v)=\infty\)</span>). For each <span class="math notranslate nohighlight">\(v\)</span> with a positive rank there exists an action
<span class="math notranslate nohighlight">\(a_v\)</span> and vertex <span class="math notranslate nohighlight">\(u_v\)</span> such that <span class="math notranslate nohighlight">\(\probTranFunc(u_v\mid v,a_v)&gt;0\)</span> and
<span class="math notranslate nohighlight">\(\rank(u_v)&lt; \rank(v)\)</span>. Consider any MD strategy <span class="math notranslate nohighlight">\(  \sigma \)</span> with the following property:
in each vertex of
<span class="math notranslate nohighlight">\(\winPos(\mdp,\Reach(\genColour))\setminus \vertices_{\genColour}\)</span>, <span class="math notranslate nohighlight">\( \sigma \)</span> selects the
action <span class="math notranslate nohighlight">\(a_v\)</span> defined above with probability 1. A straightforward induction on the rank shows that such a <span class="math notranslate nohighlight">\( \sigma \)</span> is positively winning from each vertex of
<span class="math notranslate nohighlight">\(\winPos(\mdp,\Reach(\genColour))\)</span>. This also proves the last part
of the lemma.</p>
</div>
<p>As for complexity, we can focus on the problem of determining whether a given
vertex belongs to <span class="math notranslate nohighlight">\(\winPos(\mdp,\Reach(\genColour))\)</span>.</p>
<div class="proof corollary admonition" id="5-cor:pos-complexity">
<p class="admonition-title"><span>Corollary </span> (Complexity of deciding positive reachability)</p>
<div class="corollary-content section" id="proof-content">
<p>The problem of deciding whether a given vertex of a given MDP belongs to
<span class="math notranslate nohighlight">\(\winPos(\mdp,\Reach(\genColour))\)</span> is \NL-complete. Moreover, the set <span class="math notranslate nohighlight">\(\winPos(\mdp,\Reach(\genColour))\)</span> can be computed in linear time.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p><a class="reference internal" href="#5-thm:positive-char">Theorem </a>
gives a blueprint for a logspace reduction from this problem to the
<strong>s-t-connectivity</strong> problem for directed graphs, and vice versa. The latter
problem is well known to be \NL-complete <span id="id1">[<a class="reference internal" href="references.html#id119"><span>Sav70</span></a>]</span>. Moreover, the set of states from which a target colour is reachable can be computed by a simple graph search (e.g. by BFS), hence in linear time.</p>
</div>
<blockquote>
<div><p><strong>Almost-sure reachability and safety</strong></p>
</div></blockquote>
<p>While the reachability and safety objectives are seemingly dual, in MDPs there is an intimate connection between them.
Letâs start with almost-sure reachability. Consider the  <strong>almost-sure predecessor operator <span class="math notranslate nohighlight">\(\PreAS\)</span></strong>, s.t. for each <span class="math notranslate nohighlight">\(U \subseteq \vertices\)</span> we have
$<span class="math notranslate nohighlight">\(
\PreAS(U) = \{v \in \vertices \mid \exists a \in \actions, \forall t \in 
\vertices: \probTranFunc(t\mid v,a)&gt;0 \Rightarrow t \in U \}.
\)</span>$</p>
<p>One might be tempted to mimic the positive reachability case and perform the iteration <span class="math notranslate nohighlight">\( X \leftarrow X \cup \PreAS(X) \)</span> on the set <span class="math notranslate nohighlight">\( \vertices_{\genColour} \)</span> until a fixed point is reached.
But this
is not correct: consider an MDP with two vertices, <span class="math notranslate nohighlight">\(u,v\)</span>, the latter one being coloured by <span class="math notranslate nohighlight">\(\Win\)</span>. We have only one action <span class="math notranslate nohighlight">\(a\)</span>: in <span class="math notranslate nohighlight">\(v\)</span>, the action self loops on <span class="math notranslate nohighlight">\(v\)</span>, while in <span class="math notranslate nohighlight">\(u\)</span> playing the action either switches moves us to <span class="math notranslate nohighlight">\(v\)</span> or leaves us in <span class="math notranslate nohighlight">\(u\)</span>, both options having probability <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span>. The probability that we <strong>never</strong> reach <span class="math notranslate nohighlight">\(v\)</span> from <span class="math notranslate nohighlight">\(u\)</span> is
equal to <span class="math notranslate nohighlight">\(\lim_{n\rightarrow \infty} \left(\frac{1}{2}\right)^n = 0\)</span>, and hence
<span class="math notranslate nohighlight">\(\winAS(\mdp,\Reach(\Win))=\{u,v\}\)</span>. However, <span class="math notranslate nohighlight">\(\{v\}\cup\PreAS(\{v\})=\{v\}\)</span>, so
<span class="math notranslate nohighlight">\(v\)</span> is not included into the outcome of the iteration. Note that there indeed exists an infinite play which <strong>can</strong> be generated by the strategy and
which
never visits <span class="math notranslate nohighlight">\(v\)</span>, but the probability of generating such a play is <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>Instead, we make a detour via safety. Consider the one-step <strong>almost-sure safety</strong> operator <span class="math notranslate nohighlight">\(\safeOP\)</span> acting on sets of vertices:
\begin{align*}
\safeOP(X)= X \cap \PreAS(X).
\end{align*}
This operator gives rise to a notion of a closed set, which is important for the study of safety objectives in MDPs.</p>
<div class="proof definition admonition" id="5-def:closed_set_MDP">
<p class="admonition-title"><span>Definition </span> (Closed set in an MDP)</p>
<div class="definition-content section" id="proof-content">
<p>A set <span class="math notranslate nohighlight">\(X\)</span> of vertices is closed if <span class="math notranslate nohighlight">\( \safeOP(X)=X\)</span>. A sub-MDP of an MDP <span class="math notranslate nohighlight">\( \mdp \)</span> defined by a closed subset <span class="math notranslate nohighlight">\(X\)</span> of <span class="math notranslate nohighlight">\( \mdp \)</span>âs states is the MDP <span class="math notranslate nohighlight">\(\mdp_X = (X,\edges_X,\probTranFunc_X,\colouring_X)\)</span> defined as follows:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\edges_X\)</span> is obtained from <span class="math notranslate nohighlight">\(\edges\)</span> by removing edges incident to a vertex from <span class="math notranslate nohighlight">\(\vertices\setminus X\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\probTranFunc_X\)</span> is obtained from <span class="math notranslate nohighlight">\(\probTranFunc\subseteq \vertices\times\actions\times\dist(\edges)\)</span> by removing all triples <span class="math notranslate nohighlight">\((v,a,f)\)</span> where either <span class="math notranslate nohighlight">\(v\not \in X\)</span> or where the support of <span class="math notranslate nohighlight">\(f\)</span> is not contained in <span class="math notranslate nohighlight">\(X\)</span>;</p></li>
<li><p><span class="math notranslate nohighlight">\(\colouring_X\)</span> is a restriction of <span class="math notranslate nohighlight">\(\colouring\)</span> to <span class="math notranslate nohighlight">\(X\)</span>.</p></li>
</ul>
<p>We denote by <span class="math notranslate nohighlight">\(\closed(\mdp)\)</span> the set of all closed sets in <span class="math notranslate nohighlight">\(\mdp.\)</span></p>
</div>
</div><p>Intuitively, a set is closed if Eve has a strategy ensuring that she stays in the set forever.</p>
<p>Now consider the iteration of <span class="math notranslate nohighlight">\( X, \safeOP(X),\safeOP^2(X),\ldots \)</span> of the safety operator. Clearly <span class="math notranslate nohighlight">\(\safeOP(X)\subseteq X\)</span>. Hence, the iteration reaches a fixed point in at most <span class="math notranslate nohighlight">\(|\vertices|\)</span> steps. We get the following:</p>
<div class="proof lemma admonition" id="5-lem:safety-iteration">
<p class="admonition-title"><span>Lemma </span> (Inclusion of the least fixed of the safety operator)</p>
<div class="lemma-content section" id="proof-content">
<p>The fixed point of iterating <span class="math notranslate nohighlight">\( \safeOP \)</span> on some initial set <span class="math notranslate nohighlight">\( X \)</span> of <span class="math notranslate nohighlight">\( \mdp \)</span>âs vertices is the largest (w.r.t. inclusion) closed set contained in <span class="math notranslate nohighlight">\( X \)</span>. In particular, a vertex of <span class="math notranslate nohighlight">\( X \)</span> which does not belong to the fixpoint cannot belong to  <span class="math notranslate nohighlight">\(\winAS(\mdp,\Safe(\vertices \setminus X))\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>A straightforward induction on the number of iteration shows that if a vertex <span class="math notranslate nohighlight">\( v \)</span> is removed in an <span class="math notranslate nohighlight">\( i \)</span>-th iteration, then no matter what strategy Eve uses, she has to reach <span class="math notranslate nohighlight">\( \vertices\setminus X \)</span> in at most <span class="math notranslate nohighlight">\( i \)</span> steps with a positive probability. The lemma follows.</p>
</div>
<div class="figure align-center" id="algo-safety">
<img alt="../_images/5-algo:safety.png" src="../_images/5-algo:safety.png" />
<p class="caption"><span class="caption-number">Fig. 39 </span><span class="caption-text">An algorithm computing <span class="math notranslate nohighlight">\(\winAS(\mdp,\Safe(\genColour))\)</span></span><a class="headerlink" href="#algo-safety" title="Permalink to this image">Â¶</a></p>
</div>
<div class="proof theorem admonition" id="5-thm:safety-main">
<p class="admonition-title"><span>Theorem </span> (Complexity of the almost-sure safety winning set)</p>
<div class="theorem-content section" id="proof-content">
<p><a class="reference internal" href="#algo-safety"><span class="std std-numref">Fig. 39</span></a> computes the set <span class="math notranslate nohighlight">\(\winAS(\mdp,\Safe(\genColour))\)</span> in strongly polynomial time. Moreover, there exists a memoryless deterministic strategy, computable in polynomial time, that is almost-surely winning from every vertex of <span class="math notranslate nohighlight">\(\winAS(\mdp,\Safe(\genColour))\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>The correctness follows immediately from  <a class="reference internal" href="#5-lem:safety-iteration">Lemma </a>. The algorithm makes at most linearly many iterations, each of which has at most linear complexity. Hence, the complexity is at most quadratic. The strong polynomiality is testified by the fact that the algorithm only tests whether a
probability of a given transition is positive or not, for which the exact
values of positive probabilities are irrelevant. Clearly the output of the algorithm is a closed set, and hence for each <span class="math notranslate nohighlight">\( v\in  \winAS(\mdp,\Safe(\genColour))\)</span> there is an action <span class="math notranslate nohighlight">\( a_v \)</span> such that all edges in the support of <span class="math notranslate nohighlight">\( \probTranFunc(v,a_v)  \)</span> lead back to <span class="math notranslate nohighlight">\( \winAS(\mdp,\Safe(\genColour)) \)</span>. Any MD strategy which in each <span class="math notranslate nohighlight">\( v\in  \winAS(\mdp,\Safe(\genColour)) \)</span> chooses <span class="math notranslate nohighlight">\( a_v \)</span> with probability 1 is a.s. winning inside <span class="math notranslate nohighlight">\( \winAS(\mdp,\Safe(\genColour)) \)</span>, which proves the last part of the lemma.</p>
</div>
<div class="figure align-center" id="algo-reach-as">
<img alt="../_images/5-algo:reach-as.png" src="../_images/5-algo:reach-as.png" />
<p class="caption"><span class="caption-number">Fig. 40 </span><span class="caption-text">An algorithm computing <span class="math notranslate nohighlight">\(\winAS(\mdp,\Reach(\genColour))\)</span></span><a class="headerlink" href="#algo-reach-as" title="Permalink to this image">Â¶</a></p>
</div>
<p>With a.s. safety solved, we go back to a.s. reachability, which is solved via <a class="reference internal" href="#algo-reach-as"><span class="std std-numref">Fig. 40</span></a>. Note that in the first iteration, the algorithm computes the set <span class="math notranslate nohighlight">\(\winAS(\mdp,\Safe(Z))\)</span> where <span class="math notranslate nohighlight">\( Z =  \winPos(\mdp,\Reach(\genColour))\)</span>. We might be tempted to think that this set already equals <span class="math notranslate nohighlight">\( \winAS(\mdp,\Reach(\genColour)) \)</span>, but this is not the case. To see this, consider an MDP with three states <span class="math notranslate nohighlight">\( u,v,t \)</span> and two actions <span class="math notranslate nohighlight">\( a,b \)</span> such that <span class="math notranslate nohighlight">\( t \)</span> is coloured by <span class="math notranslate nohighlight">\( \Win \)</span>, both actions self loop in <span class="math notranslate nohighlight">\( v \)</span> and <span class="math notranslate nohighlight">\( t \)</span>, and <span class="math notranslate nohighlight">\( \probTranFunc(t \mid u,a) = \probTranFunc(v \mid u,a) = \frac{1}{2} \)</span> while <span class="math notranslate nohighlight">\( \probTranFunc(u \mid u,b) = 1 \)</span>. Then <span class="math notranslate nohighlight">\( \winAS(\mdp,\Reach(\Win)) = \{t\} \)</span> while at the same time <span class="math notranslate nohighlight">\( \winAS(\mdp,\Safe( \winPos(\mdp,\Reach(\Win)))) = \{u,t\}\)</span>. However, iterating the computation works, as shown in the following theorem.</p>
<div class="proof theorem admonition" id="5-thm:as-char">
<p class="admonition-title"><span>Theorem </span> (Algorithm for the almost-sure reachability winning set)</p>
<div class="theorem-content section" id="proof-content">
<p><a class="reference internal" href="#algo-reach-as"><span class="std std-numref">Fig. 40</span></a> computes <span class="math notranslate nohighlight">\(\winAS(\mdp,\Reach(\genColour))\)</span> in strongly polynomial time. Moreover, there is an MD strategy, computable in strongly polynomial time, that is almost-surely winning from every vertex of <span class="math notranslate nohighlight">\(\winAS(\mdp,\Reach(\genColour))\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Since the set <span class="math notranslate nohighlight">\( W \)</span> can only decrease in each iteration, the algorithm terminates.
We prove that upon termination, <span class="math notranslate nohighlight">\(W\)</span> equals <span class="math notranslate nohighlight">\(\winAS(\mdp,\Reach(\genColour))\)</span>.</p>
<p>We start with the <span class="math notranslate nohighlight">\( \subseteq \)</span> direction. We have <span class="math notranslate nohighlight">\(W \subseteq \winPos(\mdp_W,\Reach(\genColour))\)</span>. By  <a class="reference internal" href="#5-thm:positive-char">Theorem </a> there exists an MD strategy <span class="math notranslate nohighlight">\(\sigma\)</span> in <span class="math notranslate nohighlight">\(\mdp_W\)</span> which is positively winning from each vertex of <span class="math notranslate nohighlight">\(W\)</span>. We show that the same strategy is also almost-surely winning from each vertex of <span class="math notranslate nohighlight">\(W\)</span> in <span class="math notranslate nohighlight">\(\mdp_W\)</span> and thus also from each vertex of <span class="math notranslate nohighlight">\(W\)</span> in <span class="math notranslate nohighlight">\(\mdp\)</span>, which also proves the second part of the theorem.
Let <span class="math notranslate nohighlight">\(v\)</span> be any vertex of <span class="math notranslate nohighlight">\(W\)</span> and denote <span class="math notranslate nohighlight">\(|W|\)</span> by <span class="math notranslate nohighlight">\(\ell\)</span>. Since <span class="math notranslate nohighlight">\(\sigma\)</span> is memoryless, it guarantees that a vertex of <span class="math notranslate nohighlight">\(\vertices_{\genColour}\)</span> is reached with a positive probability in at most <span class="math notranslate nohighlight">\(\ell\)</span> steps (see also the construction of <span class="math notranslate nohighlight">\( \sigma \)</span> in the proof of  <a class="reference internal" href="#5-thm:positive-char">Theorem </a>), and since it is also deterministic, it guarantees that the probability <span class="math notranslate nohighlight">\(p\)</span> of reaching <span class="math notranslate nohighlight">\(\vertices_{\genColour}\)</span> in at most <span class="math notranslate nohighlight">\(\ell\)</span> steps is at least <span class="math notranslate nohighlight">\(p_{\min}^{\ell}\)</span>, where  <span class="math notranslate nohighlight">\(p_{\min}\)</span> is the smallest non-zero edge probability in <span class="math notranslate nohighlight">\(\mdp_W\)</span>. Now imagine that <span class="math notranslate nohighlight">\(\ell\)</span> steps have elapsed and we have not yet reached <span class="math notranslate nohighlight">\(\vertices_{\genColour}\)</span>. This happens with a probability at most <span class="math notranslate nohighlight">\((1-p_{\min}^\ell)\)</span>. However, even after these <span class="math notranslate nohighlight">\(\ell\)</span> steps we are still in <span class="math notranslate nohighlight">\(W\)</span>, since <span class="math notranslate nohighlight">\( \sigma  \)</span> is a strategy in <span class="math notranslate nohighlight">\( \mdp_w \)</span>. Hence, the probability that we do not reach <span class="math notranslate nohighlight">\(\vertices_\genColour\)</span> within the first <span class="math notranslate nohighlight">\(2\ell\)</span> steps is bounded by <span class="math notranslate nohighlight">\((1-p_{\min}^\ell)^{2}\)</span>. To realize why this is the case, note that any finite play <span class="math notranslate nohighlight">\(\play\)</span> of length <span class="math notranslate nohighlight">\(2\ell\)</span> can be split into two halves, <span class="math notranslate nohighlight">\(\play',\play''\)</span> of length <span class="math notranslate nohighlight">\(\ell\)</span>, and then <span class="math notranslate nohighlight">\(\probm^{\sigma}_{v}(\cylinder(\play))=\probm^{\sigma}_{v}(\cylinder(\play'))\cdot\probm^{\sigma}_{\last(\play')}(\cylinder(\play''))\)</span> (here we use the fact that <span class="math notranslate nohighlight">\(\sigma\)</span> is memoryless). Using this and some arithmetic, one can show that, denoting <span class="math notranslate nohighlight">\(\mathit{Avoid}_i\)</span> the set of all plays that avoid the vertices of <span class="math notranslate nohighlight">\(\vertices_{\genColour}\)</span> in steps <span class="math notranslate nohighlight">\(\ell\cdot(i-1)\)</span> to <span class="math notranslate nohighlight">\(\ell\cdot(i)-1\)</span>, it holds
$<span class="math notranslate nohighlight">\(
\probm^{\sigma}_{v}(\mathit{Avoid}_1\cap \mathit{Avoid}_2) \leq \probm^{\sigma}_{v}(\mathit{Avoid}_1)\cdot \max_{u\in W\setminus \vertices_{\genColour}}\probm^{\sigma}_{u}(\mathit{Avoid}_1)\leq (1-p_{\min}^\ell)^{2}.
\)</span>$</p>
<p>One can then continue by induction to show that <span class="math notranslate nohighlight">\(\probm^{\sigma}_{v}(\bigcap_{i=1}^j \mathit{Avoid}_i)\leq (1-p_{\min}^\ell)^{j},\)</span> and hence</p>
<div class="math notranslate nohighlight">
\[
\probm^\sigma_{v}(\Reach(\genColour))= 1-\probm^{\sigma}_{v}(\bigcap_{i=1}^\infty \mathit{Avoid}_i) \leq 1-\lim_{j\rightarrow \infty}(1-p_{\min}^\ell)^{j}= 1-0=1.
\]</div>
<p>Now we prove the <span class="math notranslate nohighlight">\( \supseteq \)</span> direction. Denote <span class="math notranslate nohighlight">\(X=\winAS(\mdp,\Reach(\genColour))\)</span>. We prove that <span class="math notranslate nohighlight">\( W \supseteq X \)</span> is an invariant of the iteration. Initially this is clear. Now assume that this holds before an iteration takes place. It is easy to check that <span class="math notranslate nohighlight">\(X\)</span> is closed, so <span class="math notranslate nohighlight">\(\mdp_{X}\)</span> is well-defined. We prove that <span class="math notranslate nohighlight">\( X \subseteq \winAS(\mdp_W,\Safe(W\setminus Z)) \)</span>, where <span class="math notranslate nohighlight">\( Z \)</span> is defined during the iteration. A strategy in <span class="math notranslate nohighlight">\(\mdp\)</span> that reaches <span class="math notranslate nohighlight">\(\vertices_{\genColour}\)</span> with probability 1 must never visit a vertex from <span class="math notranslate nohighlight">\(\vertices\setminus X\)</span> with a positive probability. Hence, each such strategy can be viewed also as a strategy in <span class="math notranslate nohighlight">\(\mdp_{X}\)</span>. It follows that  <span class="math notranslate nohighlight">\(X=\winAS(\mdp_X,\Reach(\genColour)) = \winPos(\mdp_{X},\Reach(\genColour)) \subseteq \winPos(\mdp_{W},\Reach(\genColour)) = Z\)</span>, the middle inclusion following from induction hypothesis. Now by  <a class="reference internal" href="#5-lem:safety-iteration">Lemma </a> and  <a class="reference internal" href="#5-thm:safety-main">Theorem </a>, the set <span class="math notranslate nohighlight">\( \winAS(\mdp_W,\Safe(W\setminus Z)) \)</span> is the largest closed set contained in <span class="math notranslate nohighlight">\( Z \)</span>. But <span class="math notranslate nohighlight">\( X \)</span> is also closed, and ashown above, it is contained in <span class="math notranslate nohighlight">\( Z \)</span>. Hence,  <span class="math notranslate nohighlight">\( X \subseteq \winAS(\mdp_W,\Safe(W \setminus Z)) \)</span>.</p>
<p>The complexity follows form \Cref{5-cor:pos-complexity} and  <a class="reference internal" href="#5-thm:safety-main">Theorem </a>; and also from the fact that the main loop must terminate in <span class="math notranslate nohighlight">\( \leq |\vertices| \)</span> steps. The strong polynomiality again follows from the algorithm being oblivious to precise probabilities.</p>
</div>
<p>We also have a complementary hardness result.</p>
<div class="proof theorem admonition" id="5-thm:as-complexity">
<p class="admonition-title"><span>Theorem </span> (Complexity of the almost-sure reachability winning set)</p>
<div class="theorem-content section" id="proof-content">
<p>The problem of determining whether a given vertex of a given MDP belongs to
<span class="math notranslate nohighlight">\(\winAS(\mdp,\Reach(\genColour))\)</span> is \P-complete.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We procced by a reduction
from the <strong>circuit value problem (CVP)</strong>.
An instance of <strong>CVP</strong> is a directed acyclic graph <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>,
representing a boolean circuit: each internal node represents either an OR gate
or an AND gate, while each leaf node is labelled by <strong>true</strong> or
<strong>false</strong>. Each internal node is guaranteed to have exactly two children.
Each node of <span class="math notranslate nohighlight">\(\mathcal{C}\)</span> evaluates to a unique truth value: the value of a
leaf is given by its label and the value of an internal node <span class="math notranslate nohighlight">\(v\)</span> is given by
applying the logical operator corresponding to the node to the truth values of
the two children of <span class="math notranslate nohighlight">\(v\)</span>, the evaluation proceeding in a backward topological order. The task is to decide whether a given node <span class="math notranslate nohighlight">\(w\)</span> of
<span class="math notranslate nohighlight">\(\mathcal{C}\)</span> evaluates to <strong>true</strong>. <strong>CVP</strong> was shown to be
\P-hard (under logspace reductions) in <span id="id2">[<a class="reference internal" href="references.html#id114"><span>Lad75</span></a>]</span>.
In <span id="id3">[<a class="reference internal" href="references.html#id105"><span>CDH10</span></a>]</span>, the following logspace reduction
from CVP to
almost-sure reachability in MDPs is presented: given a boolean circuit
<span class="math notranslate nohighlight">\(\mathcal{C}\)</span>, construct an MDP <span class="math notranslate nohighlight">\(\mdp_{\mathcal{C}}\)</span> whose vertices correspond
to the gates
of <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>. There are two actions, call them <span class="math notranslate nohighlight">\(\mathit{left}\)</span> and <span class="math notranslate nohighlight">\(\mathit{right}\)</span>. In each vertex corresponding to an OR gate <span class="math notranslate nohighlight">\(g\)</span>, the
<span class="math notranslate nohighlight">\(\mathit{left}\)</span> action transitions with probability 1 to the vertex
representing the left child of <span class="math notranslate nohighlight">\(g\)</span>, and similarly for the action
<span class="math notranslate nohighlight">\(\mathit{right}\)</span>
and the right child. In a vertex corresponding to an AND gate <span class="math notranslate nohighlight">\(g\)</span>, both actions behave the same: the transition into each of the two children
of <span class="math notranslate nohighlight">\(g\)</span> with probability <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span>. Vertices corresponding to leafs have self loop as the only outgoing edges, and
moreover, they are coloured with the respective labels in <span class="math notranslate nohighlight">\(\mathcal{C}\)</span>. It is
easy to check that a gate of <span class="math notranslate nohighlight">\(\mathcal{C}\)</span> evaluates to <span class="math notranslate nohighlight">\(\mathit{true}\)</span> if and
only if the corresponding vertex belongs to
<span class="math notranslate nohighlight">\(\winAS(\mdp_{\mathcal{C}},\Reach(\mathit{true}))\)</span>.</p>
</div>
<blockquote>
<div><p><strong>Positive safety</strong></p>
</div></blockquote>
<p>We conclude this section by a discussion of positive safety.</p>
<div class="proof theorem admonition" id="5-thm:pos-safety-main">
<p class="admonition-title"><span>Theorem </span> (Algorithm for the positive safety winning set)</p>
<div class="theorem-content section" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\( \mdp_{\bar\genColour} \)</span> be an MDP obtained from <span class="math notranslate nohighlight">\( \mdp \)</span> by changing all <span class="math notranslate nohighlight">\( \genColour \)</span>-coloured vertices to sinks (i.e. all actions in these vertices just self loop on the vertex). Then
<span class="math notranslate nohighlight">\( \winPos(\mdp,\Safe(\genColour)) = \winPos(\mdp_{\bar\genColour},\Reach(\winAS(\mdp_{\bar\genColour},\Safe(\genColour))) ) \)</span>. In particular, the set <span class="math notranslate nohighlight">\( \winPos(\mdp,\Safe(\genColour)) \)</span> can be computed in a strongly polynomial time and there exists a memoryless deterministic strategy, computable in strongly polynomial time, that is positively winning from every vertex of <span class="math notranslate nohighlight">\(\winPos(\mdp,\Safe(\genColour))\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Clearly <span class="math notranslate nohighlight">\( \winPos(\mdp,\Safe(\genColour)) = \winPos(\mdp_{\bar{\genColour}},\Safe(\genColour)) \)</span> and <span class="math notranslate nohighlight">\( \winAS(\mdp,\Safe(\genColour)) = \winAS(\mdp_{\bar{\genColour}},\Safe(\genColour)) \)</span>; and moreover the corresponding winning strategies easily transfer between the two MDPs (for a safety objective, the behaviour after visiting a <span class="math notranslate nohighlight">\( \genColour \)</span>-coloured state is inconsequential).
Hence, putting <span class="math notranslate nohighlight">\( Z = \winAS(\mdp_{\bar{\genColour}},\Safe(\genColour)) \)</span>, it is sufficient to show that  <span class="math notranslate nohighlight">\( \winPos(\mdp_{\bar{\genColour}},\Safe(\genColour)) =\winPos(\mdp_{\bar\genColour},\Reach(Z))  \)</span></p>
<p>The <span class="math notranslate nohighlight">\( \supseteq \)</span>  inclusion is clear as well as the construction of the witnessing MD strategy (in the vertices of that are outside of <span class="math notranslate nohighlight">\( Z \)</span>, we behave as the positively winning MD strategy for reaching <span class="math notranslate nohighlight">\( Z \)</span>, while inside <span class="math notranslate nohighlight">\( Z \)</span> we behave as the a.s. winning strategy for <span class="math notranslate nohighlight">\( \Safe(\genColour) \)</span>).</p>
<p>For the other inclusion, let <span class="math notranslate nohighlight">\( X = \vertices \setminus \winPos(\mdp_{\bar{\genColour}},\Reach(Z)) \)</span>. We prove that <span class="math notranslate nohighlight">\( X\subseteq \vertices \setminus \winPos(\mdp_{\bar{\genColour}},\Safe(\genColour)) \)</span>. Assign ranks to vertices inductively as follows: each vertex coloured by <span class="math notranslate nohighlight">\( \genColour \)</span> gets rank <span class="math notranslate nohighlight">\( 0 \)</span>. Now if ranks <span class="math notranslate nohighlight">\( \leq i \)</span> have been already assigned, then a vertex  <span class="math notranslate nohighlight">\( v \)</span> is assigned rank <span class="math notranslate nohighlight">\(i+1  \)</span> if it  does  not already have a lower rank but for all actions <span class="math notranslate nohighlight">\( a\in\actions \)</span> there exists a vertex <span class="math notranslate nohighlight">\( u \)</span> of rank <span class="math notranslate nohighlight">\( \leq i \)</span> s.t. <span class="math notranslate nohighlight">\( \probTranFunc(u \mid v,a) &gt;0\)</span>. Then each vertex in <span class="math notranslate nohighlight">\( X \)</span> is assigned a finite rank: indeed, the set of vertices without a rank is closed and does not contain <span class="math notranslate nohighlight">\( \genColour \)</span>-coloured vertices, hence it is contained in <span class="math notranslate nohighlight">\( Z \)</span>.
Now fix any strategy <span class="math notranslate nohighlight">\( \sigma \)</span> starting in a vertex <span class="math notranslate nohighlight">\(v \in X \)</span>. By definition of <span class="math notranslate nohighlight">\( X \)</span>, <span class="math notranslate nohighlight">\( \sigma \)</span> never reaches <span class="math notranslate nohighlight">\( Z \)</span> and hence never visits an unranked state. At the same time, whenever <span class="math notranslate nohighlight">\( \sigma \)</span> is in a ranked state, there is, by definition of ranks, a probability at least <span class="math notranslate nohighlight">\(p_{\min}  \)</span> (the minimal edge probability in <span class="math notranslate nohighlight">\( \mdp \)</span>) of transitioning to a lower-ranked state in the next step. Hence, in every moment, the probability of <span class="math notranslate nohighlight">\( \sigma \)</span> reaching a <span class="math notranslate nohighlight">\( \genColour \)</span>-coloured state within the next <span class="math notranslate nohighlight">\( |\vertices| \)</span> steps is at least <span class="math notranslate nohighlight">\( p_{\min}^{|\vertices|} \)</span>. By a straightforward adaptation of the second part of the proof of  <a class="reference internal" href="#5-thm:as-char">Theorem </a>, <span class="math notranslate nohighlight">\( \sigma \)</span> eventually visits <span class="math notranslate nohighlight">\( \vertices_{\genColour} \)</span> with probability 1. Since <span class="math notranslate nohighlight">\( \sigma \)</span> was arbitrary, this shows that <span class="math notranslate nohighlight">\( v\not \in\winPos(\mdp_{\bar{\genColour}},\Safe(\genColour)).  \)</span></p>
<p>The complexity follows from the results on positive reachability and a.s. safety.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./5_MDP"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="notations.html" title="previous page">Notations</a>
    <a class='right-next' id="next-link" href="discounted.html" title="next page">Discounted payoff in MDPs</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>