
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1.3. A quadratic time algorithm for Büchi games &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"set": ["\\left\\{ #1 \\right\\}", 1], "N": "\\mathbb{N}", "Z": "\\mathbb{Z}", "Q": "\\mathbb{Q}", "Qinfty": "\\Q \\cup \\set{\\infty}", "R": "\\mathbb{R}", "Rinfty": "\\R \\cup \\set{\\infty}", "ing": "\\text{In}", "Ing": "\\ing", "out": "\\text{Out}", "Out": "\\out", "first": "\\text{first}", "last": "\\text{last}", "Paths": "\\text{Paths}", "play": "\\pi", "arena": "\\mathcal{A}", "Arena": "\\arena", "col": "\\textsf{col}", "Col": "\\col", "game": "\\mathcal{G}", "Game": "\\game", "Eve": "\\mathrm{Eve}", "Adam": "\\mathrm{Adam}", "VE": "V_\\Eve", "VA": "V_\\Adam", "VR": "V_\\mathrm{Random}", "WE": "W_\\Eve", "WA": "W_\\Adam", "Value": "val", "val": "\\Value", "ValueE": "\\Value_\\Eve", "ValueA": "\\Value_\\Adam", "Win": "\\text{Win}", "Lose": "\\text{Lose}", "Safe": "\\mathtt{Safe}", "Reach": "\\mathtt{Reach}", "Buchi": "\\mathtt{Buchi}", "CoBuchi": "\\mathtt{CoBuchi}", "Parity": "\\mathtt{Parity}", "MeanPayoff": "\\mathtt{MeanPayoff}", "DiscountedPayoff": "\\mathtt{DiscountedPayoff}", "Automaton": "\\mathbf{A}", "half": "\\frac{1}{2}"}}, "tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="1.4. An exponential time algorithm for parity games" href="parity.html" />
    <link rel="prev" title="1.2. A linear time algorithm for reachability games" href="attractors.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../book.html">
   Games on Graphs
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="../index.html">
   1. Classic
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="index.html">
     1.1. Regular
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="attractors.html">
     1.2. A linear time algorithm for reachability games
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     1.3. A quadratic time algorithm for Büchi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parity.html">
     1.4. An exponential time algorithm for parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="muller.html">
     1.5. Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zielonka.html">
     1.6. The Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     1.7. Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/2_Classic/1_Regular/buchi.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-first-algorithm">
   1.3.1. A first algorithm
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-second-algorithm">
   1.3.2. A second algorithm
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="a-quadratic-time-algorithm-for-buchi-games">
<span id="sec-buchi"></span><h1><span class="section-number">1.3. </span>A quadratic time algorithm for Büchi games<a class="headerlink" href="#a-quadratic-time-algorithm-for-buchi-games" title="Permalink to this headline">¶</a></h1>
<p>Recall that the objective <span class="math notranslate nohighlight">\(\Buchi\)</span> requires that the colour <span class="math notranslate nohighlight">\(\Win\)</span> appears infinitely many times
and <span class="math notranslate nohighlight">\(\CoBuchi\)</span> requires that the colour <span class="math notranslate nohighlight">\(\Lose\)</span> appears finitely many times.</p>
<div class="theorem admonition" id="thm-buchi">
<p class="admonition-title">Theorem</p>
<p>Büchi objectives are uniformly positionally determined for both players\footnote{See \cref{2-rmk:finite_infinite} for the case of infinite games.}.
There exists an algorithm for computing the winning regions of Büchi games in quadratic time, more precisely <span class="math notranslate nohighlight">\(O(mn)\)</span>,
and linear space, more precisely <span class="math notranslate nohighlight">\(O(m)\)</span>.</p>
</div>
<p>The first sentence implies that CoBüchi games are also uniformly positionally determined.
We present two different yet very similar algorithms.</p>
<div class="section" id="a-first-algorithm">
<h2><span class="section-number">1.3.1. </span>A first algorithm<a class="headerlink" href="#a-first-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The following lemma implies  <a class="reference internal" href="#thm-buchi"><span class="std std-ref">Theorem</span></a>.</p>
<div class="lemma admonition" id="lem-buchi-second">
<p class="admonition-title">Lemma</p>
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a Büchi game.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(\AttrE(\Win) = V\)</span>, then <span class="math notranslate nohighlight">\(\WE(\Game) = V\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\AttrE(\Win) \neq V\)</span>,
let <span class="math notranslate nohighlight">\(\Game'\)</span> be the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrA( V \setminus \AttrE(\Win) )\)</span>,
then <span class="math notranslate nohighlight">\(\WE(\Game) = \WE(\Game')\)</span>.</p></li>
</ul>
</div>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We prove the first item.</p>
<p>Let <span class="math notranslate nohighlight">\(\sigma_a\)</span> be an attractor strategy ensuring to reach <span class="math notranslate nohighlight">\(\Win\)</span> from <span class="math notranslate nohighlight">\(\AttrE(\Win)\)</span>, and <span class="math notranslate nohighlight">\(\sigma_p\)</span> any (positional) strategy from <span class="math notranslate nohighlight">\(\Win\)</span>.
We construct the strategy <span class="math notranslate nohighlight">\(\sigma\)</span> as the disjoint union of <span class="math notranslate nohighlight">\(\sigma_a\)</span> and <span class="math notranslate nohighlight">\(\sigma_p\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\sigma(v) = 
\begin{cases}
\sigma_a(v) &amp; \text{ if } v \in \AttrE(\Win) \setminus \Win, \\
\sigma_p(v) &amp; \text{ if } v \in \Win.
\end{cases}\end{split}\]</div>
<p>Note that <span class="math notranslate nohighlight">\(\sigma\)</span> is positional.
We argue that <span class="math notranslate nohighlight">\(\sigma\)</span> ensures <span class="math notranslate nohighlight">\(\Buchi[\Win]\)</span>.
Indeed a play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> can be divided into infinitely many finite plays,
each of them consistent with <span class="math notranslate nohighlight">\(\sigma_a\)</span> until reaching <span class="math notranslate nohighlight">\(\Win\)</span>,
then one step consistent with <span class="math notranslate nohighlight">\(\sigma_p\)</span>.
Thus <span class="math notranslate nohighlight">\(\sigma\)</span> is winning from <span class="math notranslate nohighlight">\(V\)</span>.</p>
<p>We now look at the second item.</p>
<p>We first prove that <span class="math notranslate nohighlight">\(\AttrA(V \setminus \AttrE(\Win)) \subseteq \WA(\Game)\)</span>.
Let <span class="math notranslate nohighlight">\(\tau_a\)</span> denote an attractor strategy ensuring to reach <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win)\)</span> from <span class="math notranslate nohighlight">\(\AttrA(V \setminus \AttrE(\Win))\)</span>,
and <span class="math notranslate nohighlight">\(\tau_c\)</span> a counter-attractor strategy ensuring to stay in <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win)\)</span> hence in never to reach <span class="math notranslate nohighlight">\(\Win\)</span>.
We construct the strategy <span class="math notranslate nohighlight">\(\tau\)</span> as the disjoint union of <span class="math notranslate nohighlight">\(\tau_a\)</span> and <span class="math notranslate nohighlight">\(\tau_c\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tau(v) = 
\begin{cases}
\tau_a(v) &amp; \text{ if } v \in \AttrA(V \setminus \AttrE(\Win)) \setminus (V \setminus \AttrE(\Win)), \\
\tau_c(v) &amp; \text{ if } v \in V \setminus \AttrE(\Win).
\end{cases}\end{split}\]</div>
<p>Note that <span class="math notranslate nohighlight">\(\tau\)</span> is positional.
Any play consistent with <span class="math notranslate nohighlight">\(\tau\)</span> is first consistent with <span class="math notranslate nohighlight">\(\tau_a\)</span> until reaching <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win)\)</span> and
then is consistent with <span class="math notranslate nohighlight">\(\tau_c\)</span> and stays there forever.
In this second phase it in particular does not visit <span class="math notranslate nohighlight">\(\Win\)</span>,
implying that the play visits <span class="math notranslate nohighlight">\(\Win\)</span> finitely many times, so it is winning.
Thus we have proved that <span class="math notranslate nohighlight">\(\AttrA(V \setminus \AttrE(\Win)) \subseteq \WA(\Game)\)</span>,
implying <span class="math notranslate nohighlight">\(\WE(\Game) \subseteq V \setminus \AttrA(V \setminus \AttrE(\Win))\)</span>.</p>
<p>We now show that <span class="math notranslate nohighlight">\(\WE(\Game') \subseteq \WE(\Game)\)</span>, which implies the converse inclusion.
Consider a winning strategy from <span class="math notranslate nohighlight">\(\WE(\Game')\)</span> in <span class="math notranslate nohighlight">\(\Game'\)</span>, it induces a strategy <span class="math notranslate nohighlight">\(\sigma\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
Since <span class="math notranslate nohighlight">\(\Game'\)</span> is a trap for Adam, any play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> stays forever in <span class="math notranslate nohighlight">\(\WE(\Game')\)</span>,
implying that <span class="math notranslate nohighlight">\(\sigma\)</span> is winning from <span class="math notranslate nohighlight">\(\WE(\Game')\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.</p>
</div>
<p>The algorithm is presented in pseudocode in  <span class="xref std std-ref">Algorithm</span>.
For the complexity analysis, the algorithm performs at most <span class="math notranslate nohighlight">\(n\)</span> recursive calls
and each of them involves two attractor computations, implying the time complexity <span class="math notranslate nohighlight">\(O(mn)\)</span>.</p>
<p>\begin{algorithm}
\KwData{A Büchi game.}
\SetKwFunction{FSolve}{Solve}
\SetKwProg{Fn}{Function}{:}{}
\DontPrintSemicolon</p>
<p>\Fn{\FSolve{<span class="math notranslate nohighlight">\(\Game\)</span>}}{
<span class="math notranslate nohighlight">\(X \leftarrow \AttrE(\Win)\)</span></p>
<p>\If{<span class="math notranslate nohighlight">\(X = V\)</span>}{
\Return{<span class="math notranslate nohighlight">\(V\)</span>}
}
\Else{
Let <span class="math notranslate nohighlight">\(\Game'\)</span> the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrA(X)\)</span></p>
<p>\Return{<span class="math notranslate nohighlight">\(\FSolve{\)</span>\Game’<span class="math notranslate nohighlight">\(}\)</span>}
}
}
\caption{The first quadratic time algorithm for solving B{“uchi} games.}
\label{2-algo:Buchi_first}
\end{algorithm}</p>
</div>
<div class="section" id="a-second-algorithm">
<h2><span class="section-number">1.3.2. </span>A second algorithm<a class="headerlink" href="#a-second-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The following lemma induces a different algorithm, it also implies  <a class="reference internal" href="#thm-buchi"><span class="std std-ref">Theorem</span></a>.</p>
<div class="lemma admonition" id="lem-buchi">
<p class="admonition-title">Lemma</p>
<p>Let <span class="math notranslate nohighlight">\(\game\)</span> a Büchi game.
Then <span class="math notranslate nohighlight">\(\WE(\game)\)</span> is the greatest fixed point of the monotonic operator</p>
<div class="math notranslate nohighlight">
\[Y \mapsto \AttrE \left( \Win \cap \PreE(Y) \right).\]</div>
</div>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>Thanks to  <span class="xref std std-ref">Theorem</span> the fixed point computation is realised by setting <span class="math notranslate nohighlight">\(Y_0 = V\)</span>
and <span class="math notranslate nohighlight">\(Y_{k+1} = Y_k \cap \AttrE \left(\Win \cap \PreE(Y_k) \right)\)</span>.
This constructs a non-increasing sequence <span class="math notranslate nohighlight">\((Y_k)_{k \in \N}\)</span> of subsets of <span class="math notranslate nohighlight">\(V\)</span>
satisfying the property:
\begin{center}
If <span class="math notranslate nohighlight">\(Y_k = Y_{k+1}\)</span>, then <span class="math notranslate nohighlight">\(Y_{k+1} = Y_{k+2}\)</span>.
\end{center}
It follows that the sequence stabilises after at most <span class="math notranslate nohighlight">\(n-1\)</span> steps, i.e. <span class="math notranslate nohighlight">\(Y_{n-1} = Y_n\)</span>.
We let <span class="math notranslate nohighlight">\(Y\)</span> denote the fixed point, and note that <span class="math notranslate nohighlight">\(Y = \AttrE(\Win \cap \PreE(Y))\)</span>.</p>
<p>We first show that <span class="math notranslate nohighlight">\(Y \subseteq \WE(\game)\)</span>.
Let <span class="math notranslate nohighlight">\(\sigma_a\)</span> be an attractor strategy ensuring to reach <span class="math notranslate nohighlight">\(\Win \cap \PreE(Y)\)</span> from <span class="math notranslate nohighlight">\(Y\)</span>.
We also define a positional strategy <span class="math notranslate nohighlight">\(\sigma_p\)</span>:
for <span class="math notranslate nohighlight">\(v \in \VE\)</span>, if <span class="math notranslate nohighlight">\(v \in \PreE(Y)\)</span> there exists <span class="math notranslate nohighlight">\((v,v') \in E\)</span> such that <span class="math notranslate nohighlight">\(v' \in Y\)</span>, let us define <span class="math notranslate nohighlight">\(\sigma_p(v) = (v,v')\)</span>.</p>
<p>We define a positional strategy <span class="math notranslate nohighlight">\(\sigma\)</span> as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\sigma(v) = 
\begin{cases}
\sigma_a(v) &amp; \text{if } v \in \AttrE(\Win \cap \PreE(Y)) \setminus (\Win \cap \PreE(Y)), \\
\sigma_p(v)&amp; \text{if } v \in \Win \cap \PreE(Y).
\end{cases}\end{split}\]</div>
<p>We argue that <span class="math notranslate nohighlight">\(\sigma\)</span> ensures <span class="math notranslate nohighlight">\(\Buchi[\Win]\)</span> from <span class="math notranslate nohighlight">\(Y\)</span>.
Indeed a play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> can be divided into infinitely many finite plays,
each of them consistent with <span class="math notranslate nohighlight">\(\sigma_a\)</span> until reaching <span class="math notranslate nohighlight">\(\Win \cap \PreE(Y)\)</span>,
then one step consistent with <span class="math notranslate nohighlight">\(\sigma_p\)</span> and leading to <span class="math notranslate nohighlight">\(Y\)</span>.</p>
<p>We now show that <span class="math notranslate nohighlight">\(\WE(\game) \subseteq Y\)</span>.
For this we show <span class="math notranslate nohighlight">\(V \setminus Y \subseteq \WA(\game)\)</span>.
For <span class="math notranslate nohighlight">\(v \in V \setminus Y\)</span>, the rank of <span class="math notranslate nohighlight">\(v\)</span> is the smallest <span class="math notranslate nohighlight">\(k \in \N\)</span> such that <span class="math notranslate nohighlight">\(v \in V \setminus Y_k\)</span>.
Equivalently, <span class="math notranslate nohighlight">\(v \in Y_{k-1} \setminus Y_k\)</span>.
Note that no vertices have rank <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(k \in \N\)</span>.
Let <span class="math notranslate nohighlight">\(\tau_{a,k}\)</span> be a counter-attractor strategy ensuring from <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win \cap \PreE(Y_k))\)</span>
to stay in <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win \cap \PreE(Y_k))\)</span> so in particular never to reach <span class="math notranslate nohighlight">\(\Win \cap \PreE(Y_k)\)</span>.
We also define a positional strategy <span class="math notranslate nohighlight">\(\tau_{p,k}\)</span>:
for <span class="math notranslate nohighlight">\(v \in \VA\)</span> of rank <span class="math notranslate nohighlight">\(k+1\)</span>, if <span class="math notranslate nohighlight">\(v \in \Win \setminus \PreE(Y_k)\)</span> there exists <span class="math notranslate nohighlight">\((v,v') \in E\)</span> such that <span class="math notranslate nohighlight">\(v' \in V \setminus Y_k\)</span>
implying that the rank of <span class="math notranslate nohighlight">\(v'\)</span> is at most <span class="math notranslate nohighlight">\(k\)</span>, let us define <span class="math notranslate nohighlight">\(\tau_{p,k}(v) = (v,v')\)</span>.</p>
<p>We construct the strategy <span class="math notranslate nohighlight">\(\tau\)</span> as the disjoint union of all <span class="math notranslate nohighlight">\(\tau_{a,k}\)</span> and <span class="math notranslate nohighlight">\(\tau_{p,k}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tau(v) = 
\begin{cases}
\tau_{a,k}(v) &amp; \text{if } v \in (Y_k \setminus Y_{k+1}) \setminus \Win, \\
\tau_{p,k}(v) &amp; \text{if } v \in \Win \cap (Y_k \setminus Y_{k+1}).
\end{cases}\end{split}\]</div>
<p>We argue that <span class="math notranslate nohighlight">\(\tau\)</span> ensures <span class="math notranslate nohighlight">\(\CoBuchi[\Win]\)</span>.
Consider a play consistent with <span class="math notranslate nohighlight">\(\tau\)</span> starting from a vertex <span class="math notranslate nohighlight">\(v\)</span> of rank <span class="math notranslate nohighlight">\(k+1\)</span>.
First, as long as the play is consistent with <span class="math notranslate nohighlight">\(\tau_{a,k}\)</span>, it remains in <span class="math notranslate nohighlight">\(V \setminus \AttrE(\Win \cap \PreE(Y_k))\)</span>
and the rank does not increase.
We distinguish two cases.
If the play never reaches <span class="math notranslate nohighlight">\(\Win\)</span>, then it satisfies <span class="math notranslate nohighlight">\(\CoBuchi[\Win]\)</span>.
Otherwise it reaches <span class="math notranslate nohighlight">\(\Win\)</span>, and then the next step is consistent with <span class="math notranslate nohighlight">\(\tau_{p,k}\)</span>
so the next vertex has rank at most <span class="math notranslate nohighlight">\(k\)</span>.
Thus along any play consistent with <span class="math notranslate nohighlight">\(\tau\)</span>, the rank never increases and each time a vertex in <span class="math notranslate nohighlight">\(\Win\)</span> is reached the rank decreases,
implying that it satisfies <span class="math notranslate nohighlight">\(\CoBuchi[\Win]\)</span>.</p>
</div>
<p><a class="reference internal" href="#lem-buchi"><span class="std std-ref">Lemma</span></a> directly transfers to  <span class="xref std std-ref">Algorithm</span>.</p>
<p>\begin{algorithm}
\KwData{A Büchi game.}</p>
<p><span class="math notranslate nohighlight">\(Y_0 \leftarrow V\)</span></p>
<p><span class="math notranslate nohighlight">\(k \leftarrow 0\)</span></p>
<p>\Repeat{<span class="math notranslate nohighlight">\(Y_{k+1} = Y_k\)</span>}{
<span class="math notranslate nohighlight">\(Y_{k+1} \leftarrow Y_k \cap \AttrE \left( \Win \cap \PreE(Y_k) \right)\)</span></p>
<p><span class="math notranslate nohighlight">\(k \leftarrow k + 1\)</span>
}</p>
<p>\Return{<span class="math notranslate nohighlight">\(Y_k\)</span>}
\caption{The second quadratic time algorithm for solving B{“uchi} games.}
\label{2-algo:Buchi_second}
\end{algorithm}</p>
<div class="remark admonition">
<p class="admonition-title">Remark</p>
<p>Both algorithms have the same complexity but they are not equivalent: the number of recursive calls of the first algorithm
may be strictly smaller than the number of iterations of the repeat loop in the second algorithm.
Both can be extended into (different) algorithms for parity games and beyond; in this chapter we will work with the first algorithm.</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./2_Classic/1_Regular"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="attractors.html" title="previous page"><span class="section-number">1.2. </span>A linear time algorithm for reachability games</a>
    <a class='right-next' id="next-link" href="parity.html" title="next page"><span class="section-number">1.4. </span>An exponential time algorithm for parity games</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>