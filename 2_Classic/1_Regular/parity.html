
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1.4. An exponential time algorithm for parity games &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"set": ["\\left\\{ #1 \\right\\}", 1], "N": "\\mathbb{N}", "Z": "\\mathbb{Z}", "Q": "\\mathbb{Q}", "Qinfty": "\\Q \\cup \\set{\\infty}", "R": "\\mathbb{R}", "Rinfty": "\\R \\cup \\set{\\infty}", "ing": "\\text{In}", "Ing": "\\ing", "out": "\\text{Out}", "Out": "\\out", "first": "\\text{first}", "last": "\\text{last}", "Paths": "\\text{Paths}", "play": "\\pi", "arena": "\\mathcal{A}", "Arena": "\\arena", "col": "\\textsf{col}", "Col": "\\col", "game": "\\mathcal{G}", "Game": "\\game", "Eve": "\\mathrm{Eve}", "Adam": "\\mathrm{Adam}", "VE": "V_\\Eve", "VA": "V_\\Adam", "VR": "V_\\mathrm{Random}", "WE": "W_\\Eve", "WA": "W_\\Adam", "Value": "val", "val": "\\Value", "ValueE": "\\Value_\\Eve", "ValueA": "\\Value_\\Adam", "Win": "\\text{Win}", "Lose": "\\text{Lose}", "Safe": "\\mathtt{Safe}", "Reach": "\\mathtt{Reach}", "Buchi": "\\mathtt{Buchi}", "CoBuchi": "\\mathtt{CoBuchi}", "Parity": "\\mathtt{Parity}", "MeanPayoff": "\\mathtt{MeanPayoff}", "DiscountedPayoff": "\\mathtt{DiscountedPayoff}", "Automaton": "\\mathbf{A}", "half": "\\frac{1}{2}"}}, "tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="1.5. Rabin, Streett, and Muller games" href="muller.html" />
    <link rel="prev" title="1.3. A quadratic time algorithm for Büchi games" href="buchi.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../index.html">
  
  <img src="../../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../book.html">
   Games on Graphs
  </a>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="../index.html">
   1. Classic
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="index.html">
     1.1. Regular
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="attractors.html">
     1.2. A linear time algorithm for reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="buchi.html">
     1.3. A quadratic time algorithm for Büchi games
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     1.4. An exponential time algorithm for parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="muller.html">
     1.5. Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zielonka.html">
     1.6. The Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     1.7. Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/2_Classic/1_Regular/parity.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="an-exponential-time-algorithm-for-parity-games">
<span id="sec-parity"></span><h1><span class="section-number">1.4. </span>An exponential time algorithm for parity games<a class="headerlink" href="#an-exponential-time-algorithm-for-parity-games" title="Permalink to this headline">¶</a></h1>
<p>Recall that the parity objective extends Büchi and coBüchi objectives:</p>
<div class="math notranslate nohighlight">
\[\Parity = \set{\rho \in [1,d]^\omega \mid \text{ the largest priority appearing infinitely often in } \rho \text{ is even}}.\]</div>
<div class="theorem admonition" id="thm-parity">
<p class="admonition-title">Theorem</p>
<p>Parity objectives are uniformly positionally determined for both players\footnote{See \cref{2-rmk:finite_infinite} for the case of infinite games.}.
There exists an algorithm for computing the winning regions of parity games in exponential time,
and more precisely of complexity <span class="math notranslate nohighlight">\(O(m n^d)\)</span>.
The space complexity of <span class="math notranslate nohighlight">\(O(nd)\)</span>.</p>
<p>Furthermore, solving parity games is in <span class="math notranslate nohighlight">\(\NP \cap \coNP\)</span>.</p>
</div>
<p>To prove  <a class="reference internal" href="#thm-parity"><span class="std std-ref">Theorem</span></a> we first construct a recursive algorithm for computing the winning regions of parity games.
The algorithm is often called Zielonka’s algorithm, or more accurately McNaughton Zielonka’s algorithm.
We refer to the reference section <a class="reference internal" href="references.html#sec-references"><span class="std std-ref">Section</span></a> for a discussion on this nomenclature.
We will see that the positionaly determinacy result for both players will be a consequence of the analysis of the algorithm.
The <span class="math notranslate nohighlight">\(\NP \cap \coNP\)</span> complexity bounds will be discussed at the end of this section.</p>
<p>The following lemma induces (half of) the recursive algorithm.
Identifying a colour and its set of vertices we write <span class="math notranslate nohighlight">\(d\)</span> for the set of vertices of priority <span class="math notranslate nohighlight">\(d\)</span>.</p>
<div class="lemma admonition" id="lem-zielonka-even">
<p class="admonition-title">Lemma</p>
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a parity game with priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>, and <span class="math notranslate nohighlight">\(d\)</span> even.
Let <span class="math notranslate nohighlight">\(\Game'\)</span> be the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrE(d)\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(\WA(\Game') = \emptyset\)</span>, then <span class="math notranslate nohighlight">\(\WE(\Game) = V\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\WA(\Game') \neq \emptyset\)</span>,
let <span class="math notranslate nohighlight">\(\Game''\)</span> be the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrA( \WA(\Game') )\)</span>,
then <span class="math notranslate nohighlight">\(\WE(\Game) = \WE(\Game'')\)</span>.</p></li>
</ul>
</div>
<p>To see that this leads to a recursive algorithm, we note that <span class="math notranslate nohighlight">\(\Game'\)</span> has priorities in <span class="math notranslate nohighlight">\([1,d-1]\)</span>
and that if <span class="math notranslate nohighlight">\(\WA(\Game') \neq \emptyset\)</span>, then <span class="math notranslate nohighlight">\(\Game''\)</span> has less vertices than <span class="math notranslate nohighlight">\(\Game\)</span>.</p>
<div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>We prove the first item.</p>
<p>Let <span class="math notranslate nohighlight">\(\sigma_d\)</span> be an attractor strategy ensuring to reach <span class="math notranslate nohighlight">\(d\)</span> from <span class="math notranslate nohighlight">\(\AttrE(d)\)</span>.
Consider a winning strategy for Eve from <span class="math notranslate nohighlight">\(V \setminus \AttrE(d)\)</span> in <span class="math notranslate nohighlight">\(\Game'\)</span>, it induces a strategy <span class="math notranslate nohighlight">\(\sigma'\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
We construct a strategy <span class="math notranslate nohighlight">\(\sigma\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span> as the disjoint union of <span class="math notranslate nohighlight">\(\sigma_d\)</span> on <span class="math notranslate nohighlight">\(\AttrE(d)\)</span> and of <span class="math notranslate nohighlight">\(\sigma'\)</span> on <span class="math notranslate nohighlight">\(V \setminus \AttrE(d)\)</span>.
Any play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> either enters <span class="math notranslate nohighlight">\(\AttrE(d)\)</span> infinitely many times,
or eventually remains in <span class="math notranslate nohighlight">\(V \setminus \AttrE(d)\)</span> and is eventually consistent with <span class="math notranslate nohighlight">\(\sigma'\)</span>.
In the first case it sees infinitely many times <span class="math notranslate nohighlight">\(d\)</span>, which is even and maximal, hence satisfies <span class="math notranslate nohighlight">\(\Parity\)</span>,
and in the other case since <span class="math notranslate nohighlight">\(\sigma'\)</span> is winning the play satisfies <span class="math notranslate nohighlight">\(\Parity\)</span>.
Thus <span class="math notranslate nohighlight">\(\sigma\)</span> is winning from <span class="math notranslate nohighlight">\(V\)</span>.</p>
<p>We now look at the second item.</p>
<p>Let <span class="math notranslate nohighlight">\(\tau_a\)</span> denote an attractor strategy from <span class="math notranslate nohighlight">\(\AttrA(\WA(\Game')) \setminus \WA(\Game')\)</span>.
Consider a winning strategy for Adam from <span class="math notranslate nohighlight">\(\WA(\Game')\)</span> in <span class="math notranslate nohighlight">\(\Game'\)</span>, it induces a strategy <span class="math notranslate nohighlight">\(\tau'\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
Since <span class="math notranslate nohighlight">\(V \setminus \AttrE(d)\)</span> is a trap for Eve, this implies that <span class="math notranslate nohighlight">\(\tau'\)</span> is a winning strategy in <span class="math notranslate nohighlight">\(\Game\)</span>.
Consider now a winning strategy in the game <span class="math notranslate nohighlight">\(\Game''\)</span> from <span class="math notranslate nohighlight">\(\WA(\Game'')\)</span>, it induces a strategy <span class="math notranslate nohighlight">\(\tau''\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
The set <span class="math notranslate nohighlight">\(V \setminus \AttrA( \WA(\Game') )\)</span> may not be a trap for Eve, so we cannot conclude that <span class="math notranslate nohighlight">\(\tau''\)</span> is a winning strategy in <span class="math notranslate nohighlight">\(\Game\)</span>,
and it indeed may not be.
We construct a strategy <span class="math notranslate nohighlight">\(\tau\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span> as the (disjoint) union of the strategy <span class="math notranslate nohighlight">\(\tau_a\)</span> on <span class="math notranslate nohighlight">\(\AttrA(\WA(\Game')) \setminus \WA(\Game')\)</span>,
the strategy <span class="math notranslate nohighlight">\(\tau'\)</span> on <span class="math notranslate nohighlight">\(\WA(\Game')\)</span> and the strategy <span class="math notranslate nohighlight">\(\tau''\)</span> on <span class="math notranslate nohighlight">\(\WA(\Game'')\)</span>.
We argue that <span class="math notranslate nohighlight">\(\tau\)</span> is winning from <span class="math notranslate nohighlight">\(\AttrA( \WA(\Game') ) \cup \WA(\Game'')\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
Indeed, any play consistent with this strategy in <span class="math notranslate nohighlight">\(\Game\)</span> either stays forever in <span class="math notranslate nohighlight">\(\WA(\Game'')\)</span> hence is consistent with <span class="math notranslate nohighlight">\(\tau''\)</span>
or enters <span class="math notranslate nohighlight">\(\AttrA( \WA(\Game') )\)</span>, hence is eventually consistent with <span class="math notranslate nohighlight">\(\tau'\)</span>.
In both cases this implies that the play is winning.
Thus we have proved that <span class="math notranslate nohighlight">\(\AttrA( \WA(\Game') ) \cup \WA(\Game'') \subseteq \WA(\Game)\)</span>.</p>
<p>We now show that <span class="math notranslate nohighlight">\(\WE(\Game'') \subseteq \WE(\Game)\)</span>, which implies the converse inclusion.
Consider a winning strategy from <span class="math notranslate nohighlight">\(\WE(\Game'')\)</span> in <span class="math notranslate nohighlight">\(\Game''\)</span>, it induces a strategy <span class="math notranslate nohighlight">\(\sigma\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.
Since <span class="math notranslate nohighlight">\(\Game''\)</span> is a trap for Adam, any play consistent with <span class="math notranslate nohighlight">\(\sigma\)</span> stays forever in <span class="math notranslate nohighlight">\(\WE(\Game'')\)</span>,
implying that <span class="math notranslate nohighlight">\(\sigma\)</span> is winning from <span class="math notranslate nohighlight">\(\WE(\Game'')\)</span> in <span class="math notranslate nohighlight">\(\Game\)</span>.</p>
</div>
<p>To get the full algorithm we need the analogous lemma for the case where the maximal priority is odd.
We do not prove the following lemma as it is the exact dual of the previous lemma, and the proof is the same swapping the two players.</p>
<div class="lemma admonition" id="lem-zielonka-odd">
<p class="admonition-title">Lemma</p>
<p>Let <span class="math notranslate nohighlight">\(\Game\)</span> be a parity game with priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>, and <span class="math notranslate nohighlight">\(d\)</span> odd.
Let <span class="math notranslate nohighlight">\(\Game'\)</span> be the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrA(d)\)</span>.</p>
<ul class="simple">
<li><p>If <span class="math notranslate nohighlight">\(\WE(\Game') = \emptyset\)</span>, then <span class="math notranslate nohighlight">\(\WA(\Game) = V\)</span>.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(\WE(\Game') \neq \emptyset\)</span>, let <span class="math notranslate nohighlight">\(\Game''\)</span> be the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrE( \WE(\Game') )\)</span>,
then <span class="math notranslate nohighlight">\(\WA(\Game) = \WA(\Game'')\)</span>.</p></li>
</ul>
</div>
<p>The algorithm is presented in pseudocode in  <span class="xref std std-ref">Algorithm</span>.</p>
<p>The proofs of  <a class="reference internal" href="#lem-zielonka-even"><span class="std std-ref">Lemma</span></a> and  <a class="reference internal" href="#lem-zielonka-odd"><span class="std std-ref">Lemma</span></a> also imply that parity games are positionally determined for both players.
Indeed, winning strategies are defined as disjoint unions of strategies constructed inductively.</p>
<p>We now perform a complexity analysis.
We write <span class="math notranslate nohighlight">\(f(n,d)\)</span> for the number of recursive calls performed by the algorithm on parity games with <span class="math notranslate nohighlight">\(n\)</span> vertices and priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>.
We have <span class="math notranslate nohighlight">\(f(n,1) = 0 = f(0,d) = 0\)</span>, with the general induction:</p>
<div class="math notranslate nohighlight">
\[f(n,d) \le f(n,d-1) + f(n-1,d) + 2.\]</div>
<p>The term <span class="math notranslate nohighlight">\(f(n,d-1)\)</span> corresponds to the recursive call to <span class="math notranslate nohighlight">\(\Game'\)</span>,
the term <span class="math notranslate nohighlight">\(f(n-1,d)\)</span> to the recursive call to <span class="math notranslate nohighlight">\(\Game''\)</span>.
We obtain <span class="math notranslate nohighlight">\(f(n,d) \le n \cdot f(n,d-1) + 2n\)</span>,
so <span class="math notranslate nohighlight">\(f(n,d) \le 2(n + n^2 + \dots + n^{d-1}) = O(n^d)\)</span>.
In each recursive call we perform two attractor computations so the number of operations
in one recursive call is <span class="math notranslate nohighlight">\(O(m)\)</span>.
Thus the overall time complexity is <span class="math notranslate nohighlight">\(O(m n^d)\)</span>.</p>
<p>We finish the proof of  <a class="reference internal" href="#thm-parity"><span class="std std-ref">Theorem</span></a> by sketching the argument that solving parity games is in <span class="math notranslate nohighlight">\(\NP \cap \coNP\)</span>.
The first observation is that computing the winning regions of the one player variants of parity games can be done in polynomial time
through a simple graph analysis that we do not detail here.
The <span class="math notranslate nohighlight">\(\NP\)</span> and <span class="math notranslate nohighlight">\(\coNP\)</span> algorithms are the following: guess a winning positional strategy,
and check whether it is winning by computing the winning regions of the one player game induced by the strategy.
Guessing a strategy for Eve is a witness that the answer is yes so it yields an <span class="math notranslate nohighlight">\(\NP\)</span> algorithm,
and guessing a strategy for Adam yields a <span class="math notranslate nohighlight">\(\coNP\)</span> algorithm.</p>
<p><span class="xref std std-ref">Chapter</span> is devoted to the study of advanced algorithms for parity games.</p>
<p>\begin{algorithm}
\KwData{A parity game <span class="math notranslate nohighlight">\(\Game\)</span> with priorities in <span class="math notranslate nohighlight">\([1,d]\)</span>}
\SetKwFunction{FSolveEven}{SolveEven}
\SetKwFunction{FSolveOdd}{SolveOdd}
\SetKwProg{Fn}{Function}{:}{}
\DontPrintSemicolon</p>
<p>\Fn{\FSolveEven{<span class="math notranslate nohighlight">\(\Game\)</span>}}{</p>
<p>Let <span class="math notranslate nohighlight">\(\Game'\)</span> the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrE(d)\)</span></p>
<p><span class="math notranslate nohighlight">\(X \leftarrow\)</span> \FSolveOdd{<span class="math notranslate nohighlight">\(\Game'\)</span>}</p>
<p>\If{<span class="math notranslate nohighlight">\(X = \emptyset\)</span>}{\Return{<span class="math notranslate nohighlight">\(V\)</span>}}
\Else{
Let <span class="math notranslate nohighlight">\(\Game''\)</span> the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrA(X)\)</span></p>
<p>\FSolveEven{<span class="math notranslate nohighlight">\(\Game''\)</span>}
}
}</p>
<p>\Fn{\FSolveOdd{<span class="math notranslate nohighlight">\(\Game\)</span>}}{
\If{<span class="math notranslate nohighlight">\(d = 1\)</span>}{\Return{<span class="math notranslate nohighlight">\(V\)</span>}}</p>
<p>Let <span class="math notranslate nohighlight">\(\Game'\)</span> the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrA(d)\)</span></p>
<p><span class="math notranslate nohighlight">\(X \leftarrow\)</span> \FSolveEven{<span class="math notranslate nohighlight">\(\Game'\)</span>}</p>
<p>\If{<span class="math notranslate nohighlight">\(X = \emptyset\)</span>}{\Return{<span class="math notranslate nohighlight">\(V\)</span>}}
\Else{
Let <span class="math notranslate nohighlight">\(\Game''\)</span> the subgame of <span class="math notranslate nohighlight">\(\Game\)</span> induced by <span class="math notranslate nohighlight">\(V \setminus \AttrE(X)\)</span></p>
<p>\FSolveOdd{<span class="math notranslate nohighlight">\(\Game''\)</span>}
}
}</p>
<p>\If{<span class="math notranslate nohighlight">\(d\)</span> is even}{
\FSolveEven{<span class="math notranslate nohighlight">\(\Game\)</span>}
}
\Else{
\FSolveOdd{<span class="math notranslate nohighlight">\(\Game\)</span>}
}
\caption{A recursive algorithm for computing the winning regions of parity games.}
\label{2-algo:zielonka}
\end{algorithm}</p>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./2_Classic/1_Regular"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="buchi.html" title="previous page"><span class="section-number">1.3. </span>A quadratic time algorithm for Büchi games</a>
    <a class='right-next' id="next-link" href="muller.html" title="next page"><span class="section-number">1.5. </span>Rabin, Streett, and Muller games</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>