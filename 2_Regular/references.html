
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bibliographic references &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Parity Games" href="../3_Parity/index.html" />
    <link rel="prev" title="Zielonka tree" href="zielonka.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../1_Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Regular Games
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="attractors.html">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="buchi.html">
     BÃ¼chi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../3_Parity/index.html">
   Parity Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Games with Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../5_MDP/index.html">
   Markov Decision Processes
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reachability.html">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="bibliographic-references">
<span id="sec-references"></span><h1>Bibliographic references<a class="headerlink" href="#bibliographic-references" title="Permalink to this headline">Â¶</a></h1>
<div class="math notranslate nohighlight">
\[\newcommand{\F}{\mathcal{F}} 
\newcommand{\LAR}{\mathrm{LAR}}
\newcommand{\Zielonka}{\mathrm{Zielonka}}
\newcommand{\depth}{\mathrm{depth}}
\newcommand{\support}{\mathrm{supp}}
\newcommand{\Eve}{\textrm{Eve}}
\newcommand{\Adam}{\textrm{Adam}}
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zinfty}{\Z \cup \set{\pm \infty}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Rinfty}{\R \cup \set{\pm \infty}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\Qinfty}{\Q \cup \set{\pm \infty}}
\newcommand{\argmax}{\textrm{argmax}}
\newcommand{\argmin}{\textrm{argmin}}
\newcommand{\Op}{\mathbb{O}}
\newcommand{\Prob}{\mathbb{P}} \newcommand{\dist}{\mathcal{D}} \newcommand{\Dist}{\dist} \newcommand{\supp}{\textrm{supp}} 
\newcommand{\game}{\mathcal{G}} \renewcommand{\Game}{\game} \newcommand{\arena}{\mathcal{A}} \newcommand{\Arena}{\arena} 
\newcommand{\col}{\textsf{col}} \newcommand{\Col}{\col} 
\newcommand{\mEve}{\mathrm{Eve}}
\newcommand{\mAdam}{\mathrm{Adam}}
\newcommand{\mRandom}{\mathrm{Random}}
\newcommand{\vertices}{V} \newcommand{\VE}{V_\mEve} \newcommand{\VA}{V_\mAdam} \newcommand{\VR}{V_\mRandom} 
\newcommand{\ing}{\textrm{In}}
\newcommand{\Ing}{\ing}
\newcommand{\out}{\textrm{Out}}
\newcommand{\Out}{\out}
\newcommand{\dest}{\Delta} 
\newcommand{\WE}{W_\mEve} \newcommand{\WA}{W_\mAdam} 
\newcommand{\Paths}{\textrm{Paths}} \newcommand{\play}{\pi} \newcommand{\first}{\textrm{first}} \newcommand{\last}{\textrm{last}} 
\newcommand{\mem}{\mathcal{M}} \newcommand{\Mem}{\mem} 
\newcommand{\Pre}{\textrm{Pre}} \newcommand{\PreE}{\textrm{Pre}_\mEve} \newcommand{\PreA}{\textrm{Pre}_\mAdam} \newcommand{\Attr}{\textrm{Attr}} \newcommand{\AttrE}{\textrm{Attr}_\mEve} \newcommand{\AttrA}{\textrm{Attr}_\mAdam} \newcommand{\rank}{\textrm{rank}}
\newcommand{\Win}{\textrm{Win}} 
\newcommand{\Lose}{\textrm{Lose}} 
\newcommand{\Value}{\textrm{val}} 
\newcommand{\ValueE}{\textrm{val}_\mEve} 
\newcommand{\ValueA}{\textrm{val}_\mAdam}
\newcommand{\val}{\Value} 
\newcommand{\Automaton}{\mathbf{A}} 
\newcommand{\Safe}{\mathtt{Safe}}
\newcommand{\Reach}{\mathtt{Reach}} 
\newcommand{\Buchi}{\mathtt{Buchi}} 
\newcommand{\CoBuchi}{\mathtt{CoBuchi}} 
\newcommand{\Parity}{\mathtt{Parity}} 
\newcommand{\Muller}{\mathtt{Muller}} 
\newcommand{\Rabin}{\mathtt{Rabin}} 
\newcommand{\Streett}{\mathtt{Streett}} 
\newcommand{\MeanPayoff}{\mathtt{MeanPayoff}} 
\newcommand{\DiscountedPayoff}{\mathtt{DiscountedPayoff}}
\newcommand{\Energy}{\mathtt{Energy}}
\newcommand{\TotalPayoff}{\mathtt{TotalPayoff}}
\newcommand{\ShortestPath}{\mathtt{ShortestPath}}
\newcommand{\Sup}{\mathtt{Sup}}
\newcommand{\Inf}{\mathtt{Inf}}
\newcommand{\LimSup}{\mathtt{LimSup}}
\newcommand{\LimInf}{\mathtt{LimInf}}
\newcommand{\NL}{\textrm{NL}}
\newcommand{\PTIME}{\textrm{PTIME}}
\newcommand{\NP}{\textrm{NP}}
\newcommand{\coNP}{\textrm{coNP}}
\newcommand{\PSPACE}{\textrm{PSPACE}}\]</div>
<p>The interest in reachability objectives goes beyond automata theory and logic.
The attractor computation presented in Section <a class="reference internal" href="attractors.html#sec-attractors"><span class="std std-ref">Reachability games</span></a> is inspired by the backward induction principle due to Zermelo <span id="id1">[<a class="reference internal" href="../1_Introduction/references.html#id40"><span>Zer13</span></a>]</span>,
which was used to show that well founded games (<strong>i.e.</strong> where all plays are finite) are determined.
The word attractor (together with traps and subgames) first appeared in Zielonkaâs work
on Muller games <span id="id2">[<a class="reference internal" href="#id76"><span>Zie98</span></a>]</span>, but without the algorithmic point of view.
A naive implementation of the attractor would have a quadractic time complexity.
It is difficult to give credit for the linear time algorithm since the problem being very natural it has appeared in several contexts,
for instance in database theory as an inference algorithm by Beeri and Bernstein <span id="id3">[<a class="reference internal" href="#id55"><span>BB79</span></a>]</span>
or in the framework of computing least fixed points over transition systems by Arnold and CrubillÃ© <span id="id4">[<a class="reference internal" href="#id54"><span>ACrubille88</span></a>]</span>.</p>
<p>The other objectives studied in this chapter are called <span class="math notranslate nohighlight">\(\omega\)</span>-regular,
let us discuss their relevance in automata theory and logic.
An important application of automata theory is to make logic effective: by translating, sometimes called compiling,
a logical formula into an equivalent automaton, we can solve problems such as satisfiability or model-checking by reducing them
to analysing automata and in particular their underlying graph structures.
In this context, the reachability objective is used for automata over finite words:
the classical definition is that a run is accepting if the last state is accepting.
Monadic second-order logic over finite words can be effectively translated into finite automata,
marking the beginning of a close connection between logic and automata theory.</p>
<p>Considering logics over infinite structures led to the study of automata over infinite structures such as words and trees.
The first objective to be studied in this context was BÃ¼chi objective, introduced by BÃ¼chi <span id="id5">[<a class="reference internal" href="#id56"><span>Buchi62</span></a>]</span>:
a run is accepting if it visits infinitely many times an accepting state.
Unfortunately the class of languages of infinite words recognised by deterministic BÃ¼chi automata is not closed under projection (corresponding in logic to existential quantification), said differently non-deterministic BÃ¼chi automata are strictly more expressive than deterministic ones
hence not equivalent to monadic second-order logic over infinite words.
Muller <span id="id6">[<a class="reference internal" href="#id71"><span>Mul63</span></a>]</span> introduced the Muller objectives and attempted to prove the closure under projection for deterministic Muller automata. Alas, the proof had a flaw.
The first correct proof of the result is due to McNaughton <span id="id7">[<a class="reference internal" href="../1_Introduction/references.html#id35"><span>McN66</span></a>]</span>.</p>
<p>The correspondence between monadic second-order logic and Muller automata was extended from infinite words to infinite binary trees
by Rabin <span id="id8">[<a class="reference internal" href="../1_Introduction/references.html#id38"><span>Rab69</span></a>]</span>, yielding the celebrated decidability of monadic second-order logic over infinite trees.
Rabin introduced and worked with Rabin objectives; his proof is arguably very complicated and a lot of subsequent works focussed on finding the right notions and tools for better understanding his approach.
Streett <span id="id9">[<a class="reference internal" href="#id72"><span>Str81</span></a>]</span> suggested to use the complement of Rabin objectives, now called Streett objectives, for translating temporal logics
to Streett automata.
As discussed in Section <a class="reference internal" href="../1_Introduction/references.html#sec-references"><span class="std std-ref">Bibliographic references</span></a>, a key step was made by applying determinacy results for games
to complementation results for automata.
The parity objectives appeared in this context as a (and in fact, the) subclass of Muller objectives which is positionally determined for both players.
They have been defined (with some variants) independently by several authors: Wagner <span id="id10">[<a class="reference internal" href="#id74"><span>Wag79</span></a>]</span>,
Mostowski <span id="id11">[<a class="reference internal" href="#id68"><span>Mos84</span></a>]</span> who called them Rabin chain,
Emerson and Jutla <span id="id12">[<a class="reference internal" href="#id59"><span>EJ91</span></a>]</span> who first used the name parity,
and McNaughton <span id="id13">[<a class="reference internal" href="#id70"><span>McN93</span></a>]</span>.
The idea can be traced back to the difference hierarchy by Hausdorff <span id="id14">[<a class="reference internal" href="#id62"><span>Hau14</span></a>]</span>.
The proof of the positionality was obtained independently by Mostowski <span id="id15">[<a class="reference internal" href="#id69"><span>Mos91</span></a>]</span>,
Emerson and Jutla <span id="id16">[<a class="reference internal" href="#id59"><span>EJ91</span></a>]</span>, and McNaughton <span id="id17">[<a class="reference internal" href="#id70"><span>McN93</span></a>]</span> (the latter proof is for finite games).
Later Walukiewicz <span id="id18">[<a class="reference internal" href="#id75"><span>Wal02</span></a>]</span> gave another very elegant proof.</p>
<p>McNaughton <span id="id19">[<a class="reference internal" href="#id70"><span>McN93</span></a>]</span> introduced the idea of solving Muller games by induction on the colours,
leading to McNaughton algorithm as presented in Section <a class="reference internal" href="muller.html#sec-muller"><span class="std std-ref">Rabin, Streett, and Muller games</span></a>.
To some extent, the algorithms for solving BÃ¼chi, CoBÃ¼chi, and parity games are all special cases of McNaughton algorithm.</p>
<p>Taking a step back in time, McNaughton already proposed the <strong>Latest Appearance Record</strong> (LAR) discussed in Section <a class="reference internal" href="zielonka.html#sec-zielonka"><span class="std std-ref">Zielonka tree</span></a>
for solving Muller games in his flawed attempt to solve the synthesis problem <span id="id20">[<a class="reference internal" href="../1_Introduction/references.html#id34"><span>McN65</span></a>]</span> (see Section <a class="reference internal" href="../1_Introduction/references.html#sec-references"><span class="std std-ref">Bibliographic references</span></a>).
The LAR was later used by Gurevich and Harrington <span id="id21">[<a class="reference internal" href="../1_Introduction/references.html#id30"><span>GH82</span></a>]</span> as memory for winning strategies in Muller games.
Thomas <span id="id22">[<a class="reference internal" href="#id73"><span>Tho95</span></a>]</span> showed that the LAR can be used to reduce Muller games to parity games.</p>
<p>Zielonka <span id="id23">[<a class="reference internal" href="#id76"><span>Zie98</span></a>]</span> greatly contributed to the study of Muller objectives and their subclasses
through his illuminating analysis of Zielonka trees.
One of the many contributions of Zielonkaâs landmark paper <span id="id24">[<a class="reference internal" href="#id76"><span>Zie98</span></a>]</span> was to follow McNaughtonâs approach for
constructing a recursive algorithm for solving parity games, and show that it implies their positionality.
We follow in Section <a class="reference internal" href="parity.html#sec-parity"><span class="std std-ref">Parity games</span></a> Zielonkaâs presentation of the algorithm, which is sometimes called Zielonka algorithm but more accurately
McNaughton Zielonka algorithm.</p>
<p>The characterisation result showing how Zielonka tree captures the exact memory requirements of Muller objectives is due to
Dziembowski, JurdziÅski, and Walukiewicz <span id="id25">[<a class="reference internal" href="#id57"><span>DJurdzinskiW97</span></a>]</span>.</p>
<p>The <span class="math notranslate nohighlight">\(\NP\)</span>-completeness stated in <a class="reference internal" href="muller.html#2-thm:Rabin_complexity">Theorem </a> for solving Rabin games is due to Emerson and Jutla <span id="id26">[<a class="reference internal" href="#id58"><span>EJ88</span></a>]</span>.
The study of the complexity of solving Muller games is due to Dawar and Hunter <span id="id27">[<a class="reference internal" href="#id65"><span>HD05</span></a>]</span>.
The <span class="math notranslate nohighlight">\(\PSPACE\)</span>-completeness results stated in <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">2-thm:complexity_Muller,2-thm:Muller_games_DAG</span></code> only concern two representations for Muller objectives. There are several others, which are not equally succinct.
For all representations but one the <span class="math notranslate nohighlight">\(\PSPACE\)</span>-completeness result holds; the only exception is the explicit representation
where the condition is specified by listing all sets of vertices in <span class="math notranslate nohighlight">\(\F\)</span>.
Surprisingly, solving Muller games with the explicit representation is in <span class="math notranslate nohighlight">\(\P\)</span> as shown by Horn <span id="id28">[<a class="reference internal" href="#id63"><span>Hor08</span></a>]</span>.</p>
<p>Our proof of positionality for Rabin objectives for <a class="reference internal" href="muller.html#2-thm:Rabin_positional_determinacy">Theorem </a>
and its extension to submixing objectives <a class="reference internal" href="muller.html#2-thm:submixing_positional">Theorem </a>
is inspired by the fairly mixing property of Gimbert and Zielonka <span id="id29">[<a class="reference internal" href="#id60"><span>GZ04</span></a>]</span>
and the concave property of KopczyÅski <span id="id30">[<a class="reference internal" href="#id66"><span>Kopczynski06</span></a>,<a class="reference internal" href="#id67"><span>Kopczynski08</span></a>]</span>.
Gimbert and Zielonka <span id="id31">[<a class="reference internal" href="#id61"><span>GZ05</span></a>]</span> further refined the submixing property to give a characterisation of objectives which are positionally determined for both players over finite games (they work in the more general framework of preference relations, which includes both qualitative and quantitative objectives).</p>
<p id="id32"><dl class="citation">
<dt class="label" id="id76"><span class="brackets">Zie98</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id23">2</a>,<a href="#id24">3</a>)</span></dt>
<dd><p>WiesÅaw Zielonka. Infinite games on finitely coloured graphs with applications to automata on infinite trees. <em>Theoretical Computer Science</em>, 200(1â2):135â183, 1998.</p>
</dd>
<dt class="label" id="id55"><span class="brackets"><a class="fn-backref" href="#id3">BB79</a></span></dt>
<dd><p>Catriel Beeri and PhilipÂ A. Bernstein. Computational problems related to the design of normal form relational schemas. <em>ACM Transactions on Database Systems</em>, 4(1):30â59, 1979.</p>
</dd>
<dt class="label" id="id54"><span class="brackets"><a class="fn-backref" href="#id4">ACrubille88</a></span></dt>
<dd><p>AndrÃ© Arnold and Paul CrubillÃ©. A linear algorithm to solve fixed-point equations on transition systems. <em>Information Processing Letters</em>, 29(2):57â66, 1988.</p>
</dd>
<dt class="label" id="id56"><span class="brackets"><a class="fn-backref" href="#id5">Buchi62</a></span></dt>
<dd><p>J.Â Richard BÃ¼chi. On a decision method in restricted second-order arithmetic. In <em>Proceedings of the International Congress of Logic, Methodology, and Philosophy of Science, CLMPS'60</em>, 1â11. Stanford University Press, 1962.</p>
</dd>
<dt class="label" id="id71"><span class="brackets"><a class="fn-backref" href="#id6">Mul63</a></span></dt>
<dd><p>DavidÂ E. Muller. Infinite sequences and finite machines. In <em>Proceedings of the Fourth Annual Symposium on Switching Circuit Theory and Logical Design</em>, SWCT â63, 3â16. IEEE Computer Society, 1963.</p>
</dd>
<dt class="label" id="id72"><span class="brackets"><a class="fn-backref" href="#id9">Str81</a></span></dt>
<dd><p>RobertÂ S. Streett. A propositional dynamic logic of looping and converse. Technical Report 263, Massachusetts Institute of Technology, 1981.</p>
</dd>
<dt class="label" id="id74"><span class="brackets"><a class="fn-backref" href="#id10">Wag79</a></span></dt>
<dd><p>KlausÂ W. Wagner. On omega-regular sets. <em>Information and Computation</em>, 43(2):123â177, 1979.</p>
</dd>
<dt class="label" id="id68"><span class="brackets"><a class="fn-backref" href="#id11">Mos84</a></span></dt>
<dd><p>AndrzejÂ W. Mostowski. Regular expressions for infinite trees and a standard form of automata. In <em>Computation Theory</em>. 1984.</p>
</dd>
<dt class="label" id="id59"><span class="brackets">EJ91</span><span class="fn-backref">(<a href="#id12">1</a>,<a href="#id16">2</a>)</span></dt>
<dd><p>E.Â Allen Emerson and CharanjitÂ S. Jutla. Tree automata, Âµ-calculus and determinacy. In <em>Proceedings of the Annual Symposium on Foundations of Computer Science, FoCS'91</em>, 368â377. IEEE Computer Society, 1991.</p>
</dd>
<dt class="label" id="id70"><span class="brackets">McN93</span><span class="fn-backref">(<a href="#id13">1</a>,<a href="#id17">2</a>,<a href="#id19">3</a>)</span></dt>
<dd><p>Robert McNaughton. Infinite games played on finite graphs. <em>Annals of Pure and Applied Logic</em>, 65(2):149â184, 1993.</p>
</dd>
<dt class="label" id="id62"><span class="brackets"><a class="fn-backref" href="#id14">Hau14</a></span></dt>
<dd><p>Felix Hausdorff. GrundzÃ¼ge der Mengenlehre. <em>Leipzig</em>, 1914.</p>
</dd>
<dt class="label" id="id69"><span class="brackets"><a class="fn-backref" href="#id15">Mos91</a></span></dt>
<dd><p>AndrzejÂ W. Mostowski. Games with forbidden positions. Technical Report 78, University of Gdansk, 1991.</p>
</dd>
<dt class="label" id="id75"><span class="brackets"><a class="fn-backref" href="#id18">Wal02</a></span></dt>
<dd><p>Igor Walukiewicz. Monadic second-order logic on tree-like structures. <em>Theoretical Computer Science</em>, 275(1-2):311â346, 2002.</p>
</dd>
<dt class="label" id="id73"><span class="brackets"><a class="fn-backref" href="#id22">Tho95</a></span></dt>
<dd><p>Wolfgang Thomas. On the synthesis of strategies in infinite games. In <em>Proceedings of the International Symposium on Theoretical Aspects of Computer Science, STACS'95</em>, volume 900 of LNCS, 1â13. Springer-Verlag, 1995.</p>
</dd>
<dt class="label" id="id57"><span class="brackets"><a class="fn-backref" href="#id25">DJurdzinskiW97</a></span></dt>
<dd><p>Stefan Dziembowski, Marcin JurdziÅski, and Igor Walukiewicz. How much memory is needed to win infinite games? In <em>Proceedings of the Annual IEEE Symposium on Logic in Computer Science, LICS'97</em>, 99â110. IEEE Computer Society, 1997.</p>
</dd>
<dt class="label" id="id58"><span class="brackets"><a class="fn-backref" href="#id26">EJ88</a></span></dt>
<dd><p>E.Â Allen Emerson and CharanjitÂ S. Jutla. The complexity of tree automata and logics of programs. In <em>Proceedings of the Annual Symposium on Foundations of Computer Science, FoCS'88</em>, 328â337. IEEE Computer Society, 1988.</p>
</dd>
<dt class="label" id="id65"><span class="brackets"><a class="fn-backref" href="#id27">HD05</a></span></dt>
<dd><p>Paul Hunter and Anuj Dawar. Complexity bounds for regular games. In <em>Proceedings of the International Symposium on Mathematical Foundations of Computer Science, MFCS'05</em>, volume 3618 of LNCS, 495â506. Springer-Verlag, 2005.</p>
</dd>
<dt class="label" id="id63"><span class="brackets"><a class="fn-backref" href="#id28">Hor08</a></span></dt>
<dd><p>Florian Horn. Explicit muller games are ptime. In <em>Proceedings of the International Conference on the Foundations of Software Technology and Theoretical Computer Science, FSTTCS'08</em>, volumeÂ 2 of LIPIcs, 235â243. SchloÃ Dagstuhl, 2008.</p>
</dd>
<dt class="label" id="id60"><span class="brackets"><a class="fn-backref" href="#id29">GZ04</a></span></dt>
<dd><p>Hugo Gimbert and WiesÅaw Zielonka. When can you play positionally? In <em>Proceedings of the International Symposium on Mathematical Foundations of Computer Science, MFCS'04</em>, volume 3153 of LNCS, 686â698. Springer-Verlag, 2004.</p>
</dd>
<dt class="label" id="id66"><span class="brackets"><a class="fn-backref" href="#id30">Kopczynski06</a></span></dt>
<dd><p>Eryk KopczyÅski. Half-positional determinacy of infinite games. In <em>Proceedings of the International Colloquium on Automata, Languages and Programming, ICALP'06</em>, volume 4052 of LNCS, 336â347. Springer-Verlag, 2006.</p>
</dd>
<dt class="label" id="id67"><span class="brackets"><a class="fn-backref" href="#id30">Kopczynski08</a></span></dt>
<dd><p>Eryk KopczyÅski. <em>Half-positional Determinacy of Infinite Games</em>. PhD thesis, University of Warsaw, 2008.</p>
</dd>
<dt class="label" id="id61"><span class="brackets"><a class="fn-backref" href="#id31">GZ05</a></span></dt>
<dd><p>Hugo Gimbert and WiesÅaw Zielonka. Games where you can play optimally without any memory. In <em>Proceedings of the International Conference on Concurrency Theory, CONCUR'05</em>, volume 3653 of LNCS, 428â442. Springer-Verlag, 2005.</p>
</dd>
</dl>
</p>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./2_Regular"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="zielonka.html" title="previous page">Zielonka tree</a>
    <a class='right-next' id="next-link" href="../3_Parity/index.html" title="next page">Parity Games</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>