
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Forward Algorithm &#8212; Games on graphs</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Bibliographic references" href="references.html" />
    <link rel="prev" title="Backward Algorithm" href="backward_algorithm.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cover.jpg" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Games on graphs</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <p class="caption collapsible-parent">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../1_Introduction/index.html">
   Introduction
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/intro.html">
     What is this book about?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/simple.html">
     A first model of games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/objectives.html">
     Objectives
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/computation.html">
     Computational models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/automata.html">
     Automata
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/memory.html">
     Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/reductions.html">
     Reductions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/subgames.html">
     Traps and subgames
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/fixed_points.html">
     Generic fixed point algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/value_iteration.html">
     Value iteration algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/strategy_improvement.html">
     Strategy improvement algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../1_Introduction/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Classic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../2_Regular/index.html">
   Regular Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/attractors.html">
     Reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/buchi.html">
     Büchi games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/parity.html">
     Parity games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/muller.html">
     Rabin, Streett, and Muller games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/zielonka.html">
     Zielonka tree
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2_Regular/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../3_Parity/index.html">
   Parity Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/strategy_improvement.html">
     An exponential time strategy improvement algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/zielonka.html">
     A quasipolynomial time attractor decomposition algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/separation.html">
     A quasipolynomial time separating automata algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/value_iteration.html">
     A quasipolynomial time value iteration algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/relationships.html">
     Comparing the three families of algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../3_Parity/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../4_Payoffs/index.html">
   Games with Payoffs
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/qualitative.html">
     Refining qualitative objectives with quantities
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/mean_payoff.html">
     Mean payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/discounted_payoff.html">
     Discounted payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/shortest_path.html">
     Shortest path games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/total_payoff.html">
     Total payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4_Payoffs/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Stochastic
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../5_MDP/index.html">
   Markov Decision Processes
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reachability.html">
     Positive and almost-sure reachability and safety in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/discounted.html">
     Discounted payoff in MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_properties.html">
     Mean-payoff in MDPs: General properties and linear programming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/mean_payoff_strongly_connected.html">
     Mean-payoff optimality in strongly connected MDPs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/end_components.html">
     End components
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/reductions.html">
     Reductions to optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/optimal_reachability.html">
     Optimal reachability
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5_MDP/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../6_Stochastic/index.html">
   Stochastic Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/determinacy.html">
     Positional determinacy of stochastic reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/relations.html">
     Relations between all games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/algos.html">
     Algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6_Stochastic/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Information
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../7_Concurrent/index.html">
   Concurrent Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/matrix_games.html">
     Matrix games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/reachability.html">
     Concurrent reachability games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/mean_payoff.html">
     Concurrent mean-payoff games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/discounted.html">
     Concurrent discounted games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../7_Concurrent/references.html">
     Bibilographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../8_Imperfect/index.html">
   Games with Signals
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/finite_duration.html">
     Finite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/infinite_duration.html">
     Infinite duration
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../8_Imperfect/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Infinite
 </span>
</p>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1 current active collapsible-parent">
  <a class="reference internal" href="index.html">
   Timed Games
  </a>
  <ul class="current collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="state_space_representation.html">
     State-Space Representation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="controllable_predecessor_operator.html">
     Controllable-Predecessor Operator
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="backward_algorithm.html">
     Backward Algorithm
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Forward Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../10_Pushdown/index.html">
   Pushdown Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/notations.html">
     Notations
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/profiles.html">
     Profiles and regularity of the winning regions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/parity.html">
     Parity pushdown games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10_Pushdown/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../11_Counters/index.html">
   Games with Counters
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/counters.html">
     Vector games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/dim1.html">
     Games in dimension one
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/avag.html">
     Asymmetric games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/resource.html">
     Resource-conscious games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/complexity.html">
     The complexity of asymmetric monotone games
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../11_Counters/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>
<p class="caption collapsible-parent">
 <span class="caption-text">
  Multi
 </span>
</p>
<ul class="nav sidenav_l1">
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../12_Multiobjectives/index.html">
   Games with multiple objectives
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/mean_payoff_energy.html">
     Mean-payoff and energy
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/total_payoff_shortest_path.html">
     Total-payoff and shortest path
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/beyond_worst_case.html">
     Beyond worst-case synthesis
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/percentile.html">
     Percentile queries
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../12_Multiobjectives/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
 <li class="toctree-l1 collapsible-parent">
  <a class="reference internal" href="../13_Multiplayer/index.html">
   Multiplayer Games
  </a>
  <ul class="collapse-ul">
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/nash_equilibria_normal_form.html">
     Nash Equilibria for games in normal form
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/admissible_strategies.html">
     Admissible strategies
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../13_Multiplayer/references.html">
     Bibliographic references
    </a>
   </li>
  </ul>
  <i class="fas fa-chevron-down">
  </i>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#a-forward-algorithm-for-finite-state-games">
   A Forward Algorithm for Finite-State Games
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#extension-to-timed-games">
   Extension to Timed Games
  </a>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="forward-algorithm">
<span id="sec-forward-algorithm"></span><h1>Forward Algorithm<a class="headerlink" href="#forward-algorithm" title="Permalink to this headline">¶</a></h1>
<div class="math notranslate nohighlight">
\[\renewcommand{\Game}{\game}
\]</div>
<p>The backward algorithm we just presented is conceptually simple, but
it is often not very efficient in practice,
as federations tend to grow too much in size in each iteration of the
computation.
The forward algorithm we will now present is more efficient in practice.
It performs a forward exploration and only applies the controllable predecessor along branches
that actually reach the target state from the initial state. If the witness
trace is not excessively long, which is often the case in practice,
this limits the size of the federations.</p>
<p>We present below the algorithm proposed in <span id="id1">[<span>CDFLL05</span>]</span>,
and as a first step, we explain the untimed version of that algorithm,
based on an algorithm of Liu and Smolka for computing
fixpoints <span id="id2">[<a class="reference internal" href="references.html#id161"><span>LS98</span></a>]</span>.</p>
<div class="section" id="a-forward-algorithm-for-finite-state-games">
<h2>A Forward Algorithm for Finite-State Games<a class="headerlink" href="#a-forward-algorithm-for-finite-state-games" title="Permalink to this headline">¶</a></h2>
<p>The original algorithm of Liu and Smolka is expressed in terms of
<strong>(pre-)fixpoints</strong> in <strong>dependency graphs</strong>: a dependency graph
is a pair <span class="math notranslate nohighlight">\(G=(V,E)\)</span> in which <span class="math notranslate nohighlight">\(E \subseteq V \times 2^V\)</span> relates
states with sets of states.</p>
<p>For any order-preserving
function <span class="math notranslate nohighlight">\(f\colon 2^V\to2^V\)</span>
(<strong>order-preserving</strong> meaning non-decreasing for the <span class="math notranslate nohighlight">\(\subseteq\)</span>-relation),</p>
<p>a <strong>pre-fixpoint</strong> is a set <span class="math notranslate nohighlight">\(X\subseteq V\)</span> for which <span class="math notranslate nohighlight">\(f(X)\subseteq
X\)</span>; it is a <strong>fixpoint</strong> if <span class="math notranslate nohighlight">\(f(X)=X\)</span>. By Knaster-Tarski theorem, such
functions always admit a least pre-fixpoint which is also the least fixpoint.</p>
<p>Fix a dependency graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>.
For <span class="math notranslate nohighlight">\(W\subseteq V\)</span>,
we define a mapping <span class="math notranslate nohighlight">\(f_W\colon 2^V\to 2^V\)</span>: for
each <span class="math notranslate nohighlight">\(X\subseteq V\)</span>, we let <span class="math notranslate nohighlight">\(f_W(X)=W\cup \{v\in V\mid \exists (v,Y)\in
E.\ Y\subseteq X\}\)</span>.</p>
<p>Clearly, <span class="math notranslate nohighlight">\(X\subseteq X'\)</span> implies <span class="math notranslate nohighlight">\(f_W(X)\subseteq f_W(X')\)</span>, so that <span class="math notranslate nohighlight">\(f_W\)</span> admits
a least (pre-)fixpoint.
The Liu-Smolka
algorithm aims at deciding whether a given vertex <span class="math notranslate nohighlight">\(v_0\in V\)</span> belongs
to the least fixpoint of <span class="math notranslate nohighlight">\(f_W\)</span>.  Classical algorithms for computing
least fixpoints consist in iteratively
computing <span class="math notranslate nohighlight">\((f_W^i(\emptyset))_i\)</span> until convergence (assuming <span class="math notranslate nohighlight">\(V\)</span> is
finite). Observe that this corresponds to the algorithm of <a class="reference internal" href="backward_algorithm.html#9-thm:timed-control">Theorem 281</a>
for timed games.
The Liu-Smolka algorithm proceeds from <span class="math notranslate nohighlight">\(v_0\)</span>, and explores
the dependency graph until it can claim that <span class="math notranslate nohighlight">\(v_0\)</span> is, or that it
is not, in the least fixpoint of <span class="math notranslate nohighlight">\(f_W\)</span>.</p>
<p>Before tackling the algorithm, let us link least fixpoints in
dependency graphs and winning sets in concurrent games (with
reachability objectives): with a concurrent arena
<span class="math notranslate nohighlight">\(\mathcal C=(V, \textsf{Act},\delta,c')\)</span> and a target set <span class="math notranslate nohighlight">\(Win\)</span>, we associate
the dependency graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>, where <span class="math notranslate nohighlight">\((v,T)\in E\)</span> whenever <span class="math notranslate nohighlight">\(v\in V\)</span>
and <span class="math notranslate nohighlight">\(T\subseteq V\)</span> is such that there exists an action <span class="math notranslate nohighlight">\(a\)</span> for which
<span class="math notranslate nohighlight">\(T=\{v' \mid \exists a'\in \textsf{Act}.\ v'=\delta(v,a,a')\}\)</span>.  Then for any
set <span class="math notranslate nohighlight">\(X\subseteq V\)</span>, the set <span class="math notranslate nohighlight">\(f_{ Win}(X)\)</span> contains <span class="math notranslate nohighlight">\(Win\)</span> and all the
states from which Eve can force a visit to <span class="math notranslate nohighlight">\(X\)</span> in one step.
We then have:</p>
<div class="proof proposition admonition" id="9-prop:fixp-game">
<p class="admonition-title"><span class="caption-number">Proposition 282 </span> (NEEDS TITLE 9-prop:fixp-game)</p>
<div class="proposition-content section" id="proof-content">
<p>The least fixpoint of <span class="math notranslate nohighlight">\(f_{ Win}\)</span> in <span class="math notranslate nohighlight">\(G\)</span> corresponds to the set <span class="math notranslate nohighlight">\(W\)</span> of
winning states for  Eve in <span class="math notranslate nohighlight">\(\mathcal C\)</span>.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>The winning states of  Eve form a pre-fixpoint of <span class="math notranslate nohighlight">\(f_{ Win}\)</span>
containing  Win: indeed, for any <span class="math notranslate nohighlight">\(v\in f_{ Win}(W)\)</span>, either <span class="math notranslate nohighlight">\(v\in
   Win\)</span>, or  Eve has an action to move from <span class="math notranslate nohighlight">\(v\)</span> to some state
in <span class="math notranslate nohighlight">\(W\)</span>. Hence <span class="math notranslate nohighlight">\(v\)</span> is winning, i.e., <span class="math notranslate nohighlight">\(v\in W\)</span>.</p>
<p>Conversely, from any state <span class="math notranslate nohighlight">\(v\)</span> that is not in the least
pre-fixpoint <span class="math notranslate nohighlight">\(X\)</span>, for any edge <span class="math notranslate nohighlight">\((v,T)\)</span>, there is a state <span class="math notranslate nohighlight">\(v'\in T\)</span>
that again is not in <span class="math notranslate nohighlight">\(X\)</span>. This defines a strategy for  Adam to avoid
reaching <span class="math notranslate nohighlight">\(Win\)</span>, so that  Eve does not have a winning strategy from <span class="math notranslate nohighlight">\(v\)</span>.</p>
</div>
<p>\begin{algorithm}
\SetKwFunction{Pop}{pop}\SetAlgoNoEnd
\KwData{A dependency graph <span class="math notranslate nohighlight">\(G=(V,E)\)</span>, a set <span class="math notranslate nohighlight">\(W\subseteq V\)</span>, a node <span class="math notranslate nohighlight">\(v_0\in V\)</span>}
\KwResult{Is <span class="math notranslate nohighlight">\(v_0\)</span> in the least fixpoint of <span class="math notranslate nohighlight">\(f_W\)</span>?}</p>
<p>\For{<span class="math notranslate nohighlight">\(v\in V\)</span>}{\lIf{<span class="math notranslate nohighlight">\(v\in W\)</span>}{<span class="math notranslate nohighlight">\(F(v):=1\)</span>}
\lElseIf{<span class="math notranslate nohighlight">\(v==v_0\)</span>}{<span class="math notranslate nohighlight">\(F(v):=0\)</span>}
\lElse{<span class="math notranslate nohighlight">\(F(v):=\bot\)</span>}}</p>
<p><span class="math notranslate nohighlight">\(\textsf{Dep}(v_0):=\emptyset\)</span>;</p>
<p><span class="math notranslate nohighlight">\(\textsf{Wait}:=\{(v,T)\in E \mid v=v_0\}\)</span>;</p>
<p>\While{(<span class="math notranslate nohighlight">\(\textsf{Wait}\not=\emptyset\)</span> and <span class="math notranslate nohighlight">\(F(v_0)==0\)</span>)}
{<span class="math notranslate nohighlight">\((v,T):=\Pop{ \textsf{Wait}}\)</span>;\
\If({// case 1}){<span class="math notranslate nohighlight">\(F(v)==0\)</span> and <span class="math notranslate nohighlight">\(\forall v'\in T.\ F(v')==1\)</span>}
{<span class="math notranslate nohighlight">\(F(v):=1\)</span>;\
<span class="math notranslate nohighlight">\(\textsf{Wait}:= \textsf{Wait}\cup \textsf{Dep}(v)\)</span>;}
\ElseIf({// case 2}){<span class="math notranslate nohighlight">\(\exists v'\in T.\ F(v')==0\)</span>}
{<span class="math notranslate nohighlight">\(\textsf{Dep}(v'):= \textsf{Dep}(v') \cup \{(v,T)\}\)</span>;}
\ElseIf({// case 3}){<span class="math notranslate nohighlight">\(\exists v'\in T.\ F(v')==\bot\)</span>}
{<span class="math notranslate nohighlight">\(F(v'):=0\)</span>; \
<span class="math notranslate nohighlight">\(\textsf{Dep}(v'):=\{(v,T)\}\)</span>;\
<span class="math notranslate nohighlight">\(\textsf{Wait}:= \textsf{Wait}\cup\{(w,U)\in E \mid w=v'\}\)</span>;
}
}
\Return{<span class="math notranslate nohighlight">\(F(v_0)\)</span>}
\caption{Liu-Smolka algorithm\protect\footnotemark for least fixpoint of <span class="math notranslate nohighlight">\(f_W\)</span>}
\label{9-algo:LS98}
\end{algorithm}
\footnotetext{Our version of the algorithm slightly differs from the
original one <span id="id3">[<a class="reference internal" href="references.html#id161"><span>LS98</span></a>]</span>: we let <span class="math notranslate nohighlight">\(\textsf{Dep}(v'):=\{(v,T)\}\)</span> at the penultimate line
of the <strong>while</strong> loop (which otherwise results in a wrong
result, as already noticed in <span id="id4">[<span>JLSO13</span>]</span>), reinforce the
condition for case <span class="math notranslate nohighlight">\(1\)</span> (which otherwise would not guarantee
termination), and reinforce the condition of the <strong>while</strong> loop
to get earlier termination.}</p>
<p><code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:LS98</span></code> can be seen as an alternation of forward
exploration and backward propagation. Intuitively, the algorithm first
explores the graph in a forward manner, remembering for each node <span class="math notranslate nohighlight">\(v\)</span>
the set <span class="math notranslate nohighlight">\(\textsf{Dep}(v)\)</span> of nodes that <strong>depend</strong> on <span class="math notranslate nohighlight">\(v\)</span>, and have to be
reexplored if the status of <span class="math notranslate nohighlight">\(v\)</span> is updated.</p>
<p>For each <span class="math notranslate nohighlight">\(v\)</span>, the algorithm maintains a
value <span class="math notranslate nohighlight">\(F(v)\)</span>, which is <span class="math notranslate nohighlight">\(\bot\)</span> if <span class="math notranslate nohighlight">\(v\)</span> has not been explored yet,
<span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(v\)</span> has been explored but not yet been shown to be winning,
and <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(v\)</span> is known to be winning.</p>
<p>Whenever a vertex <span class="math notranslate nohighlight">\(v\)</span> whose all successors are winning is found, the value of <span class="math notranslate nohighlight">\(v\)</span> is set to <span class="math notranslate nohighlight">\(1\)</span>, and its parents (in <span class="math notranslate nohighlight">\(\textsf{Dep}(v)\)</span>)
are scheduled to be visited again to check whether their statuses have to be changed.
This is how the backward propagation is triggered; in fact, the search will climb in the tree as long as the values of
vertices can be updated to <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>The correctness of this algorithm relies on the following lemma:</p>
<p>````{prf:lemma} <span id="id5">[<a class="reference internal" href="references.html#id161"><span>LS98</span></a>]</span>
:label: 9-lemma:ls98</p>
<p>The following properties hold at the end of each run in the
<strong>while</strong> loop of <code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:LS98</span></code>:</p>
<ul class="simple">
<li><p>for any <span class="math notranslate nohighlight">\(v\in V\)</span>, if <span class="math notranslate nohighlight">\(F(v)=1\)</span>, then <span class="math notranslate nohighlight">\(v\)</span> belongs to the least
fixpoint containing <span class="math notranslate nohighlight">\(W\)</span>;</p></li>
<li><p>for any <span class="math notranslate nohighlight">\(v\in V\)</span> with <span class="math notranslate nohighlight">\(F(v)=0\)</span>, and any <span class="math notranslate nohighlight">\((v,T)\in E\)</span>, either
<span class="math notranslate nohighlight">\((v,T)\in  \textsf{Wait}\)</span> or <span class="math notranslate nohighlight">\((v,T)\in \textsf{Dep}(v')\)</span> for some <span class="math notranslate nohighlight">\(v'\in T\)</span> with
<span class="math notranslate nohighlight">\(F(v')=0\)</span>.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
````{admonition} Proof
:class: dropdown tip

  We fix an execution of {numref}`9-algo:LS98`, and prove that both
  claims are true at the beginning and end of each iteration through
  the **while** loop. To clarify the presentation, we use
  superscript $i$ to indicate the value of variables at the end of the
  $i$-th run through the loop, so that $\textsf{Wait}^3$ is the value of
  variable $\textsf{Wait}$ after three iterations (and $\textsf{Wait}^0$ is its value
  after initialization). In particular, $(v^i,T^i)$ is the
  symbolic transition popped from the $\textsf{Wait}$ list during the $i$-th
  iteration (and is not defined for $i=0$).

  Let us first prove the first property: the initialization phase
  clearly enforces that if $F^0(x)=1$, then $x\in W$, which is
  included in any fixpoint of $f_W$. Now, assume that the property
  holds true at the beginning of the $i$-th run through the loop
  (i.e., if $F^{i-1}(x)=1$, then $x$ is in the least fixpoint), and
  pick some $x\in V$ such that $F^i(x)=1$. If $F^{i-1}(x)=1$, our
  result follows; if not, then the $i$-th iteration of the loop must
  have run via case $1$, hence $F^{i-1}(x&#39;)=1$ for all $x&#39;\in
  T^i$. By our induction hypothesis, this indicates that $T^i$ is part
  of the least fixpoint, and by definition of $f_W$, $x$ must also
  belong to the least fixpoint.

  \smallskip
  The second statement also clearly holds after initialization:
  initially, $F^0(x)=0$ only for $x=v_0$, and all transitions
  from $v_0$ have been stored in $\textsf{Wait}^0$. We now assume that the
  property holds when entering the **while** loop for the $i$-th
  time, and consider $x$ such that $F^i(x)=0$ at the end of that
  loop. We pick $(x,Y)\in E$.
  
  *  if the $i$-th run through the loop visits case $1$, then
    already $F^{i-1}(x)=0$ (hence $x\not=v^i$). Then either
    $(x,Y)\in \textsf{Wait}^{i-1}$, or $(x,Y)\in \textsf{Dep}^{i-1}(x&#39;)$ for some $x&#39;\in Y$
    with $F(x&#39;)=0$. In the former case: since $x\not=v^i$,
    if $(x,Y)\in \textsf{Wait}^{i-1}$ then also $(x,Y)\in  \textsf{Wait}^i$;

    in the latter case: if $(x,Y)\in \textsf{Dep}^{i-1}(x&#39;)$ for some $x&#39;\in Y$
    with $F(x&#39;)=0$, then **(i)** either $x&#39;=v^i$, and
    $(x,Y)\in \textsf{Wait}^i$ because $\textsf{Dep}^{i-1}(v^i)\subseteq  \textsf{Wait}^i$
    (last line of case $1$), **(ii)** or ${x&#39;\not=v^i}$, and
    $(x,Y)\in  \textsf{Dep}^{i-1}(x&#39;)= \textsf{Dep}^{i}(x&#39;)$ and $F^i(x&#39;)=F^{i-1}(x&#39;)=0$.

  *  if the $i$-th run goes to case $2$, then again $F^{i-1}(x)=0$,
    and the induction hypothesis applies: either $(x,Y)$ is
    in $\textsf{Wait}^{i-1}$, or it is in $\textsf{Dep}^{i-1}(x&#39;)$ for some $x&#39;\in Y$
    with $F^{i-1}(x&#39;)=0$. For the latter case, observe that
    $\textsf{Dep}^{i-1}(x&#39;)\subseteq  \textsf{Dep}^i(x&#39;)$, and $F^{i}(x&#39;)=F^{i-1}(x&#39;)$
    when running case $2$; for the former case, we have
    $\textsf{Wait}^i= \textsf{Wait}^{i-1}\setminus\{(v^i,T^i)\}$, so that $(x,Y)$
    remain in $\textsf{Wait}^i$ if $(x,Y)\not=(v^i,T^i)$; finally,
    if $(x,Y)=(v^i,T^i)$, then case $2$ precisely adds $(v^i,T^i)$
    to $\textsf{Dep}^i(v&#39;)$ for some $v&#39;\in T^i$ with $F^i(v&#39;)=0$, which concludes
    the proof for this case.

  *  for case $3$, we first consider the case where $x$ is the
    state $v&#39;$ selected at the beginning of case $3$: in that case,
    all transitions from $x$ are added to $\textsf{Wait}$, so that
    $(x,Y)\in \textsf{Wait}^i$. Now, if $x$ is not the selected state $v&#39;$,
    then $F^{i-1}(x)=0$, and again either $x\in \textsf{Wait}^{i-1}$ or
    $x\in \textsf{Dep}^{i-1}(x&#39;)$ for some $x&#39;\in Y$ with
    $F^{i-1}(x&#39;)=0$. The latter case is preserved when running
    case $3$; if $x\in \textsf{Wait}^{i-1}$: if $(x,Y)\not=(v^i,T^i)$, then
    $x\in \textsf{Wait}^i$, while if $(x,Y)=(v^i,T^i)$, then
    $(x,Y)\in \textsf{Dep}^i(v&#39;)$ for the state $v&#39;\in T^i$ selected at the
    beginning of case $3$ (and for which $F^i(v&#39;)=0$).

</pre></div>
</div>
<p>As a corollary, if the algorithm terminates after <span class="math notranslate nohighlight">\(n\)</span> rounds of the
<strong>while</strong> loop, then either <span class="math notranslate nohighlight">\(F^n(v_0)=1\)</span>, or
<span class="math notranslate nohighlight">\(F^n(v_0)=0\)</span> and <span class="math notranslate nohighlight">\(\textsf{Wait}^n=\emptyset\)</span>.</p>
<ul class="simple">
<li><p>From the first claim of the lemma above, the former case entails
that <span class="math notranslate nohighlight">\(v_0\)</span> belongs to the least fixpoint.</p></li>
<li><p>Now consider the second case, and let <span class="math notranslate nohighlight">\(B=\left\{v\in V\mid
F^n(v)\in \{\bot,1\}\right\}\)</span>. We prove that <span class="math notranslate nohighlight">\(f_W(B)\subseteq
B\)</span>. For this, we pick <span class="math notranslate nohighlight">\(v\in f_W(B)\)</span>:</p>
<ul>
<li><p>if <span class="math notranslate nohighlight">\(v\in W\)</span>, then <span class="math notranslate nohighlight">\(F(v)\)</span> is set to <span class="math notranslate nohighlight">\(1\)</span> initially, and may
never be changed, so that <span class="math notranslate nohighlight">\(v\in B\)</span>;</p></li>
<li><p>otherwise, there is a transition <span class="math notranslate nohighlight">\((v,T)\)</span> such that <span class="math notranslate nohighlight">\(T\subseteq
B\)</span>. If <span class="math notranslate nohighlight">\(v\notin B\)</span>, then <span class="math notranslate nohighlight">\((v,T)\in \textsf{Dep}^n(v')\)</span> for some <span class="math notranslate nohighlight">\(v'\in T\)</span>
with <span class="math notranslate nohighlight">\(F^n(v')=0\)</span>, which contradicts the fact that <span class="math notranslate nohighlight">\(T\subseteq B\)</span>.</p></li>
</ul>
</li>
</ul>
<p>This proves that <span class="math notranslate nohighlight">\(f_W(B)\subseteq B\)</span>, so that <span class="math notranslate nohighlight">\(B\)</span> is a pre-fixpoint
of <span class="math notranslate nohighlight">\(f_W\)</span>. It thus contains the least (pre-)fixpoint of <span class="math notranslate nohighlight">\(f_W\)</span>, so
that any state <span class="math notranslate nohighlight">\(v\)</span> not in <span class="math notranslate nohighlight">\(B\)</span> (i.e., with <span class="math notranslate nohighlight">\(F^n(v)=0\)</span>) for sure does
not belong to that least fixpoint. In particular, <span class="math notranslate nohighlight">\(v_0\)</span> is not in
the fixpoint.</p>
<p>\medskip
It remains to prove termination. For this, we first notice that, for
any hyper-edge <span class="math notranslate nohighlight">\((v,S)\)</span>, if <span class="math notranslate nohighlight">\((v,S)\in \textsf{Dep}^i(v')\)</span> then <span class="math notranslate nohighlight">\((v,S)\in \textsf{Wait}^j\)</span>
for some <span class="math notranslate nohighlight">\(j&lt;i\)</span>, and if <span class="math notranslate nohighlight">\((v,S)\in \textsf{Wait}^j\)</span> or <span class="math notranslate nohighlight">\((v,S)\in \textsf{Dep}^j(v')\)</span> for
some <span class="math notranslate nohighlight">\(v'\)</span>, then <span class="math notranslate nohighlight">\(F^j(v)\not=\bot\)</span>.</p>
<p>We then set</p>
<div class="math notranslate nohighlight">
\[
M= 
2 | \textsf{Wait|} + 
2\hskip-4pt\sum_{v\text{ s.t. }F(v)=\bot}\hskip-4pt  |\{(v,S)\in E\|} 
+ \hskip-4pt\sum_{v\text{ s.t. }F(v)=0}\hskip-4pt  | \textsf{Dep|(v)}
- \hskip-4pt\sum_{v\text{ s.t. }F(v)=1}\hskip-4pt  | \textsf{Dep|(v)}\]</div>
<p>again writing <span class="math notranslate nohighlight">\(M^i\)</span> for the value of <span class="math notranslate nohighlight">\(M\)</span> after the <span class="math notranslate nohighlight">\(i\)</span>-th run through
the <strong>while</strong> loop.  This value is at most <span class="math notranslate nohighlight">\(2 |E|\)</span> when
entering the <strong>while</strong> loop for the first time; clearly, it can
never go below <span class="math notranslate nohighlight">\(- |E|\)</span>. We now prove that <span class="math notranslate nohighlight">\(M^{i}&lt;M^{i-1}\)</span>,</p>
<p>which implies termination of the algorithm.</p>
<p>Consider the <span class="math notranslate nohighlight">\(i\)</span>-th run through the loop, popping <span class="math notranslate nohighlight">\((v^i,T^i)\)</span>
from <span class="math notranslate nohighlight">\(\textsf{Wait}^{i-1}\)</span> (which decreases <span class="math notranslate nohighlight">\(M\)</span> by <span class="math notranslate nohighlight">\(2\)</span>). We consider all three cases:</p>
<ul class="simple">
<li><p>if case <span class="math notranslate nohighlight">\(1\)</span> applies, <span class="math notranslate nohighlight">\(F^i(v)\)</span> is set to <span class="math notranslate nohighlight">\(1\)</span>.
The set <span class="math notranslate nohighlight">\(\textsf{Dep}^{i-1}(v)\)</span> is added to <span class="math notranslate nohighlight">\(\textsf{Wait}^i\)</span>. This globally
leaves <span class="math notranslate nohighlight">\(M\)</span> unchanged, so that globally <span class="math notranslate nohighlight">\(M^i=M^{i-1}-2\)</span>;</p></li>
<li><p>if case <span class="math notranslate nohighlight">\(2\)</span> applies, <span class="math notranslate nohighlight">\(\textsf{Dep}^{i-1}(v')\)</span> is augmented by (at most) one edge,
and since <span class="math notranslate nohighlight">\(F^i(v')=0\)</span>, this increases <span class="math notranslate nohighlight">\(M\)</span> by at most <span class="math notranslate nohighlight">\(1\)</span>. Hence globally
<span class="math notranslate nohighlight">\(M^i\leq M^{i-1}-1\)</span>;</p></li>
<li><p>finally, case <span class="math notranslate nohighlight">\(3\)</span> increases <span class="math notranslate nohighlight">\(M\)</span> by <span class="math notranslate nohighlight">\(1\)</span>: the edges added
to <span class="math notranslate nohighlight">\(\textsf{Wait}\)</span> are compensated by the fact that <span class="math notranslate nohighlight">\(F(v')\)</span> no longer
is <span class="math notranslate nohighlight">\(\bot\)</span>, and only one extra edge has to be considered in the
second sum. Hence again <span class="math notranslate nohighlight">\(M^i\leq M^{i-1}-1\)</span>.</p></li>
</ul>
<p>This concludes the correctness proof of <code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:LS98</span></code>.</p>
<div class="proof theorem admonition" id="theorem-1">
<p class="admonition-title"><span class="caption-number">Theorem 283 </span> (NEEDS TITLE AND LABEL)</p>
<div class="theorem-content section" id="proof-content">
<p><code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:LS98</span></code> terminates, and returns <span class="math notranslate nohighlight">\(1\)</span> if, and only if,
<span class="math notranslate nohighlight">\(v_0\)</span> belongs to the least fixpoint of <span class="math notranslate nohighlight">\(f_W\)</span>.</p>
<p><code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:LS98</span></code> terminates, and returns <span class="math notranslate nohighlight">\(1\)</span> if, and only if,
<span class="math notranslate nohighlight">\(v_0\)</span> belongs to the least fixpoint of <span class="math notranslate nohighlight">\(f_W\)</span>.</p>
</div>
</div><p>Using <a class="reference internal" href="#9-prop:fixp-game">Proposition 282</a>, we get a <strong>forward</strong> algorithm for
deciding if a given state of a concurrent game is winning
for Eve. This corresponds to the OTFUR algorithm
of <span id="id6">[<span>CDFLL05</span>]</span>.</p>
</div>
<div class="section" id="extension-to-timed-games">
<h2>Extension to Timed Games<a class="headerlink" href="#extension-to-timed-games" title="Permalink to this headline">¶</a></h2>
<p>We now explain how to adapt the algorithm above to (infinite-state)
timed games.</p>
<p>For efficiency, the algorithm relies on zones (and DBMs); instead of
computing whether a given zone <span class="math notranslate nohighlight">\((\ell,Z)\)</span> is winning, the algorithm
maintains, for each zone <span class="math notranslate nohighlight">\(S=(\ell,Z)\)</span> it explores, a subzone <span class="math notranslate nohighlight">\((\ell,Z')\)</span> of
configurations that it knows are winning; this subzone is stored as
<span class="math notranslate nohighlight">\(F(S)\)</span>, and is updated during the execution.
As in <code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:LS98</span></code>, a waiting list keeps track of the
zones to be explored, and a dependency list stores the list of nodes
to be revisited upon update of the winning subzone of a zone.
The algorithm is given in <code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:sotftr</span></code>.</p>
<p>\begin{algorithm}
\SetKwFunction{Pop}{pop}\SetAlgoNoEnd
\KwData{A reachability timed game <span class="math notranslate nohighlight">\(\mathcal{G}=( \mathcal{A},  \mathtt{Reach}( Win))\)</span>,
a location <span class="math notranslate nohighlight">\(\ell_0\in  \mathcal{L}\)</span>}
\KwResult{Is <span class="math notranslate nohighlight">\((\ell_0,\mathbf{0})\)</span> winning for Eve?}</p>
<p><span class="math notranslate nohighlight">\(S_0:= \sf Post_{\geq 0}(\ell_0,\mathbf 0)\)</span>;</p>
<p>\leIf{<span class="math notranslate nohighlight">\(c(S_0)== Win\)</span>}{<span class="math notranslate nohighlight">\(F(S_0):=S_0\)</span>}{<span class="math notranslate nohighlight">\(F(S_0):=\emptyset\)</span>}</p>
<p><span class="math notranslate nohighlight">\(\textsf{Passed}:=\{S_0\}\)</span>;<br />
// <span class="math notranslate nohighlight">\(\textsf{Passed}\)</span> stores all configurations for which <span class="math notranslate nohighlight">\(F\)</span> is defined</p>
<p><span class="math notranslate nohighlight">\(\textsf{Dep}(S_0):=\emptyset\)</span>;</p>
<p><span class="math notranslate nohighlight">\(\textsf{Wait}:=\{(S_0,\alpha,T) \mid 
    T= \sf Post_{\geq 0}( \sf Post_{\alpha}(S_0))\not=\emptyset, \alpha\text{ transition of } \mathcal{G}\}\)</span>;</p>
<p>\While{(<span class="math notranslate nohighlight">\(\textsf{Wait}\not=\emptyset\)</span> and <span class="math notranslate nohighlight">\((v_0,\mathbf 0)\notin F(S_0)\)</span>)}
{<span class="math notranslate nohighlight">\((S,\alpha,T)):=\Pop{ \textsf{Wait}}\)</span>;\
\If({// case <span class="math notranslate nohighlight">\(A\)</span>}){<span class="math notranslate nohighlight">\(T\in \textsf{Passed}\)</span>}
{<span class="math notranslate nohighlight">\(\textsf{Dep}(T):= \textsf{Dep}(T) \cup \{(S,\alpha,T)\}\)</span>;\
<span class="math notranslate nohighlight">\(W:= \sf Pred_{\geq 0}\left(F(S)\cup \bigcup_{\substack{S\xrightarrow{c} V\\ \!\!V\in \textsf{Passed}\!\!}}  \sf Pred_c(F(V)),\ \bigcup_{\substack{S\xrightarrow{u} V\\ \!\!V\in \textsf{Passed}\!\!}} \sf Pred_u(V\setminus F(V))\right) \cap S\)</span>;\
\If{<span class="math notranslate nohighlight">\(F(S) \subsetneq W\)</span>}{<span class="math notranslate nohighlight">\(F(S):=W\)</span>;\
<span class="math notranslate nohighlight">\(\textsf{Wait}:= \textsf{Wait}\cup \textsf{Dep}(S)\)</span>;}}
\Else({// case <span class="math notranslate nohighlight">\(B\)</span>})
{<span class="math notranslate nohighlight">\(\textsf{Passed}:= \textsf{Passed} \cup\{T\}\)</span>; \
\If{<span class="math notranslate nohighlight">\(c(T)== Win\)</span>}{<span class="math notranslate nohighlight">\(F(T):=T\)</span>\ <span class="math notranslate nohighlight">\(\textsf{Wait}:= \textsf{Wait}\cup\{(S,\alpha,T)\}\)</span>}
\Else{<span class="math notranslate nohighlight">\(F(T):=\emptyset\)</span>}
<span class="math notranslate nohighlight">\(\textsf{Dep}(T):=\{(S,\alpha,T)\}\)</span>;\
<span class="math notranslate nohighlight">\(\textsf{Wait}:= \textsf{Wait}\cup\{(T,\alpha,U) \mid U= \sf Post_{\geq 0}( \sf Post_{\alpha}(T))\not=\emptyset, \alpha\text{ transition of } \mathcal{G}\}\)</span>;
}
}
\leIf{<span class="math notranslate nohighlight">\((v_0,\mathbf 0)\in F(S_0)\)</span>}{\Return 1}{\Return 0}</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>    \caption{Symbolic on-the-fly algorithm for timed reachability}
</pre></div>
</div>
<p>\label{9-algo:sotftr}
\end{algorithm}</p>
<p>The correctness of the algorithm can be proven using the following
lemma. We omit the proof of this lemma, as it is tedious and and does
not contain any difficult argument.</p>
<div class="proof lemma admonition" id="9-lem:sotftr">
<p class="admonition-title"><span class="caption-number">Lemma 284 </span> (NEEDS TITLE 9-lem:sotftr)</p>
<div class="lemma-content section" id="proof-content">
<p>The following properties hold at the end of each run through
the <strong>while</strong> loop of <code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:sotftr</span></code>:</p>
<ul class="simple">
<li><p>for any <span class="math notranslate nohighlight">\(S\in \textsf{Passed}\)</span> and any transition <span class="math notranslate nohighlight">\(\alpha\)</span>, if
<span class="math notranslate nohighlight">\(T= \sf Post_{\geq 0}( \sf Post_\alpha(S))\not=\emptyset\)</span>,
then either <span class="math notranslate nohighlight">\((S,\alpha,T)\in \textsf{Wait}\)</span>, or
<span class="math notranslate nohighlight">\(T\in \textsf{Passed}\)</span> and <span class="math notranslate nohighlight">\((S,\alpha,T)\in \textsf{Dep}(T)\)</span>;</p></li>
<li><p>for any <span class="math notranslate nohighlight">\(S\in \textsf{Passed}\)</span> and <span class="math notranslate nohighlight">\(q\in F(S)\)</span>,  <span class="math notranslate nohighlight">\(q\)</span> is winning for Eve;</p></li>
<li><p>for any <span class="math notranslate nohighlight">\(S\in \textsf{Passed}\)</span> and <span class="math notranslate nohighlight">\(q\in S\setminus F(S)\)</span>,
either</p></li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$\textsf{Wait}$ contains a symbolic transition $(S,\alpha,S&#39;)$ from $S$
with $S&#39;\in \textsf{Passed}$,

or
</pre></div>
</div>
<div class="math notranslate nohighlight">
\[\begin{split}
      q\notin  \sf Pred_{\geq 0}\Bigl(F(S)\cup \bigcup_{\substack{S\xrightarrow{c} V\\ V\in \textsf{Passed}}}  \sf Pred_c(F(V)),\ \bigcup_{\substack{S\xrightarrow{u} V\\ V\in \textsf{Passed}}}  \sf Pred_u(V\setminus F(V))\Bigr) \cap S.
    \end{split}\]</div>
</div>
</div><p>The proof is omitted but can be found in <span id="id7">[<span>CDFLL05</span>]</span>.</p>
<p>Using these invariants, we get the following result:</p>
<div class="proof lemma admonition" id="lemma-3">
<p class="admonition-title"><span class="caption-number">Lemma 285 </span> (NEEDS TITLE AND LABEL)</p>
<div class="lemma-content section" id="proof-content">
<p>If <code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:sotftr</span></code> terminates, all configurations in <span class="math notranslate nohighlight">\(F(S)\)</span> for
any <span class="math notranslate nohighlight">\(S\in \textsf{Passed}\)</span> are winning for Eve;  if additionally
<span class="math notranslate nohighlight">\(\textsf{Wait}=\emptyset\)</span>, then all configurations in <span class="math notranslate nohighlight">\(S\setminus F(S)\)</span>, for
any <span class="math notranslate nohighlight">\(S\in \textsf{Passed}\)</span>, are losing for Eve.</p>
<p>If <code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:sotftr</span></code> terminates, all configurations in <span class="math notranslate nohighlight">\(F(S)\)</span> for
any <span class="math notranslate nohighlight">\(S\in \textsf{Passed}\)</span> are winning for Eve;  if additionally
<span class="math notranslate nohighlight">\(\textsf{Wait}=\emptyset\)</span>, then all configurations in <span class="math notranslate nohighlight">\(S\setminus F(S)\)</span>, for
any <span class="math notranslate nohighlight">\(S\in \textsf{Passed}\)</span>, are losing for Eve.</p>
</div>
</div><div class="dropdown tip admonition">
<p class="admonition-title">Proof</p>
<p>The first statement corresponds to the second statement of
<a class="reference internal" href="#9-lem:sotftr">Lemma 284</a>. Now, assume <span class="math notranslate nohighlight">\(\textsf{Wait}^n=\emptyset\)</span> after
termination at the <span class="math notranslate nohighlight">\(n\)</span>-th step,
and</p>
<p>let <span class="math notranslate nohighlight">\(L=\{q\in  \mathcal{L}\times\mathbb{R}_{\geq 0}^{ \mathcal{C}} \mid \exists
S\in \textsf{Passed}^n.\ q\in S\setminus F^n(S)\}\)</span>, and <span class="math notranslate nohighlight">\(M\)</span> be the complement
of <span class="math notranslate nohighlight">\(L\)</span>. For any <span class="math notranslate nohighlight">\(S\in \textsf{Passed}^n\)</span>, we then have <span class="math notranslate nohighlight">\(M\cap S\subseteq
F^n(S)\)</span>.</p>
<p>Pick <span class="math notranslate nohighlight">\(q\in \pi(M)\cup  Win\)</span>, where we abusively write <span class="math notranslate nohighlight">\(Win\)</span> to denote
all configurations with location colored <span class="math notranslate nohighlight">\(Win\)</span>. We prove that <span class="math notranslate nohighlight">\(q\in M\)</span>:</p>
<ul class="simple">
<li><p>if <span class="math notranslate nohighlight">\(q\in Win\)</span>: assume <span class="math notranslate nohighlight">\(q\in L\)</span>, and pick <span class="math notranslate nohighlight">\(S\in \textsf{Passed}^n\)</span> such
that <span class="math notranslate nohighlight">\(q\in S\setminus F^n(S)\)</span>. Since <span class="math notranslate nohighlight">\(q\in S\)</span>, it holds <span class="math notranslate nohighlight">\(c(S)= Win\)</span>;
but then <span class="math notranslate nohighlight">\(F^n(S)\)</span> is defined (since <span class="math notranslate nohighlight">\(S\in \textsf{Passed}^n\)</span>), and it
equals <span class="math notranslate nohighlight">\(S\)</span> by initialization of <span class="math notranslate nohighlight">\(F\)</span>. This contradicts the fact that
<span class="math notranslate nohighlight">\(q\in S\setminus F^n(S)\)</span>, hence <span class="math notranslate nohighlight">\(q\in M\)</span>.</p></li>
<li><p>if <span class="math notranslate nohighlight">\(q\in\pi(M)\)</span>: we again assume <span class="math notranslate nohighlight">\(q\in L\)</span>. Then for some
<span class="math notranslate nohighlight">\(S\in \textsf{Passed}^n\)</span>, <span class="math notranslate nohighlight">\(q\in S\setminus F^n(S)\)</span>. By the third property of
<a class="reference internal" href="#9-lem:sotftr">Lemma 284</a>, <span class="math notranslate nohighlight">\(q\notin W^n\)</span></p></li>
</ul>
<p>(because <span class="math notranslate nohighlight">\(\textsf{Wait}^n\)</span> is
empty).  Since <span class="math notranslate nohighlight">\(M\cap U \subseteq F^n(U)\)</span> for all <span class="math notranslate nohighlight">\(U\in \textsf{Passed}^n\)</span>
and <span class="math notranslate nohighlight">\(F^n(U)=\emptyset\)</span> for all <span class="math notranslate nohighlight">\(U\notin \textsf{Passed}^n\)</span>,
and by monotonicity, we get</p>
<div class="math notranslate nohighlight">
\[
  q\notin \sf Pred_{\geq 0}\Biggl((M\cap S)\cup \bigcup_{\substack{S\xrightarrow{c}
    V}}  \sf Pred_c(M\cap V),\ \bigcup_{\substack{S\xrightarrow{u}
    V}}  \sf Pred_u(V\setminus (M\cap V))\Biggr) \cap S.
  \]</div>
<p>Now, notice that any <span class="math notranslate nohighlight">\(S\in \textsf{Passed}^n\)</span> is closed under <span class="math notranslate nohighlight">\(\sf Post_{\geq 0}\)</span>. Then
\begin{xalignat*}1
\pi(M)\cap S &amp;=  \sf Pred_{\geq 0}(M\cup \sf Pred_c(M),  \sf Pred_u(\overline M)) \
&amp;=  \sf Pred_{\geq 0}((M\cap S)\cup ( \sf Pred_c(M)\cap S),  \sf Pred_u(\overline M)).
\end{xalignat*}
Now, it can be checked that <span class="math notranslate nohighlight">\(\sf Pred_c(M)\cap S \subseteq
  \bigcup_{\substack{S\xrightarrow{c} V}}  \sf Pred_c(M\cap V)\)</span> and
<span class="math notranslate nohighlight">\(\sf Pred_u(\overline M) \supseteq \bigcup_{\substack{S\xrightarrow{u}
      V}}  \sf Pred_u(V\setminus (M\cap V))\)</span>.  So the fact that <span class="math notranslate nohighlight">\(q\in
  \pi(M)\)</span> and <span class="math notranslate nohighlight">\(q\in S\)</span> leads to a contradiction. This entails that
<span class="math notranslate nohighlight">\(q\notin L\)</span>, hence <span class="math notranslate nohighlight">\(q\in M\)</span>.</p>
<p>In the end, we have proven that <span class="math notranslate nohighlight">\(\pi(M)\cup Win \subseteq M\)</span>, so that
<span class="math notranslate nohighlight">\(M\)</span> is a pre-fixpoint of <span class="math notranslate nohighlight">\(X\mapsto \pi(X)\cup Win\)</span>, hence it contains
all winning configurations of  Eve and <span class="math notranslate nohighlight">\(L\)</span> only contains losing
configurations.</p>
</div>
<p>The procedure given in <code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:sotftr</span></code> will in general not
terminate: as in the case of timed automata, the number of zones
generated by the algorithm may be infinite. This is classically
avoided using <strong>extrapolation</strong>: this consists in abstracting the
zones being considered by larger zones, defined by only using integer
constants less than the maximal constant appearing in the timed arena
(as we did for regions in the proof
of <a class="reference internal" href="backward_algorithm.html#9-thm:timed-control">Theorem 281</a>). This can be proven to preserve
correctness, and makes the number of zones finite. Termination follows
by noticing that any triple <span class="math notranslate nohighlight">\((S,\alpha,T)\)</span> may be added to <span class="math notranslate nohighlight">\(\textsf{Wait}\)</span> only
a finite number of times (bounded by the number of regions
in <span class="math notranslate nohighlight">\(T\)</span>).</p>
<p>We can then conclude:</p>
<div class="proof theorem admonition" id="theorem-4">
<p class="admonition-title"><span class="caption-number">Theorem 286 </span> (NEEDS TITLE AND LABEL)</p>
<div class="theorem-content section" id="proof-content">
<p><code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:sotftr</span></code> terminates when extrapolation is used, and returns <span class="math notranslate nohighlight">\(1\)</span> if, and only if,
<span class="math notranslate nohighlight">\((\ell_0,\mathbf{0})\)</span> is winning for  Eve.</p>
<p><code class="xref std std-numref docutils literal notranslate"><span class="pre">9-algo:sotftr</span></code> terminates when extrapolation is used, and returns <span class="math notranslate nohighlight">\(1\)</span> if, and only if,
<span class="math notranslate nohighlight">\((\ell_0,\mathbf{0})\)</span> is winning for  Eve.</p>
</div>
</div></div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./9_Timed"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="backward_algorithm.html" title="previous page">Backward Algorithm</a>
    <a class='right-next' id="next-link" href="references.html" title="next page">Bibliographic references</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By a set of authors coordinated by Nathana&euml;l Fijalkow<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>